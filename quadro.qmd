---
title: "NMAR"
format: 
  revealjs:
    theme: ["./quadro/q-theme.scss"]
    code-overflow: wrap
    highlight-style: a11y
    height: 1080
    width: 1920    
    scrollable: true  # Add this line
editor: visual
---

## NMAR - A novel `R Package`
### Estimation under Nonignorable Nonresponse in Official Surveys
<hr>


#### National Science Centre grant Poland (OPUS 20 grant no. 2020/39/B/HS4/00941)
<br>

#### dr Maciej BerÄ™sewicz (Poznan University of Business and Economics),<br> Igor KoÅ‚odziej (WUT - Faculty of Mathematics),<br> Mateusz Iwaniuk (WUT - Faculty of Mathematics)

<br>

> NMAR - Not Missing At Random

<div style="text-align: right;">
<img src="./logo.PNG" alt="Logo" style="height: 550px;position:fixed;right:50px;bottom:100px"/>
</div>

## NMAR assumptions:

1.  **Missing Data Structure**\
    We have $Y$ which contains NaNs. Each observation $x_i$ has its own $\delta_i$ which is 0 or 1:

> $$
> \delta_i = \begin{cases} 
> 1 & \text{if } y_i \text{ is observed} \\
> 0 & \text{if } y_i \text{ is missing}
> \end{cases}
> $$

2.  **Outcome Mechanism**\
    We have at least one column which affects $Y$ value:

    > $Y, \delta \sim X_1$

3.  **Response Mechanism**\
    Optionally we have columns which affect $Y$ visibility **but not** $Y$:

    > $\delta \sim X_2$
    
**Note**: In general, $X_1 \cap X_2 = \emptyset$, but this depends on the specific method implementation and assumptions.

## Practical Example: Salary Survey

**Scenario**: Richer people tend not to answer questions about salary

> $Y$: Salary (with missing values) <br> $\delta$: Response indicator (1 = answered, 0 = refused)

<br>

**Outcome Mechanism** :

> $Y, \delta \sim \text{experience} + \text{education}$

<br>

**Response Mechanism**:

If we assume gender affects response likelihood but not salary value itself)

> $\delta \sim \text{gender}$

## But does it work?
<div style="text-align: center;">
<img src="./quadro/boxplots.png" alt="Simulation Results" style="width: 70%;"/>
</div>
> NMAR estimators are closer to true population mean compared to MAR (Naive) estimators




## Exponential tilting approach
### A Propensity-score-adjustment Method For Nonignorable Nonresponse (Aka `Exponential Tilting`)

#### Minsun Kim Riddles<br> Jae Kwang Kim<br> Jongho Im

<hr>

<br><br><br><br>

-   Author of this paper gained PhD for their solution
-   I will highlight **overview concept** rather than go in details\
-   It took me few weeks to understand it, thus I am not able to explain this in 3 minutes ðŸ¤«

<br>

<br>

## Method Steps

::: {style="font-size: 30px;"}
### 1. Estimate Observed Distribution

> $$
> \hat{f}_1(y) = f(y | X_1, \delta = 1)
> $$

### 2. Compute Score Components

<!-- > $$ -->

<!-- S_{\text{obs}} = \sum_{j:\delta_j=1} s(y_j, X_{1j}) -->

<!-- $$ -->

<!-- $$ -->

<!-- S_{\text{mis}} = \sum_{j:\delta_j=0} \sum_i w_{ij} \cdot s(y_i, X_{1i}) -->

<!-- $$ -->

> $S_{\text{obs}} = \sum_{j:\delta_j=1} s(y_j, X_{1j})$, \quad $S_{\text{mis}} = \sum_{j:\delta_j=1} \sum_{i:\delta_i=0} w_{ij} \cdot s(y_j, X_{1i})$

where $w_{ij}$ depends on $\hat{f}_1$ and odds ratio

### 3. Solve Final Equation

> $$
> S_{\text{total}} = S_{\text{obs}} + S_{\text{mis}} = 0
> $$

### 4. Estimate Population Mean

> $$
> \mathbb{E}[Y] = \hat{\theta} = \frac{\sum_{i:\delta_i=1} \frac{1}{\pi_i(\hat{\boldsymbol{\phi}}_p)} y_i}{\sum_{i:\delta_i=1} \frac{1}{\pi_i(\hat{\boldsymbol{\phi}}_p)}}
> $$

### Key Insight:

We never fill in missing values - we reweight observed data to represent the entire population!
:::

## NMAR Package Demonstration

```{r}
#| echo: false
#| message: false
#| warning: false
devtools::load_all()
```

```{r}
#| echo: false
#| message: false
# Function to generate testdata, basing on riddle(2016)
generate_test_data <- function(n_rows = 500, n_cols = 1, case = 1, x_var = 0.5, eps_var = 0.9, a = 0.8, b = -0.2) {
# Generate X variables - fixed to match comparison
  X <- as.data.frame(replicate(n_cols, rnorm(n_rows, 0, sqrt(x_var))))
  colnames(X) <- paste0("x", 1:n_cols)

# Generate Y - fixed coefficients to match comparison
  eps <- rnorm(n_rows, 0, sqrt(eps_var))
  if (case == 1) {
# Use fixed coefficient of 1 for all x variables to match: y = -1 + x1 + epsilon
    X$Y <- as.vector(-1 + as.matrix(X) %*% rep(1, n_cols) + eps)
  }
  else if (case == 2) {
    X$Y <- -2 + 0.5 * exp(as.matrix(X) %*% rep(1, n_cols)) + eps
  }
  else if (case == 3) {
    X$Y <- -1 + sin(2 * as.matrix(X) %*% rep(1, n_cols)) + eps
  }
  else if (case == 4) {
    X$Y <- -1 + 0.4 * as.matrix(X)^3 %*% rep(1, n_cols) + eps
  }

  Y_original <- X$Y

# Missingness mechanism - identical to comparison
  pi_obs <- 1 / (1 + exp(-(a + b * X$Y)))

# Create missing values
  mask <- runif(nrow(X)) > pi_obs
  mask[1] <- FALSE # Ensure at least one observation is not missing
  X$Y[mask] <- NA

  return(list(X = X, Y_original = Y_original))
}

set.seed(1109)
res_test_data <- generate_test_data(n_rows = 500, n_cols = 2, case = 1)
x <- res_test_data$X
y_original <- res_test_data$Y_original # to compare with true values
```

```{r}
#| echo: true
#| message: false
#| warning: false
exptilt_config <- exptilt_engine(
  y_dens = 'normal',
  control = list(maxit = 10),
  stopping_threshold = 0.01,
  standardize = FALSE,
  family = 'logit',
  bootstrap_reps = 20,
  variance_method = 'bootstrap'
)
formula = Y ~ x1 + x2
res <- nmar(formula = formula, data = x, engine = exptilt_config, response_predictors = NULL)
```

```{r}
#| echo: true
#| message: false
#| warning: false
print(res)
```

```{r}
#| echo: true
#| message: false
#| warning: false
coef(res)
```

```{r}
#| echo: false
#| message: false
#| warning: false
cat('True Y mean:          ', sprintf('%.4f', mean(y_original)), '\n')
est <- as.numeric(res$y_hat)
se <- res$se
cat('Est Y mean (NMAR):    ', sprintf('%.4f', est),
    '  3Ïƒ interval: (', sprintf('%.4f', est - 1.5 * se),
    ', ', sprintf('%.4f', est + 1.5 * se), 'Ïƒ=', sprintf('%.4f', se), ')\n')
cat('Naive Y mean (MAR):   ', sprintf('%.4f', mean(x[!is.na(x$Y), 'Y'])), '\n')
```
