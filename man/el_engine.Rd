% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/engines_el_engine.R
\name{el_engine}
\alias{el_engine}
\title{Empirical likelihood (EL) engine for NMAR}
\usage{
el_engine(
  standardize = TRUE,
  trim_cap = Inf,
  on_failure = c("return", "error"),
  variance_method = c("bootstrap", "none"),
  bootstrap_reps = 500,
  auxiliary_means = NULL,
  control = list(),
  strata_augmentation = TRUE,
  n_total = NULL,
  start = NULL,
  family = c("logit", "probit")
)
}
\arguments{
\item{standardize}{logical; standardize predictors. Default \code{TRUE}.}

\item{trim_cap}{numeric; cap for EL weights (\code{Inf} = no trimming).}

\item{on_failure}{character; \code{"return"} or \code{"error"} on solver failure.}

\item{variance_method}{character; one of \code{"bootstrap"} or \code{"none"}.}

\item{bootstrap_reps}{integer; number of bootstrap replicates when
\code{variance_method = "bootstrap"}.}

\item{auxiliary_means}{named numeric vector; population means for auxiliary
design columns. Names must match the materialized model.matrix column names
on the first RHS (after formula expansion), e.g., factor indicators like
`F_b` or transformed terms `I(X^2)`. Auxiliary intercepts are always
dropped automatically, so do not supply `(Intercept)`. Optional.}

\item{control}{list; optional solver control for \code{nleqslv::nleqslv()}.
Recognized fields (defaults in parentheses):
\itemize{
  \item Top-level: \code{global} = \code{"qline"} (quadratic line search) or one of
    \code{"dbldog"}, \code{"pwldog"}, \code{"cline"}, \code{"gline"}, \code{"hook"}, \code{"none"};
    \code{xscalm} = \code{"auto"} or \code{"fixed"}
  \item In \code{control=}: \code{xtol}, \code{ftol}, \code{btol}, \code{maxit}, \code{trace},
    \code{stepmax}, \code{delta}, \code{allowSing}
}
Unknown names are ignored. For \code{data.frame} inputs the EL system is
solved by Newton with an analytic Jacobian; for \code{survey.design}
inputs a design-weighted analogue is solved with an analytic Jacobian
when available or numeric/Broyden Jacobians otherwise.}

\item{strata_augmentation}{logical; when \code{TRUE} (default), survey designs
with an identifiable strata structure are augmented with stratum indicators
and corresponding population shares in the auxiliary block (Wu-style
strata augmentation). Has no effect for \code{data.frame} inputs or
survey designs without strata.}

\item{n_total}{numeric; optional when supplying respondents-only data (no \code{NA} in the
outcome). For \code{data.frame} inputs, set to the total number of sampled units
before filtering to respondents. For \code{survey.design} inputs, set to the total
design weight or known population total. If omitted and the outcome contains no NAs,
the estimator errors, requesting \code{n_total}.}

\item{start}{list; optional starting point for the solver. Fields:
\itemize{
  \item \code{beta}: named numeric vector of missingness-model coefficients on the
    original (unscaled) scale, including \code{(Intercept)}.
  \item \code{W} or \code{z}: starting value for population response rate (\code{0 < W < 1})
    or its logit (\code{z}). If both are provided, \code{z} takes precedence.
  \item \code{lambda}: named numeric vector of auxiliary multipliers on the original
    scale (names must match auxiliary design columns; no intercept). Values
    are mapped to the scaled space internally.
}}

\item{family}{character; missingness (response) model family, either \code{"logit"} or \code{"probit"},
or a family object created by \code{logit_family()} / \code{probit_family()}.}
}
\value{
A list of class \code{"nmar_engine_el"} (also inheriting from \code{"nmar_engine"})
containing configuration fields to be supplied to \code{nmar()}. Users rarely
access fields directly; instead, pass the engine to \code{nmar()} together with a
formula and data.
}
\description{
Constructs a configuration object for the empirical likelihood estimator under
nonignorable nonresponse (NMAR) with optional auxiliary moment constraints.
For \code{data.frame} inputs (IID setting) the estimator solves a stacked
system in \eqn{\theta = (\beta, z, \lambda_x)} with \eqn{z = \operatorname{logit}(W)}
using a Newton method with an analytic Jacobian and globalization via
\link[nleqslv]{nleqslv}. For \code{survey.design} inputs it solves a
design-weighted analogue in \eqn{\theta = (\beta, z, \lambda_W, \lambda_x)}.
When the response family supplies second derivatives (logit and probit) an
analytic Jacobian is used; otherwise the solver falls back to numeric/Broyden
Jacobians. Numerical safeguards (bounded linear predictor, link-inverse
clipping, denominator floors, and stable linear algebra) improve robustness.
Pass the engine to \link{nmar} together with a formula and data.
}
\details{
This engine implements an empirical likelihood estimator for NMAR response
based on Qin, Leung and Shao (2002) for IID data, and a design-weighted
analogue for complex survey designs inspired by Chen and Sitter (1999) and
Wu (2005). For \code{data.frame} inputs the unknowns are \code{(beta, z, lambda_x)}
with \code{z = logit(W)}, and the QLS closed-form identity is used to profile
out the multiplier \code{lambda_W}. For \code{survey.design} inputs the system
is extended to \code{(beta, z, lambda_W, lambda_x)} and solved with design
weights and, when present, Wu-style strata augmentation in the auxiliary
block. Numerical guards (capped linear predictors, clipped response
probabilities, denominator floors) are applied consistently in equations and
Jacobians.

\strong{Formula syntax}: \code{nmar()} supports a partitioned right-hand side
\code{y_miss ~ aux1 + aux2 | z1 + z2}. Variables left of \code{|} are auxiliaries
(used in EL moment constraints); variables right of \code{|} are missingness-model
predictors only. The outcome appears on the left-hand side and is included as a
response predictor by default. Auxiliary design matrices are constructed with
an intercept dropped automatically; missingness models always include an
intercept even if the formula uses \code{-1} or \code{+0}.

\strong{Variance}: The EL engine supports bootstrap standard errors via
\code{variance_method = "bootstrap"} or can skip variance with
\code{variance_method = "none"}.
}
\section{Progress Reporting}{

When \code{variance_method = "bootstrap"}, progress reporting is available via the
\code{progressr} package. To enable it:

\preformatted{
library(progressr)
library(future)

# Enable progress reporting
handlers(global = TRUE)
handlers("txtprogressbar")  # or "progress", "cli", etc.

# Set parallel backend (optional)
plan(multisession, workers = 4)

# Always set seed for reproducibility
set.seed(123)

# Run with progress bar
result <- nmar(Y ~ X, data = df,
               engine = el_engine(variance_method = "bootstrap",
                                  bootstrap_reps = 500))

# Reset to sequential
plan(sequential)
}

To disable progress in simulations or batch jobs:

\code{handlers("void")  # Silent}

If progressr is not installed or no handlers are set, bootstrap runs silently
(default behavior). Progress reporting works with all future backends and does
not affect reproducibility.
}

\examples{
\donttest{
set.seed(1)
n <- 200
X <- rnorm(n)
Z <- rnorm(n)
Y <- 2 + 0.5 * X + Z
p <- plogis(-0.7 + 0.4 * scale(Y)[, 1])
R <- runif(n) < p
df <- data.frame(Y_miss = Y, X = X)
df$Y_miss[!R] <- NA_real_
eng <- el_engine(auxiliary_means = c(X = 0), variance_method = "none")
fit <- nmar(Y_miss ~ X, data = df, engine = eng)
summary(fit)

# Response-only predictors can be placed to the right of `|`:
df2 <- data.frame(Y_miss = Y, X = X, Z = Z)
df2$Y_miss[!R] <- NA_real_
eng2 <- el_engine(auxiliary_means = c(X = 0), variance_method = "none")
fit2 <- nmar(Y_miss ~ X | Z, data = df2, engine = eng2)
print(fit2)

# Survey design usage
if (requireNamespace("survey", quietly = TRUE)) {
  des <- survey::svydesign(ids = ~1, weights = ~1, data = df)
  eng3 <- el_engine(auxiliary_means = c(X = 0), variance_method = "none")
  fit3 <- nmar(Y_miss ~ X, data = des, engine = eng3)
  summary(fit3)
}
}
}
\references{
Qin, J., Leung, D., and Shao, J. (2002). Estimation with survey data under
nonignorable nonresponse or informative sampling. Journal of the American Statistical
Association, 97(457), 193-200.

Chen, J., and Sitter, R. R. (1999). A pseudo empirical likelihood approach for
complex survey data. Biometrika, 86(2), 373-385.

Wu, C. (2005). Algorithms and R codes for the pseudo empirical likelihood method
in survey sampling. Canadian Journal of Statistics, 33(3), 497-509.
}
\seealso{
[nmar()], [weights.nmar_result()], [summary.nmar_result]
}
\keyword{engine}
