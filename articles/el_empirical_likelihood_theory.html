<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Empirical Likelihood Theory for NMAR ‚Ä¢ NMAR</title>
<!-- favicons --><link rel="icon" type="image/png" sizes="96x96" href="../favicon-96x96.png">
<link rel="icon" type="‚Äùimage/svg+xml‚Äù" href="../favicon.svg">
<link rel="apple-touch-icon" sizes="180x180" href="../apple-touch-icon.png">
<link rel="icon" sizes="any" href="../favicon.ico">
<link rel="manifest" href="../site.webmanifest">
<script src="../lightswitch.js"></script><script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Empirical Likelihood Theory for NMAR">
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top " aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">NMAR</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.1.1</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="active nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles">
<li><hr class="dropdown-divider"></li>
    <li><h6 class="dropdown-header" data-toc-skip>Tutorials</h6></li>
    <li><a class="dropdown-item" href="../articles/tutorial_empirical_likelihood.html">Empirical Likelihood</a></li>
    <li><a class="dropdown-item" href="../articles/tutorial_exptilt.html">Exponential Tilting</a></li>
    <li><a class="dropdown-item" href="../articles/tutorial_exptilt_nonparam.html">Exponential Tilting (Nonparametric)</a></li>
    <li><hr class="dropdown-divider"></li>
    <li><h6 class="dropdown-header" data-toc-skip>Theory</h6></li>
    <li><a class="dropdown-item" href="../articles/el_empirical_likelihood_theory.html">Empirical Likelihood Theory for NMAR</a></li>
    <li><a class="dropdown-item" href="../articles/exptilt_theory.html">Exponential Tilting Theory</a></li>
    <li><a class="dropdown-item" href="../articles/exptilt_nonparam_theory.html">Nonparametric Exponential Tilting Theory</a></li>
    <li><hr class="dropdown-divider"></li>
    <li><a class="dropdown-item" href="../articles/index.html">More articles...</a></li>
  </ul>
</li>
<li class="nav-item"><a class="nav-link" href="../news/index.html">Changelog</a></li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json">
</form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/ncn-foreigners/NMAR/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="../logo.png" class="logo" alt=""><h1>Empirical Likelihood Theory for NMAR</h1>
            
      
      <small class="dont-index">Source: <a href="https://github.com/ncn-foreigners/NMAR/blob/package-dev/vignettes/el_empirical_likelihood_theory.Rmd" class="external-link"><code>vignettes/el_empirical_likelihood_theory.Rmd</code></a></small>
      <div class="d-none name"><code>el_empirical_likelihood_theory.Rmd</code></div>
    </div>

    
    
<p>This vignette summarizes the key mathematical objects and
estimating-equation derivations behind the empirical likelihood (EL)
estimator implemented in the <code>nmar</code> package, and maps them to
code. It covers both data-frame (IID) and survey design use cases,
allows arbitrary numbers of response-model and auxiliary covariates, and
supports both logit and probit response families.</p>
<div class="section level2">
<h2 id="notation">Notation<a class="anchor" aria-label="anchor" href="#notation"></a>
</h2>
<div class="section level3">
<h3 id="units">Units<a class="anchor" aria-label="anchor" href="#units"></a>
</h3>
<ul>
<li>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>‚Ä¶</mi><mo>,</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">i = 1, \ldots, n</annotation></semantics></math>
index respondents (those with observed
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Y</mi><annotation encoding="application/x-tex">Y</annotation></semantics></math>)</li>
<li>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>i</mi></msub><mo>‚àà</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">R_i \in \{0, 1\}</annotation></semantics></math>
is the response indicator; we work on observed subset
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>i</mi></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">R_i = 1</annotation></semantics></math>
</li>
</ul>
</div>
<div class="section level3">
<h3 id="data">Data<a class="anchor" aria-label="anchor" href="#data"></a>
</h3>
<ul>
<li>
<strong>Outcome</strong>:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Y</mi><mi>i</mi></msub><annotation encoding="application/x-tex">Y_i</annotation></semantics></math>
(observed when
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>i</mi></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">R_i = 1</annotation></semantics></math>;
missing otherwise)</li>
<li>
<strong>Response covariates</strong>: row vector
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Z</mi><mi>i</mi></msub><mo>‚àà</mo><msup><mi>‚Ñù</mi><mi>K</mi></msup></mrow><annotation encoding="application/x-tex">Z_i \in \mathbb{R}^K</annotation></semantics></math>,
the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>th
row of the missingness-model design matrix built from the formula as an
intercept, the LHS outcome expression (evaluated in the model frame),
and any additional missingness predictors on the RHS after
<code>|</code>
</li>
<li>
<strong>Auxiliary covariates</strong>: row vector
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mi>i</mi></msub><mo>‚àà</mo><msup><mi>‚Ñù</mi><mi>L</mi></msup></mrow><annotation encoding="application/x-tex">X_i \in \mathbb{R}^L</annotation></semantics></math>
(possibly
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">L = 0</annotation></semantics></math>),
from auxiliary RHS (no intercept)</li>
<li>
<strong>Population auxiliary means</strong>:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Œº</mi><mi>x</mi></msub><mo>‚àà</mo><msup><mi>‚Ñù</mi><mi>L</mi></msup></mrow><annotation encoding="application/x-tex">\mu_x \in \mathbb{R}^L</annotation></semantics></math>,
known; names match columns of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math>
</li>
</ul>
<p>Mapping to code: - <code>response_model_matrix</code> (the
<code>missingness_design</code> in <code><a href="../reference/el_prepare_inputs.html">el_prepare_inputs()</a></code>)
corresponds to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Z</mi><annotation encoding="application/x-tex">Z</annotation></semantics></math>
and has columns: <code>(Intercept)</code>, the evaluated LHS outcome
expression, and any RHS2 predictors (after the <code>|</code> in the
formula) - <code>auxiliary_matrix</code> corresponds to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math>
(no intercept); we center it in code as
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>‚àí</mo><msub><mi>Œº</mi><mi>x</mi></msub></mrow><annotation encoding="application/x-tex">X - \mu_x</annotation></semantics></math></p>
</div>
<div class="section level3">
<h3 id="response-model-family-functions">Response Model (Family functions)<a class="anchor" aria-label="anchor" href="#response-model-family-functions"></a>
</h3>
<ul>
<li>
<strong>Linear predictor</strong>:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Œ∑</mi><mi>i</mi></msub><mo>=</mo><msub><mi>Z</mi><mi>i</mi></msub><mspace width="0.167em"></mspace><mi>Œ≤</mi></mrow><annotation encoding="application/x-tex">\eta_i = Z_i \, \beta</annotation></semantics></math>
</li>
<li>
<strong>Response probability</strong>:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mi>i</mi></msub><mo>‚â°</mo><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Œ∑</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mrow><mi mathvariant="normal">l</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">k</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">v</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Œ∑</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">w_i \equiv g(\eta_i) = \mathrm{linkinv}(\eta_i)</annotation></semantics></math>
</li>
<li>
<strong>First derivative</strong>:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac displaystyle="true"><mrow><mi>d</mi><mi>w</mi></mrow><mrow><mi>d</mi><mi>Œ∑</mi></mrow></mfrac><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Œ∑</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msub><mi>Œº</mi><mrow><mi>Œ∑</mi><mo>,</mo><mi>i</mi></mrow></msub><mo>=</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">a</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Œ∑</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\dfrac{dw}{d\eta}(\eta_i) = \mu_{\eta,i} = \mathrm{mu.eta}(\eta_i)</annotation></semantics></math>
</li>
<li>
<strong>Second derivative</strong>:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac displaystyle="true"><mrow><msup><mi>d</mi><mn>2</mn></msup><mi>w</mi></mrow><mrow><mi>d</mi><msup><mi>Œ∑</mi><mn>2</mn></msup></mrow></mfrac><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Œ∑</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mrow><mi mathvariant="normal">d</mi><mn mathvariant="normal">2</mn><mi mathvariant="normal">m</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">a</mi><mn mathvariant="normal">2</mn></mrow><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Œ∑</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\dfrac{d^2 w}{d\eta^2}(\eta_i) = \mathrm{d2mu.deta2}(\eta_i)</annotation></semantics></math>
Here <code>linkinv</code>, <code>mu.eta</code>, and
<code>d2mu.deta2</code> refer to the chosen response family (logit or
probit). We follow the paper‚Äôs
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>w</mi><mi>i</mi></msub><annotation encoding="application/x-tex">w_i</annotation></semantics></math>
notation for the response probability and reserve
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>p</mi><mi>i</mi><mtext mathvariant="normal">EL</mtext></msubsup><annotation encoding="application/x-tex">p_i^{\text{EL}}</annotation></semantics></math>
for empirical-likelihood weights.</li>
</ul>
</div>
<div class="section level3">
<h3 id="weight-re-parameterization">Weight Re-parameterization<a class="anchor" aria-label="anchor" href="#weight-re-parameterization"></a>
</h3>
<ul>
<li>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mo>‚àà</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">W \in (0,1)</annotation></semantics></math>
nuisance scalar; we parameterize via
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi><mo>=</mo><mtext mathvariant="normal">logit</mtext><mrow><mo stretchy="true" form="prefix">(</mo><mi>W</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">z = \text{logit}(W)</annotation></semantics></math>
for stability and set
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mo>=</mo><mtext mathvariant="normal">plogis</mtext><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">W = \text{plogis}(z)</annotation></semantics></math>
</li>
<li>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Œª</mi><mi>W</mi></msub><mo>‚àà</mo><mi>‚Ñù</mi></mrow><annotation encoding="application/x-tex">\lambda_W \in \mathbb{R}</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Œª</mi><mi>x</mi></msub><mo>‚àà</mo><msup><mi>‚Ñù</mi><mi>L</mi></msup></mrow><annotation encoding="application/x-tex">\lambda_x \in \mathbb{R}^L</annotation></semantics></math>
are EL Lagrange multipliers for the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>W</mi><annotation encoding="application/x-tex">W</annotation></semantics></math>-constraint
and the auxiliary constraints</li>
</ul>
</div>
<div class="section level3">
<h3 id="el-weights">EL Weights<a class="anchor" aria-label="anchor" href="#el-weights"></a>
</h3>
<ul>
<li>
<strong>Denominator</strong>:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>i</mi></msub><mo>=</mo><mn>1</mn><mo>+</mo><msub><mi>Œª</mi><mi>W</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>w</mi><mi>i</mi></msub><mo>‚àí</mo><mi>W</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>X</mi><mi>i</mi></msub><mo>‚àí</mo><msub><mi>Œº</mi><mi>x</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>T</mi></msup><msub><mi>Œª</mi><mi>x</mi></msub></mrow><annotation encoding="application/x-tex">D_i = 1 + \lambda_W (w_i - W) + (X_i - \mu_x)^T \lambda_x</annotation></semantics></math>
</li>
<li>
<strong>Base sampling weights</strong>:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">a_i = 1</annotation></semantics></math>
(IID) or
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo>=</mo></mrow><annotation encoding="application/x-tex">a_i =</annotation></semantics></math>
survey base weight for respondent
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>
</li>
<li>
<strong>EL weights for respondents</strong>:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>p</mi><mi>i</mi><mtext mathvariant="normal">EL</mtext></msubsup><mo>‚àù</mo><msub><mi>a</mi><mi>i</mi></msub><mi>/</mi><msub><mi>D</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">p_i^{\text{EL}} \propto a_i / D_i</annotation></semantics></math>
(proportionality normalized by totals below)</li>
</ul>
</div>
<div class="section level3">
<h3 id="estimator">Estimator<a class="anchor" aria-label="anchor" href="#estimator"></a>
</h3>
<ul>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>Y</mi><mo accent="true">ÃÇ</mo></mover><mo>=</mo><mo>‚àë</mo><msubsup><mi>p</mi><mi>i</mi><mtext mathvariant="normal">EL</mtext></msubsup><msub><mi>Y</mi><mi>i</mi></msub><mi>/</mi><mo>‚àë</mo><msubsup><mi>p</mi><mi>i</mi><mtext mathvariant="normal">EL</mtext></msubsup></mrow><annotation encoding="application/x-tex">\hat{Y} = \sum p_i^{\text{EL}} Y_i / \sum p_i^{\text{EL}}</annotation></semantics></math></li>
</ul>
</div>
<div class="section level3">
<h3 id="notation-at-a-glance">Notation at a Glance<a class="anchor" aria-label="anchor" href="#notation-at-a-glance"></a>
</h3>
<table class="table">
<colgroup>
<col width="50%">
<col width="50%">
</colgroup>
<thead><tr class="header">
<th>Symbol</th>
<th>Meaning</th>
</tr></thead>
<tbody>
<tr class="odd">
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math></td>
<td>Respondent index (rows with observed
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Y</mi><annotation encoding="application/x-tex">Y</annotation></semantics></math>)</td>
</tr>
<tr class="even">
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Y</mi><mi>i</mi></msub><annotation encoding="application/x-tex">Y_i</annotation></semantics></math></td>
<td>Outcome for unit
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>
(observed if
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>i</mi></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">R_i=1</annotation></semantics></math>)</td>
</tr>
<tr class="odd">
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Z</mi><mi>i</mi></msub><annotation encoding="application/x-tex">Z_i</annotation></semantics></math></td>
<td>Row of response design matrix (includes intercept)</td>
</tr>
<tr class="even">
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>X</mi><mi>i</mi></msub><annotation encoding="application/x-tex">X_i</annotation></semantics></math></td>
<td>Row of auxiliary design (no intercept)</td>
</tr>
<tr class="odd">
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Œº</mi><mi>x</mi></msub><annotation encoding="application/x-tex">\mu_x</annotation></semantics></math></td>
<td>Known population means of auxiliaries (vector)</td>
</tr>
<tr class="even">
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Œ≤</mi><annotation encoding="application/x-tex">\beta</annotation></semantics></math></td>
<td>Response-model coefficients</td>
</tr>
<tr class="odd">
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Œ∑</mi><mi>i</mi></msub><mo>=</mo><msub><mi>Z</mi><mi>i</mi></msub><mi>Œ≤</mi></mrow><annotation encoding="application/x-tex">\eta_i=Z_i\beta</annotation></semantics></math></td>
<td>Linear predictor for response model</td>
</tr>
<tr class="even">
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>w</mi><mi>i</mi></msub><annotation encoding="application/x-tex">w_i</annotation></semantics></math></td>
<td>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">l</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">k</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">v</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Œ∑</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathrm{linkinv}(\eta_i)</annotation></semantics></math>
(logit:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">p</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">g</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">s</mi></mrow><annotation encoding="application/x-tex">\mathrm{plogis}</annotation></semantics></math>;
probit:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Œ¶</mi><annotation encoding="application/x-tex">\Phi</annotation></semantics></math>)</td>
</tr>
<tr class="odd">
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Œº</mi><mrow><mi>Œ∑</mi><mo>,</mo><mi>i</mi></mrow></msub><annotation encoding="application/x-tex">\mu_{\eta,i}</annotation></semantics></math></td>
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac displaystyle="true"><mrow><mi>d</mi><msub><mi>w</mi><mi>i</mi></msub></mrow><mrow><mi>d</mi><msub><mi>Œ∑</mi><mi>i</mi></msub></mrow></mfrac><annotation encoding="application/x-tex">\dfrac{dw_i}{d\eta_i}</annotation></semantics></math></td>
</tr>
<tr class="even">
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Œª</mi><mi>W</mi></msub><annotation encoding="application/x-tex">\lambda_W</annotation></semantics></math></td>
<td>Multiplier for the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>W</mi><annotation encoding="application/x-tex">W</annotation></semantics></math>-constraint
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>‚àë</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>w</mi><mi>i</mi></msub><mo>‚àí</mo><mi>W</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>/</mi><msub><mi>D</mi><mi>i</mi></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\sum (w_i-W)/D_i=0</annotation></semantics></math>
</td>
</tr>
<tr class="odd">
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Œª</mi><mi>x</mi></msub><annotation encoding="application/x-tex">\lambda_x</annotation></semantics></math></td>
<td>Multipliers for auxiliary constraints
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>‚àë</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>X</mi><mi>i</mi></msub><mo>‚àí</mo><msub><mi>Œº</mi><mi>x</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>/</mi><msub><mi>D</mi><mi>i</mi></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\sum (X_i-\mu_x)/D_i=0</annotation></semantics></math>
</td>
</tr>
<tr class="even">
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>D</mi><mi>i</mi></msub><annotation encoding="application/x-tex">D_i</annotation></semantics></math></td>
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>+</mo><msub><mi>Œª</mi><mi>W</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>w</mi><mi>i</mi></msub><mo>‚àí</mo><mi>W</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>X</mi><mi>i</mi></msub><mo>‚àí</mo><msub><mi>Œº</mi><mi>x</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>T</mi></msup><msub><mi>Œª</mi><mi>x</mi></msub></mrow><annotation encoding="application/x-tex">1+\lambda_W(w_i-W)+(X_i-\mu_x)^T\lambda_x</annotation></semantics></math></td>
</tr>
<tr class="odd">
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>a</mi><mi>i</mi></msub><annotation encoding="application/x-tex">a_i</annotation></semantics></math></td>
<td>Base weight (IID: 1; survey: design weight)</td>
</tr>
<tr class="even">
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>p</mi><mi>i</mi><mrow><mi mathvariant="normal">E</mi><mi mathvariant="normal">L</mi></mrow></msubsup><annotation encoding="application/x-tex">p_i^{\mathrm{EL}}</annotation></semantics></math></td>
<td>Empirical-likelihood weight
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>‚àù</mo><msub><mi>a</mi><mi>i</mi></msub><mi>/</mi><msub><mi>D</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\propto a_i/D_i</annotation></semantics></math>
</td>
</tr>
<tr class="odd">
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>Y</mi><mo accent="true">ÃÇ</mo></mover><annotation encoding="application/x-tex">\hat Y</annotation></semantics></math></td>
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>‚àë</mo><msubsup><mi>p</mi><mi>i</mi><mrow><mi mathvariant="normal">E</mi><mi mathvariant="normal">L</mi></mrow></msubsup><msub><mi>Y</mi><mi>i</mi></msub><mi>/</mi><mo>‚àë</mo><msubsup><mi>p</mi><mi>i</mi><mrow><mi mathvariant="normal">E</mi><mi mathvariant="normal">L</mi></mrow></msubsup></mrow><annotation encoding="application/x-tex">\sum p_i^{\mathrm{EL}} Y_i/\sum p_i^{\mathrm{EL}}</annotation></semantics></math></td>
</tr>
<tr class="even">
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>Œ∏</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">F(\theta)</annotation></semantics></math></td>
<td>Stacked estimating system (beta, W, constraints)</td>
</tr>
<tr class="odd">
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math></td>
<td>Jacobian
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>‚àÇ</mi><mi>F</mi><mi>/</mi><mi>‚àÇ</mi><mi>Œ∏</mi></mrow><annotation encoding="application/x-tex">\partial F/\partial \theta</annotation></semantics></math>
</td>
</tr>
</tbody>
</table>
<p>Note: QLS use
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Œ∏</mi><annotation encoding="application/x-tex">\theta</annotation></semantics></math>
for the response-model parameter; in this vignette that parameter is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Œ≤</mi><annotation encoding="application/x-tex">\beta</annotation></semantics></math>.
We use
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Œ∏</mi><annotation encoding="application/x-tex">\theta</annotation></semantics></math>
for the full stacked unknown vector solved by the EL engine.</p>
</div>
<div class="section level3">
<h3 id="engines">Engines<a class="anchor" aria-label="anchor" href="#engines"></a>
</h3>
<ul>
<li>Family: ‚Äúlogit‚Äù (default) or ‚Äúprobit‚Äù. For respondents
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>i</mi></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">R_i = 1</annotation></semantics></math>),
the score with respect to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Œ∑</mi><annotation encoding="application/x-tex">\eta</annotation></semantics></math>
is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub><mo>=</mo><mi>‚àÇ</mi><mo>log</mo><msub><mi>w</mi><mi>i</mi></msub><mi>/</mi><mi>‚àÇ</mi><msub><mi>Œ∑</mi><mi>i</mi></msub><mo>=</mo><msub><mi>Œº</mi><mrow><mi>Œ∑</mi><mo>,</mo><mi>i</mi></mrow></msub><mi>/</mi><msub><mi>w</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">s_i = \partial\log w_i/\partial\eta_i = \mu_{\eta,i}/w_i</annotation></semantics></math>
(equals
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>‚àí</mo><msub><mi>w</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">1 - w_i</annotation></semantics></math>
for logit and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>œï</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Œ∑</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>/</mi><mi>Œ¶</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Œ∑</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\phi(\eta_i)/\Phi(\eta_i)</annotation></semantics></math>
for probit). In code we compute these using stable log-domain formulas
for probit and clip probabilities away from 0 and 1 when they appear in
ratios.</li>
<li>Scaling: optional standardization of design matrices and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Œº</mi><mi>x</mi></msub><annotation encoding="application/x-tex">\mu_x</annotation></semantics></math>
via <code>nmar_scaling_recipe</code>
</li>
</ul>
</div>
</div>
<div class="section level2">
<h2 id="data-and-interface-constraints">Data and Interface Constraints<a class="anchor" aria-label="anchor" href="#data-and-interface-constraints"></a>
</h2>
<p>Before applying the EL equations, the implementation enforces several
constraints on the formula and data (<code><a href="../reference/el_prepare_inputs.html">el_prepare_inputs()</a></code> in
<code>src_dev/engines/el/impl/input.R</code> and the entry points in
<code>src_dev/engines/el/impl/dataframe.R</code> and
<code>src_dev/engines/el/impl/survey.R</code>):</p>
<ul>
<li>
<strong>Single outcome source</strong>: The LHS expression must
reference exactly one outcome source variable in <code>data</code> (for
example <code>Y_miss</code>). Any transformation is applied to this
variable in the model frame, and the transformed values must be finite
for all respondent rows (no new NA/NaN introduced among
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>i</mi></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">R_i=1</annotation></semantics></math>).</li>
<li>
<strong>Outcome only via LHS in the response model</strong>: The raw
outcome variable and the LHS expression are not allowed on RHS1
(auxiliaries) or RHS2 (missingness predictors), either explicitly or via
<code>.</code> expansion. The response model uses the evaluated LHS
outcome column as a dedicated predictor in
<code>missingness_design</code>, together with an intercept and any
additional RHS2 predictors.</li>
<li>
<strong>Auxiliaries among respondents</strong>: Auxiliary variables
(RHS1) must be fully observed and non-constant among respondents. If
<code>auxiliary_means</code> are not supplied, auxiliaries must be fully
observed in the full data so that population means can be estimated from
the sample.</li>
<li>
<strong>Missingness predictors among respondents</strong>:
Missingness predictors (RHS2) must be fully observed among respondents.
Zero-variance predictors are allowed but generate a warning; their
columns still enter the response model design matrix.</li>
<li>
<strong>Respondents-only data</strong>: When the outcome has no
missing values (respondents-only data), the EL engines require
<code>n_total</code> to be supplied so that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>N</mi><mtext mathvariant="normal">pop</mtext></msub><annotation encoding="application/x-tex">N_{\text{pop}}</annotation></semantics></math>
can be set on the analysis scale. If auxiliaries are requested in this
setting, <code>auxiliary_means</code> must also be supplied; otherwise
the engines error with a descriptive message.</li>
</ul>
</div>
<div class="section level2">
<h2 id="from-paper-to-implementation-core-ideas">From Paper to Implementation: Core Ideas<a class="anchor" aria-label="anchor" href="#from-paper-to-implementation-core-ideas"></a>
</h2>
<p>The paper (Qin-Leung-Shao, JASA 2002) sets EL under nonignorable
response using:</p>
<ul>
<li>
<strong>Empirical likelihood weights</strong> for respondents that
satisfy:
<ul>
<li>Zero-sum residual:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>‚àë</mo><msubsup><mi>p</mi><mi>i</mi><mtext mathvariant="normal">EL</mtext></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>w</mi><mi>i</mi></msub><mo>‚àí</mo><mi>W</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\sum p_i^{\text{EL}} (w_i - W) = 0</annotation></semantics></math>
</li>
<li>Auxiliary moments:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>‚àë</mo><msubsup><mi>p</mi><mi>i</mi><mtext mathvariant="normal">EL</mtext></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>X</mi><mi>i</mi></msub><mo>‚àí</mo><msub><mi>Œº</mi><mi>x</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\sum p_i^{\text{EL}} (X_i - \mu_x) = 0</annotation></semantics></math>
</li>
</ul>
</li>
<li>A <strong>response model probability</strong>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mi>i</mi></msub><mo>=</mo><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Œ∑</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">w_i = g(\eta_i)</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Œ∑</mi><mi>i</mi></msub><mo>=</mo><msub><mi>Z</mi><mi>i</mi></msub><mspace width="0.167em"></mspace><mi>Œ≤</mi></mrow><annotation encoding="application/x-tex">\eta_i = Z_i \, \beta</annotation></semantics></math>
</li>
</ul>
<p>In our code, we adopt the same EL structure and estimating equations.
We extend it to arbitrary
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Z</mi><annotation encoding="application/x-tex">Z</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math>,
and to survey designs. For uncertainty, we provide bootstrap variance
(IID resampling and survey replicate-weight bootstrap). Because
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>Y</mi><mo accent="true">ÃÇ</mo></mover><annotation encoding="application/x-tex">\hat Y</annotation></semantics></math>
is a ratio-of-weights estimator, any common normalization of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>p</mi><mi>i</mi><mtext mathvariant="normal">EL</mtext></msubsup><mo>‚àù</mo><msub><mi>a</mi><mi>i</mi></msub><mi>/</mi><msub><mi>D</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">p_i^{\text{EL}} \propto a_i/D_i</annotation></semantics></math>
cancels in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>Y</mi><mo accent="true">ÃÇ</mo></mover><annotation encoding="application/x-tex">\hat Y</annotation></semantics></math>;
only relative weights matter (the KKT multipliers
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Œª</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>
enforce the constraints; normalization affects only a common scale that
vanishes in the ratio).</p>
<div class="section level3">
<h3 id="closed-form-lambda_w-qls-eq--10-iid-path">Closed-form
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Œª</mi><mi>W</mi></msub><annotation encoding="application/x-tex">\lambda_W</annotation></semantics></math>
(QLS Eq. 10, IID path)<a class="anchor" aria-label="anchor" href="#closed-form-lambda_w-qls-eq--10-iid-path"></a>
</h3>
<p>QLS derive
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Œª</mi><mi>W</mi></msub><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>N</mi><mi>/</mi><mi>n</mi><mo>‚àí</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mi>/</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>‚àí</mo><mi>W</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\lambda_W = (N/n - 1)/(1-W)</annotation></semantics></math>
when
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo>‚â°</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">a_i \equiv 1</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
counts respondents. In our <strong>IID (data-frame) path</strong> we
reuse this relation with base weights fixed at
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo>‚â°</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">a_i \equiv 1</annotation></semantics></math>:</p>
<ul>
<li>Let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mtext mathvariant="normal">resp_weighted</mtext></msub><mo>=</mo><msub><mo>‚àë</mo><mrow><mi>i</mi><mo>:</mo><msub><mi>R</mi><mi>i</mi></msub><mo>=</mo><mn>1</mn></mrow></msub><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">n_{\text{resp\_weighted}} = \sum_{i:R_i=1} a_i</annotation></semantics></math>
be the respondent-weighted total.</li>
<li>Let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>N</mi><mtext mathvariant="normal">pop</mtext></msub><annotation encoding="application/x-tex">N_{\text{pop}}</annotation></semantics></math>
be the analysis-scale population total (by default
<code>nrow(data)</code>, or a user-supplied <code>n_total</code>).</li>
</ul>
<p>In the <code>data.frame</code> path <code><a href="../reference/el_prepare_inputs.html">el_prepare_inputs()</a></code>
is called with <code>weights = NULL</code>, so
<code>respondent_weights</code> are identically 1 and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mtext mathvariant="normal">resp_weighted</mtext></msub><mo>=</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">n_{\text{resp\_weighted}} = n</annotation></semantics></math>.
We then set</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Œª</mi><mi>W</mi></msub><mo>=</mo><mfrac><mrow><msub><mi>N</mi><mtext mathvariant="normal">pop</mtext></msub><mi>/</mi><msub><mi>n</mi><mtext mathvariant="normal">resp_weighted</mtext></msub><mo>‚àí</mo><mn>1</mn></mrow><mrow><mn>1</mn><mo>‚àí</mo><mi>W</mi></mrow></mfrac><mo>,</mo></mrow><annotation encoding="application/x-tex">
\lambda_W = \frac{N_{\text{pop}}/n_{\text{resp\_weighted}} - 1}{1 - W},
</annotation></semantics></math></p>
<p>which reduces exactly to the original QLS formula when
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>N</mi><mtext mathvariant="normal">pop</mtext></msub><annotation encoding="application/x-tex">N_{\text{pop}}</annotation></semantics></math>
is the total number of sampled units. This closed form is used
<strong>only</strong> in the IID path to profile out
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Œª</mi><mi>W</mi></msub><annotation encoding="application/x-tex">\lambda_W</annotation></semantics></math>;
for complex survey designs we instead treat
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Œª</mi><mi>W</mi></msub><annotation encoding="application/x-tex">\lambda_W</annotation></semantics></math>
as a free parameter and solve for it jointly with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mi>Œ≤</mi><mo>,</mo><mi>W</mi><mo>,</mo><msub><mi>Œª</mi><mi>x</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(\beta, W, \lambda_x)</annotation></semantics></math>
via the design-weighted system described in the survey extension
section.</p>
</div>
<div class="section level3">
<h3 id="guarding-and-numerical-stability">Guarding and Numerical Stability<a class="anchor" aria-label="anchor" href="#guarding-and-numerical-stability"></a>
</h3>
<p>We solve the stacked system with a consistent guarding policy across
equations, Jacobian, and post-solution:</p>
<ul>
<li>Cap
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Œ∑</mi><annotation encoding="application/x-tex">\eta</annotation></semantics></math>:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Œ∑</mi><mo>‚Üê</mo><mo>max</mo><mo stretchy="false" form="prefix">{</mo><mo>min</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>Œ∑</mi><mo>,</mo><mspace width="0.167em"></mspace><msub><mi>Œ∑</mi><mo>max</mo></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mspace width="0.167em"></mspace><mo>‚àí</mo><msub><mi>Œ∑</mi><mo>max</mo></msub><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\eta \leftarrow \max\{\min(\eta,\,\eta_{\max}),\,-\eta_{\max}\}</annotation></semantics></math>
</li>
<li>Compute
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo>=</mo><mrow><mi mathvariant="normal">l</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">k</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">v</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>Œ∑</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">w = \mathrm{linkinv}(\eta)</annotation></semantics></math>;
clip
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>w</mi><annotation encoding="application/x-tex">w</annotation></semantics></math>
to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">[</mo><msup><mn>10</mn><mrow><mo>‚àí</mo><mn>12</mn></mrow></msup><mo>,</mo><mn>1</mn><mo>‚àí</mo><msup><mn>10</mn><mrow><mo>‚àí</mo><mn>12</mn></mrow></msup><mo stretchy="true" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[10^{-12}, 1-10^{-12}]</annotation></semantics></math>
when used in ratios</li>
<li>Guard denominators:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>i</mi></msub><mo>‚Üê</mo><mo>max</mo><mo stretchy="false" form="prefix">{</mo><msub><mi>D</mi><mi>i</mi></msub><mo>,</mo><mspace width="0.167em"></mspace><mi>Œ¥</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">D_i \leftarrow \max\{D_i,\,\delta\}</annotation></semantics></math>
with a small
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Œ¥</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\delta&gt;0</annotation></semantics></math>
</li>
<li>In the Jacobian, multiply terms involving
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>‚àÇ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mi>/</mi><msub><mi>D</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>/</mi><mi>‚àÇ</mi><mo>‚ãÖ</mo></mrow><annotation encoding="application/x-tex">\partial(1/D_i)/\partial\cdot</annotation></semantics></math>
by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>ùüô</mn><mo stretchy="false" form="prefix">{</mo><msubsup><mi>D</mi><mi>i</mi><mtext mathvariant="normal">raw</mtext></msubsup><mo>&gt;</mo><mi>Œ¥</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\mathbb{1}\{D_i^{\text{raw}} &gt; \delta\}</annotation></semantics></math>
so the analytic Jacobian matches the piecewise-smooth equations being
solved</li>
</ul>
<p>For the probit link,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>Œ∑</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>‚àÇ</mi><mo>log</mo><mi>w</mi><mi>/</mi><mi>‚àÇ</mi><mi>Œ∑</mi><mo>=</mo><mi>œï</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>Œ∑</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>/</mi><mi>Œ¶</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>Œ∑</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">s_i(\eta) = \partial\log w/\partial\eta = \phi(\eta)/\Phi(\eta)</annotation></semantics></math>
(Mills ratio) is computed in the log domain for stability; its
derivative is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>d</mi><msub><mi>s</mi><mi>i</mi></msub></mrow><mrow><mi>d</mi><mi>Œ∑</mi></mrow></mfrac><mo>=</mo><mo>‚àí</mo><mi>Œ∑</mi><mspace width="0.167em"></mspace><msub><mi>s</mi><mi>i</mi></msub><mo>‚àí</mo><msubsup><mi>s</mi><mi>i</mi><mn>2</mn></msubsup></mrow><annotation encoding="application/x-tex">\frac{d s_i}{d\eta} = -\eta\,s_i - s_i^2</annotation></semantics></math>.</p>
</div>
<div class="section level3">
<h3 id="equation-crosswalk-qls-2002---this-vignettecode">Equation Crosswalk (QLS 2002 -&gt; This Vignette/Code)<a class="anchor" aria-label="anchor" href="#equation-crosswalk-qls-2002---this-vignettecode"></a>
</h3>
<ul>
<li>QLS (5): Discrete mass form for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>p</mi><mi>i</mi></msub><annotation encoding="application/x-tex">p_i</annotation></semantics></math>
with two multipliers -&gt; Our
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>i</mi></msub><mo>=</mo><mn>1</mn><mo>+</mo><msub><mi>Œª</mi><mi>W</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>w</mi><mi>i</mi></msub><mo>‚àí</mo><mi>W</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>X</mi><mi>i</mi></msub><mo>‚àí</mo><msub><mi>Œº</mi><mi>x</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>T</mi></msup><msub><mi>Œª</mi><mi>x</mi></msub></mrow><annotation encoding="application/x-tex">D_i = 1 + \lambda_W (w_i - W) + (X_i - \mu_x)^T \lambda_x</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>p</mi><mi>i</mi><mtext mathvariant="normal">EL</mtext></msubsup><mo>‚àù</mo><msub><mi>a</mi><mi>i</mi></msub><mi>/</mi><msub><mi>D</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">p_i^{\text{EL}} \propto a_i/D_i</annotation></semantics></math>.</li>
<li>QLS (7):
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>‚àë</mo><mfrac displaystyle="true"><mrow><msub><mi>x</mi><mi>i</mi></msub><mo>‚àí</mo><msub><mi>Œº</mi><mi>x</mi></msub></mrow><mrow><mn>1</mn><mo>+</mo><mi>‚ãØ</mi></mrow></mfrac><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\sum \dfrac{x_i - \mu_x}{1 + \cdots} = 0</annotation></semantics></math>
(or with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Œº</mi><mi>x</mi></msub><annotation encoding="application/x-tex">\mu_x</annotation></semantics></math>
replaced by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>X</mi><mo accent="true">‚Äæ</mo></mover><annotation encoding="application/x-tex">\bar X</annotation></semantics></math>
when auxiliary variables are observed for all sampled units) -&gt; Our
auxiliary constraints
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>‚àë</mo><msub><mi>a</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>X</mi><mi>i</mi></msub><mo>‚àí</mo><msub><mi>Œº</mi><mi>x</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>/</mi><msub><mi>D</mi><mi>i</mi></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\sum a_i (X_i - \mu_x)/D_i = 0</annotation></semantics></math>,
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Œº</mi><mi>x</mi></msub><annotation encoding="application/x-tex">\mu_x</annotation></semantics></math>
is taken from <code>auxiliary_means</code> if supplied, otherwise
estimated from the full input (unweighted for IID, design-weighted for
surveys).</li>
<li>QLS (8):
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>‚àë</mo><mfrac displaystyle="true"><mrow><msub><mi>w</mi><mi>i</mi></msub><mo>‚àí</mo><mi>W</mi></mrow><mrow><mn>1</mn><mo>+</mo><mi>‚ãØ</mi></mrow></mfrac><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\sum \dfrac{w_i - W}{1 + \cdots} = 0</annotation></semantics></math>
-&gt; Our
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>W</mi><annotation encoding="application/x-tex">W</annotation></semantics></math>-equation
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>‚àë</mo><msub><mi>a</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>w</mi><mi>i</mi></msub><mo>‚àí</mo><mi>W</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>/</mi><msub><mi>D</mi><mi>i</mi></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\sum a_i (w_i - W)/D_i = 0</annotation></semantics></math>.</li>
<li>QLS (10):
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>Œª</mi><mo accent="true">ÃÇ</mo></mover><mn>2</mn></msub><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>N</mi><mi>/</mi><mi>n</mi><mo>‚àí</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mi>/</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>‚àí</mo><mi>W</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\hat{\lambda}_2 = (N/n - 1)/(1 - W)</annotation></semantics></math>
-&gt; In the IID path we set
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Œª</mi><mi>W</mi></msub><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>N</mi><mtext mathvariant="normal">pop</mtext></msub><mi>/</mi><msub><mi>n</mi><mtext mathvariant="normal">resp_weighted</mtext></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>‚àí</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mi>/</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>‚àí</mo><mi>W</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\lambda_W = ((N_{\text{pop}}/n_{\text{resp\_weighted}}) - 1)/(1 - W)</annotation></semantics></math>;
in the survey path
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Œª</mi><mi>W</mi></msub><annotation encoding="application/x-tex">\lambda_W</annotation></semantics></math>
is solved from the additional linkage equation
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>g</mi><mi>W</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></msubsup><annotation encoding="application/x-tex">g_W^{(1)}</annotation></semantics></math>.</li>
<li>Estimator
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>Y</mi><mo accent="true">ÃÇ</mo></mover><annotation encoding="application/x-tex">\hat Y</annotation></semantics></math>
in QLS -&gt; Our ratio
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>Y</mi><mo accent="true">ÃÇ</mo></mover><mo>=</mo><mo>‚àë</mo><msubsup><mi>p</mi><mi>i</mi><mrow><mi mathvariant="normal">E</mi><mi mathvariant="normal">L</mi></mrow></msubsup><msub><mi>Y</mi><mi>i</mi></msub><mi>/</mi><mo>‚àë</mo><msubsup><mi>p</mi><mi>i</mi><mrow><mi mathvariant="normal">E</mi><mi mathvariant="normal">L</mi></mrow></msubsup></mrow><annotation encoding="application/x-tex">\hat Y = \sum p_i^{\mathrm{EL}} Y_i/\sum p_i^{\mathrm{EL}}</annotation></semantics></math>
using
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>p</mi><mi>i</mi><mrow><mi mathvariant="normal">E</mi><mi mathvariant="normal">L</mi></mrow></msubsup><mo>‚àù</mo><msub><mi>a</mi><mi>i</mi></msub><mi>/</mi><msub><mi>D</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">p_i^{\mathrm{EL}} \propto a_i/D_i</annotation></semantics></math>.</li>
</ul>
</div>
<div class="section level3">
<h3 id="likelihood-and-profiling-sketch">Likelihood and Profiling (sketch)<a class="anchor" aria-label="anchor" href="#likelihood-and-profiling-sketch"></a>
</h3>
<p>QLS start from the factorized semiparametric likelihood (their Eq.
(2)):
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>‚Ñí</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>Œ≤</mi><mo>,</mo><mi>W</mi><mo>,</mo><mi>F</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mrow><mo stretchy="true" form="prefix">{</mo><munderover><mo>‚àè</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mfrac><mrow><mi>w</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Y</mi><mi>i</mi></msub><mo>,</mo><msub><mi>X</mi><mi>i</mi></msub><mo>;</mo><mi>Œ≤</mi><mo stretchy="true" form="postfix">)</mo></mrow><mspace width="0.167em"></mspace><mi>d</mi><mi>F</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Y</mi><mi>i</mi></msub><mo>,</mo><msub><mi>X</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><mi>W</mi></mfrac><mo stretchy="true" form="postfix">}</mo></mrow><msup><mi>W</mi><mi>n</mi></msup><msup><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>‚àí</mo><mi>W</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mi>N</mi><mo>‚àí</mo><mi>n</mi></mrow></msup><mo>,</mo></mrow><annotation encoding="application/x-tex">
\mathcal{L}(\beta, W, F)
=
\left\{\prod_{i=1}^{n} \frac{w(Y_i, X_i; \beta)\, dF(Y_i, X_i)}{W}\right\}
W^{n}(1-W)^{N-n},
</annotation></semantics></math> where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mo>=</mo><mo>‚à¨</mo><mi>w</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>y</mi><mo>,</mo><mi>x</mi><mo>;</mo><mi>Œ≤</mi><mo stretchy="true" form="postfix">)</mo></mrow><mspace width="0.167em"></mspace><mi>d</mi><mi>F</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>y</mi><mo>,</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">W=\iint w(y,x;\beta)\,dF(y,x)</annotation></semantics></math>
is the unconditional response rate. The
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>W</mi><mrow><mo>‚àí</mo><mi>n</mi></mrow></msup><annotation encoding="application/x-tex">W^{-n}</annotation></semantics></math>
factor in the conditional likelihood cancels the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>W</mi><mi>n</mi></msup><annotation encoding="application/x-tex">W^n</annotation></semantics></math>
in the binomial term, so the overall likelihood is equivalently
proportional to
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">{</mo><munderover><mo>‚àè</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mi>w</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Y</mi><mi>i</mi></msub><mo>,</mo><msub><mi>X</mi><mi>i</mi></msub><mo>;</mo><mi>Œ≤</mi><mo stretchy="true" form="postfix">)</mo></mrow><mspace width="0.167em"></mspace><mi>d</mi><mi>F</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Y</mi><mi>i</mi></msub><mo>,</mo><msub><mi>X</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">}</mo></mrow><msup><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>‚àí</mo><mi>W</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mi>N</mi><mo>‚àí</mo><mi>n</mi></mrow></msup><mi>.</mi></mrow><annotation encoding="application/x-tex">
\left\{\prod_{i=1}^{n} w(Y_i, X_i; \beta)\, dF(Y_i, X_i)\right\}(1-W)^{N-n}.
</annotation></semantics></math></p>
<p>Maximization is subject to (i)
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>‚à´</mo><mi>d</mi><mi>F</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\int dF = 1</annotation></semantics></math>,
(ii)
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>‚à´</mo><mi>X</mi><mspace width="0.167em"></mspace><mi>d</mi><mi>F</mi><mo>=</mo><msub><mi>Œº</mi><mi>x</mi></msub></mrow><annotation encoding="application/x-tex">\int X \, dF = \mu_x</annotation></semantics></math>
(or
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>X</mi><mo accent="true">‚Äæ</mo></mover><annotation encoding="application/x-tex">\bar X</annotation></semantics></math>
when applicable), and (iii)
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>‚à´</mo><mi>w</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>Y</mi><mo>,</mo><mi>X</mi><mo>;</mo><mi>Œ≤</mi><mo stretchy="true" form="postfix">)</mo></mrow><mspace width="0.167em"></mspace><mi>d</mi><mi>F</mi><mo>=</mo><mi>W</mi></mrow><annotation encoding="application/x-tex">\int w(Y,X;\beta)\, dF = W</annotation></semantics></math>.
Discretizing
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>
at observed respondents by assigning unknown masses
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>p</mi><mi>i</mi></msub><annotation encoding="application/x-tex">p_i</annotation></semantics></math>
and introducing multipliers
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Œª</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>,
the KKT conditions yield the familiar EL weight form with
denominator</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>i</mi></msub><mspace width="0.278em"></mspace><mo>=</mo><mspace width="0.278em"></mspace><mn>1</mn><mo>+</mo><msub><mi>Œª</mi><mi>W</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>w</mi><mi>i</mi></msub><mo>‚àí</mo><mi>W</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>X</mi><mi>i</mi></msub><mo>‚àí</mo><msub><mi>Œº</mi><mi>x</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>‚ä§</mi></msup><msub><mi>Œª</mi><mi>x</mi></msub><mo>,</mo></mrow><annotation encoding="application/x-tex">
D_i \;=\; 1 + \lambda_W (w_i - W) + (X_i - \mu_x)^\top \lambda_x,
</annotation></semantics></math></p>
<p>and, with base weights
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>a</mi><mi>i</mi></msub><annotation encoding="application/x-tex">a_i</annotation></semantics></math>,
the working masses are proportional to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mi>/</mi><msub><mi>D</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i / D_i</annotation></semantics></math>.</p>
<p>Remark on conditioning: QLS‚Äôs Eq. (2) writes the first product as
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>‚àè</mo><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">[</mo><mspace width="0.167em"></mspace><mi>w</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>y</mi><mi>i</mi></msub><mo>,</mo><msub><mi>x</mi><mi>i</mi></msub><mo>;</mo><mi>Œ≤</mi><mo stretchy="true" form="postfix">)</mo></mrow><mspace width="0.167em"></mspace><mi>d</mi><mi>F</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>y</mi><mi>i</mi></msub><mo>,</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>/</mi><mi>W</mi><mspace width="0.167em"></mspace><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">\prod_i [\, w(y_i,x_i;\beta)\,dF(y_i,x_i)/W\,]</annotation></semantics></math>
so that it explicitly represents the likelihood of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Y</mi><mi>i</mi></msub><mo>,</mo><msub><mi>X</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(Y_i,X_i)</annotation></semantics></math>
conditional on
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>i</mi></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">R_i=1</annotation></semantics></math>.
Multiplying by the binomial term
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>W</mi><mi>n</mi></msup><msup><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>‚àí</mo><mi>W</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mi>N</mi><mo>‚àí</mo><mi>n</mi></mrow></msup></mrow><annotation encoding="application/x-tex">W^n(1-W)^{N-n}</annotation></semantics></math>
yields the same overall likelihood as above because the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>W</mi><mrow><mo>‚àí</mo><mi>n</mi></mrow></msup><annotation encoding="application/x-tex">W^{-n}</annotation></semantics></math>
in the first factor cancels the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>W</mi><mi>n</mi></msup><annotation encoding="application/x-tex">W^n</annotation></semantics></math>
in the second. Both factorizations lead to the same estimating equations
and the same profiled log-likelihood form used subsequently in QLS after
introducing the multipliers.</p>
</div>
<div class="section level3">
<h3 id="kkt-and-denominator-details">KKT and Denominator (details)<a class="anchor" aria-label="anchor" href="#kkt-and-denominator-details"></a>
</h3>
<p>There are two closely related objects in the EL construction:</p>
<ul>
<li>The unknown <em>conditional</em> masses
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>p</mi><mi>i</mi></msub><annotation encoding="application/x-tex">p_i</annotation></semantics></math>
on respondent support points (these are the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>p</mi><mi>i</mi></msub><annotation encoding="application/x-tex">p_i</annotation></semantics></math>
in QLS).</li>
<li>The <em>probability mass weights</em> actually used to form
expectations under the discretized law. For surveys this mass is
proportional to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><msub><mi>p</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i p_i</annotation></semantics></math>
(because
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>a</mi><mi>i</mi></msub><annotation encoding="application/x-tex">a_i</annotation></semantics></math>
represents how many population units respondent
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>
stands for).</li>
</ul>
<p>In a survey-weighted setting (with base weights
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>a</mi><mi>i</mi></msub><annotation encoding="application/x-tex">a_i</annotation></semantics></math>
acting as multiplicities), we can write the discretized empirical
distribution as
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mtext mathvariant="normal">EL</mtext></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>A</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><munder><mo>‚àë</mo><mi>i</mi></munder><msub><mi>a</mi><mi>i</mi></msub><msub><mi>p</mi><mi>i</mi></msub><mspace width="0.167em"></mspace><mn>ùüè</mn><mo stretchy="false" form="prefix">{</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>y</mi><mi>i</mi></msub><mo>,</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>‚àà</mo><mi>A</mi><mo stretchy="false" form="postfix">}</mo><mo>,</mo></mrow><annotation encoding="application/x-tex">
F_{\text{EL}}(A) = \sum_i a_i p_i\,\mathbf{1}\{(y_i,x_i)\in A\},
</annotation></semantics></math> with constraints
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><munder><mo>‚àë</mo><mi>i</mi></munder><msub><mi>a</mi><mi>i</mi></msub><msub><mi>p</mi><mi>i</mi></msub><mo>=</mo><mn>1</mn><mo>,</mo><mspace width="2.0em"></mspace><munder><mo>‚àë</mo><mi>i</mi></munder><msub><mi>a</mi><mi>i</mi></msub><msub><mi>p</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>X</mi><mi>i</mi></msub><mo>‚àí</mo><msub><mi>Œº</mi><mi>x</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>0</mn><mo>,</mo><mspace width="2.0em"></mspace><munder><mo>‚àë</mo><mi>i</mi></munder><msub><mi>a</mi><mi>i</mi></msub><msub><mi>p</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>w</mi><mi>i</mi></msub><mo>‚àí</mo><mi>W</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>0</mn><mi>.</mi></mrow><annotation encoding="application/x-tex">
\sum_i a_i p_i = 1,\qquad
\sum_i a_i p_i(X_i-\mu_x)=0,\qquad
\sum_i a_i p_i(w_i-W)=0.
</annotation></semantics></math></p>
<p>Introducing Lagrange multipliers
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Œª</mi><mn>0</mn></msub><mo>,</mo><msub><mi>Œª</mi><mi>x</mi></msub><mo>,</mo><msub><mi>Œª</mi><mi>W</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(\lambda_0,\lambda_x,\lambda_W)</annotation></semantics></math>
for these constraints and profiling the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>p</mi><mi>i</mi></msub><annotation encoding="application/x-tex">p_i</annotation></semantics></math>‚Äôs
gives the KKT stationarity conditions</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>‚àÇ</mi><mrow><mi>‚àÇ</mi><msub><mi>p</mi><mi>i</mi></msub></mrow></mfrac><mo minsize="1.8" maxsize="1.8" stretchy="false" form="prefix">[</mo><munder><mo>‚àë</mo><mi>j</mi></munder><msub><mi>a</mi><mi>j</mi></msub><mspace width="0.167em"></mspace><mo>log</mo><msub><mi>p</mi><mi>j</mi></msub><mo>‚àí</mo><msub><mi>Œª</mi><mn>0</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><munder><mo>‚àë</mo><mi>j</mi></munder><msub><mi>a</mi><mi>j</mi></msub><msub><mi>p</mi><mi>j</mi></msub><mo>‚àí</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>‚àí</mo><msubsup><mi>Œª</mi><mi>x</mi><mi>T</mi></msubsup><munder><mo>‚àë</mo><mi>j</mi></munder><msub><mi>a</mi><mi>j</mi></msub><msub><mi>p</mi><mi>j</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>X</mi><mi>j</mi></msub><mo>‚àí</mo><msub><mi>Œº</mi><mi>x</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>‚àí</mo><msub><mi>Œª</mi><mi>W</mi></msub><munder><mo>‚àë</mo><mi>j</mi></munder><msub><mi>a</mi><mi>j</mi></msub><msub><mi>p</mi><mi>j</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>w</mi><mi>j</mi></msub><mo>‚àí</mo><mi>W</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo minsize="1.8" maxsize="1.8" stretchy="false" form="postfix">]</mo><mo>=</mo><mn>0</mn><mo>,</mo></mrow><annotation encoding="application/x-tex">
\frac{\partial}{\partial p_i} \Big[ \sum_j a_j\, \log p_j - \lambda_0 (\sum_j a_j p_j - 1) - \lambda_x^T \sum_j a_j p_j (X_j - \mu_x) - \lambda_W \sum_j a_j p_j (w_j - W) \Big] = 0,
</annotation></semantics></math></p>
<p>which solve to</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mi>i</mi></msub><mspace width="0.278em"></mspace><mo>‚àù</mo><mspace width="0.278em"></mspace><mfrac><mn>1</mn><mrow><mspace width="0.167em"></mspace><mn>1</mn><mo>+</mo><msubsup><mi>Œª</mi><mi>x</mi><mi>T</mi></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>X</mi><mi>i</mi></msub><mo>‚àí</mo><msub><mi>Œº</mi><mi>x</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><msub><mi>Œª</mi><mi>W</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>w</mi><mi>i</mi></msub><mo>‚àí</mo><mi>W</mi><mo stretchy="true" form="postfix">)</mo></mrow><mspace width="0.167em"></mspace></mrow></mfrac><mspace width="0.278em"></mspace><mo>‚â°</mo><mspace width="0.278em"></mspace><mfrac><mn>1</mn><msub><mi>D</mi><mi>i</mi></msub></mfrac><mi>.</mi></mrow><annotation encoding="application/x-tex">
p_i \;\propto\; \frac{1}{\,1 + \lambda_x^T (X_i-\mu_x) + \lambda_W (w_i - W)\,} \;\equiv\; \frac{1}{D_i}.
</annotation></semantics></math></p>
<p>Normalizing to enforce
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>‚àë</mo><mi>i</mi></msub><msub><mi>a</mi><mi>i</mi></msub><msub><mi>p</mi><mi>i</mi></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\sum_i a_i p_i = 1</annotation></semantics></math>
yields
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mi>i</mi></msub><mo>=</mo><mfrac><msubsup><mi>D</mi><mi>i</mi><mrow><mo>‚àí</mo><mn>1</mn></mrow></msubsup><mrow><munder><mo>‚àë</mo><mi>j</mi></munder><msub><mi>a</mi><mi>j</mi></msub><msubsup><mi>D</mi><mi>j</mi><mrow><mo>‚àí</mo><mn>1</mn></mrow></msubsup></mrow></mfrac><mi>.</mi></mrow><annotation encoding="application/x-tex">
p_i = \frac{D_i^{-1}}{\sum_j a_j D_j^{-1}}.
</annotation></semantics></math> The <em>probability mass weight</em>
placed on respondent
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>
under
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>F</mi><mtext mathvariant="normal">EL</mtext></msub><annotation encoding="application/x-tex">F_{\text{EL}}</annotation></semantics></math>
is then
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><msub><mi>p</mi><mi>i</mi></msub><mo>=</mo><mfrac><mrow><msub><mi>a</mi><mi>i</mi></msub><msubsup><mi>D</mi><mi>i</mi><mrow><mo>‚àí</mo><mn>1</mn></mrow></msubsup></mrow><mrow><munder><mo>‚àë</mo><mi>j</mi></munder><msub><mi>a</mi><mi>j</mi></msub><msubsup><mi>D</mi><mi>j</mi><mrow><mo>‚àí</mo><mn>1</mn></mrow></msubsup></mrow></mfrac><mspace width="0.278em"></mspace><mo>‚àù</mo><mspace width="0.278em"></mspace><mfrac><msub><mi>a</mi><mi>i</mi></msub><msub><mi>D</mi><mi>i</mi></msub></mfrac><mi>.</mi></mrow><annotation encoding="application/x-tex">
a_i p_i
=
\frac{\displaystyle a_i D_i^{-1}}{\displaystyle \sum_j a_j D_j^{-1}}
\;\propto\; \frac{a_i}{D_i}.
</annotation></semantics></math> In the implementation we store
unnormalized EL masses
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>m</mi><mi>i</mi></msub><mo>=</mo><msub><mi>a</mi><mi>i</mi></msub><mi>/</mi><msub><mi>D</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">m_i = a_i/D_i</annotation></semantics></math>
and use probability-scale weights
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>p</mi><mi>i</mi><mtext mathvariant="normal">EL</mtext></msubsup><mo>=</mo><msub><mi>m</mi><mi>i</mi></msub><mi>/</mi><msub><mo>‚àë</mo><mi>j</mi></msub><msub><mi>m</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">p_i^{\text{EL}} = m_i/\sum_j m_j</annotation></semantics></math>
for expectations.</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>m</mi><mi>i</mi></msub><mspace width="0.278em"></mspace><mo>‚àù</mo><mspace width="0.278em"></mspace><mfrac><msub><mi>a</mi><mi>i</mi></msub><msub><mi>D</mi><mi>i</mi></msub></mfrac><mspace width="1.0em"></mspace><mtext mathvariant="normal">with</mtext><mspace width="1.0em"></mspace><msub><mi>D</mi><mi>i</mi></msub><mo>=</mo><mn>1</mn><mo>+</mo><msub><mi>Œª</mi><mi>W</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>w</mi><mi>i</mi></msub><mo>‚àí</mo><mi>W</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>X</mi><mi>i</mi></msub><mo>‚àí</mo><msub><mi>Œº</mi><mi>x</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>T</mi></msup><msub><mi>Œª</mi><mi>x</mi></msub><mi>.</mi></mrow><annotation encoding="application/x-tex">
m_i \;\propto\; \frac{a_i}{D_i} \quad \text{with} \quad D_i = 1 + \lambda_W (w_i - W) + (X_i - \mu_x)^T\lambda_x.
</annotation></semantics></math></p>
<p>The EL weights
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>p</mi><mi>i</mi><mtext mathvariant="normal">EL</mtext></msubsup><annotation encoding="application/x-tex">p_i^{\text{EL}}</annotation></semantics></math>
are then used to build the mean estimator</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>Y</mi><mo accent="true">ÃÇ</mo></mover><mspace width="0.278em"></mspace><mo>=</mo><mspace width="0.278em"></mspace><mfrac><mrow><munder><mo>‚àë</mo><mi>i</mi></munder><msubsup><mi>p</mi><mi>i</mi><mtext mathvariant="normal">EL</mtext></msubsup><msub><mi>Y</mi><mi>i</mi></msub></mrow><mrow><munder><mo>‚àë</mo><mi>i</mi></munder><msubsup><mi>p</mi><mi>i</mi><mtext mathvariant="normal">EL</mtext></msubsup></mrow></mfrac><mi>.</mi></mrow><annotation encoding="application/x-tex">
\hat Y \;=\; \frac{\sum_i p_i^{\text{EL}} Y_i}{\sum_i p_i^{\text{EL}}}.
</annotation></semantics></math></p>
<p>The remaining unknowns
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mi>Œ≤</mi><mo>,</mo><mi>W</mi><mo>,</mo><msub><mi>Œª</mi><mi>x</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(\beta, W, \lambda_x)</annotation></semantics></math>
(and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Œª</mi><mi>W</mi></msub><annotation encoding="application/x-tex">\lambda_W</annotation></semantics></math>
in the survey system) are determined by the estimating equations
below.</p>
</div>
<div class="section level3">
<h3 id="clarification-relationship-between-w-and-lambda_w">Clarification: Relationship Between
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>W</mi><annotation encoding="application/x-tex">W</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Œª</mi><mi>W</mi></msub><annotation encoding="application/x-tex">\lambda_W</annotation></semantics></math><a class="anchor" aria-label="anchor" href="#clarification-relationship-between-w-and-lambda_w"></a>
</h3>
<p>In the IID (data-frame) path, the EL multiplier for the response-rate
constraint is expressed as</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Œª</mi><mi>W</mi></msub><mo>=</mo><mfrac><mi>C</mi><mrow><mn>1</mn><mo>‚àí</mo><mi>W</mi></mrow></mfrac><mo>,</mo><mspace width="1.0em"></mspace><mrow><mtext mathvariant="normal">with </mtext><mspace width="0.333em"></mspace></mrow><mi>C</mi><mo>=</mo><mfrac><msub><mi>N</mi><mtext mathvariant="normal">pop</mtext></msub><msub><mi>n</mi><mtext mathvariant="normal">resp_weighted</mtext></msub></mfrac><mo>‚àí</mo><mn>1</mn><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> and </mtext><mspace width="0.333em"></mspace></mrow><mi>W</mi><mo>=</mo><mtext mathvariant="normal">plogis</mtext><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>.</mi></mrow><annotation encoding="application/x-tex">
\lambda_W = \frac{C}{1 - W}, \quad \text{with } C = \frac{N_{\text{pop}}}{n_{\text{resp\_weighted}}} - 1 \text{ and } W = \text{plogis}(z).
</annotation></semantics></math></p>
<p>Intuition: In the EL KKT system, the constraint
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>‚àë</mo><msubsup><mi>p</mi><mi>i</mi><mtext mathvariant="normal">EL</mtext></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>w</mi><mi>i</mi></msub><mo>‚àí</mo><mi>W</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\sum p_i^{\text{EL}} (w_i - W) = 0</annotation></semantics></math>
sits alongside normalization and (optionally) auxiliary constraints.
Incorporating base weights
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>a</mi><mi>i</mi></msub><annotation encoding="application/x-tex">a_i</annotation></semantics></math>
and the ratio between population and respondent totals induces a scaling
of the multiplier linked to the mass constraint. Writing
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Œª</mi><mi>W</mi></msub><annotation encoding="application/x-tex">\lambda_W</annotation></semantics></math>
in this scaled form keeps the parameter on a numerically stable scale
and lets the derivative structure (with respect to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>z</mi><annotation encoding="application/x-tex">z</annotation></semantics></math>
via
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>W</mi><annotation encoding="application/x-tex">W</annotation></semantics></math>)
be handled cleanly. This is consistent with the EL structure when the
baseline mass is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>n</mi><mtext mathvariant="normal">resp_weighted</mtext></msub><annotation encoding="application/x-tex">n_{\text{resp\_weighted}}</annotation></semantics></math>
and the ‚Äúfull population‚Äù target is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>N</mi><mtext mathvariant="normal">pop</mtext></msub><annotation encoding="application/x-tex">N_{\text{pop}}</annotation></semantics></math>,
and it is exactly what the IID code path uses to match the normalization
implied by base weights.</p>
<p>Derivation sketch (KKT, IID case): The discretized semiparametric
likelihood (QLS, 2002) maximizes, over the unknown masses
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><msub><mi>p</mi><mi>i</mi></msub><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\{p_i\}</annotation></semantics></math>
at observed points and over
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mi>Œ≤</mi><mo>,</mo><mi>W</mi><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(\beta, W)</annotation></semantics></math>,</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>‚Ñì</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>Œ≤</mi><mo>,</mo><mi>W</mi><mo>,</mo><msub><mi>Œª</mi><mi>x</mi></msub><mo>,</mo><msub><mi>Œª</mi><mi>W</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mspace width="0.278em"></mspace><mo>=</mo><mspace width="0.278em"></mspace><munderover><mo>‚àë</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mo>log</mo><msub><mi>w</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>Œ≤</mi><mo stretchy="true" form="postfix">)</mo></mrow><mspace width="0.278em"></mspace><mo>+</mo><mspace width="0.278em"></mspace><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>N</mi><mtext mathvariant="normal">pop</mtext></msub><mo>‚àí</mo><msub><mi>n</mi><mtext mathvariant="normal">resp_weighted</mtext></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>log</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>‚àí</mo><mi>W</mi><mo stretchy="true" form="postfix">)</mo></mrow><mspace width="0.278em"></mspace><mo>‚àí</mo><mspace width="0.278em"></mspace><munderover><mo>‚àë</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mo>log</mo><mspace width="-0.167em"></mspace><mo minsize="1.8" maxsize="1.8" stretchy="false" form="prefix">(</mo><mn>1</mn><mo>+</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>X</mi><mi>i</mi></msub><mo>‚àí</mo><msub><mi>Œº</mi><mi>x</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>‚ä§</mi></msup><msub><mi>Œª</mi><mi>x</mi></msub><mo>+</mo><msub><mi>Œª</mi><mi>W</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>w</mi><mi>i</mi></msub><mo>‚àí</mo><mi>W</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo minsize="1.8" maxsize="1.8" stretchy="false" form="postfix">)</mo><mo>,</mo></mrow><annotation encoding="application/x-tex">
\ell(\beta, W, \lambda_x, \lambda_W) 
\;=\; \sum_{i=1}^{n} \log w_i(\beta)
\; +\; (N_{\text{pop}} - n_{\text{resp\_weighted}}) \log(1 - W)
\; -\; \sum_{i=1}^{n} \log\!\Big(1 + (X_i - \mu_x)^\top \lambda_x + \lambda_W (w_i - W)\Big),
</annotation></semantics></math></p>
<p>subject to the normalization and moment constraints that generate the
EL denominator. In the IID QLS case
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo>‚â°</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">a_i \equiv 1</annotation></semantics></math>),
profiling the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>p</mi><mi>i</mi></msub><annotation encoding="application/x-tex">p_i</annotation></semantics></math>‚Äôs
under
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>‚àë</mo><mi>i</mi></msub><msub><mi>p</mi><mi>i</mi></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\sum_i p_i = 1</annotation></semantics></math>
gives
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mi>i</mi></msub><mo>=</mo><mn>1</mn><mi>/</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><msub><mi>D</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">p_i = 1/(n D_i)</annotation></semantics></math>
and therefore
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>‚àë</mo><mi>i</mi></msub><msubsup><mi>D</mi><mi>i</mi><mrow><mo>‚àí</mo><mn>1</mn></mrow></msubsup><mo>=</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\sum_i D_i^{-1} = n</annotation></semantics></math>.
Combining this identity with the first-order condition for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>W</mi><annotation encoding="application/x-tex">W</annotation></semantics></math>
yields the closed form</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Œª</mi><mi>W</mi></msub><mspace width="0.278em"></mspace><mo>=</mo><mspace width="0.278em"></mspace><mfrac><mrow><mfrac displaystyle="false"><msub><mi>N</mi><mtext mathvariant="normal">pop</mtext></msub><msub><mi>n</mi><mtext mathvariant="normal">resp_weighted</mtext></msub></mfrac><mo>‚àí</mo><mn>1</mn></mrow><mrow><mn>1</mn><mo>‚àí</mo><mi>W</mi></mrow></mfrac><mspace width="0.278em"></mspace><mo>=</mo><mspace width="0.278em"></mspace><mfrac><mi>C</mi><mrow><mn>1</mn><mo>‚àí</mo><mi>W</mi></mrow></mfrac><mo>,</mo></mrow><annotation encoding="application/x-tex">
\lambda_W 
\;=\; \frac{\tfrac{N_{\text{pop}}}{n_{\text{resp\_weighted}}} - 1}{1 - W}
\;=\; \frac{C}{1 - W},
</annotation></semantics></math></p>
<p>which coincides with QLS (10) when
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo>‚â°</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">a_i \equiv 1</annotation></semantics></math>.
This closed-form relationship is used in the IID EL implementation to
profile out
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Œª</mi><mi>W</mi></msub><annotation encoding="application/x-tex">\lambda_W</annotation></semantics></math>.
In the <strong>survey-design path</strong>, by contrast,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Œª</mi><mi>W</mi></msub><annotation encoding="application/x-tex">\lambda_W</annotation></semantics></math>
is treated as an explicit unknown and the linkage between
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>W</mi><annotation encoding="application/x-tex">W</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Œª</mi><mi>W</mi></msub><annotation encoding="application/x-tex">\lambda_W</annotation></semantics></math>
is enforced through the additional equation</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>g</mi><mi>W</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><mi>Œ≤</mi><mo>,</mo><mi>W</mi><mo>,</mo><msub><mi>Œª</mi><mi>W</mi></msub><mo>,</mo><msub><mi>Œª</mi><mi>x</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mspace width="0.278em"></mspace><mo>=</mo><mspace width="0.278em"></mspace><mfrac><msub><mi>T</mi><mn>0</mn></msub><mrow><mn>1</mn><mo>‚àí</mo><mi>W</mi></mrow></mfrac><mo>‚àí</mo><msub><mi>Œª</mi><mi>W</mi></msub><munder><mo>‚àë</mo><mrow><mi>i</mi><mo>‚àà</mo><mi>R</mi></mrow></munder><mfrac><msub><mi>d</mi><mi>i</mi></msub><msub><mi>D</mi><mi>i</mi></msub></mfrac><mo>=</mo><mn>0</mn><mo>,</mo></mrow><annotation encoding="application/x-tex">
g_W^{(1)}(\beta, W, \lambda_W, \lambda_x)
\;=\; \frac{T_0}{1 - W} - \lambda_W \sum_{i \in R} \frac{d_i}{D_i} = 0,
</annotation></semantics></math></p>
<p>where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>0</mn></msub><mo>=</mo><msub><mi>N</mi><mrow><mi mathvariant="normal">p</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">p</mi></mrow></msub><mo>‚àí</mo><msub><mo>‚àë</mo><mrow><mi>i</mi><mo>‚àà</mo><mi>R</mi></mrow></msub><msub><mi>d</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">T_0 = N_{\mathrm{pop}} - \sum_{i \in R} d_i</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>d</mi><mi>i</mi></msub><annotation encoding="application/x-tex">d_i</annotation></semantics></math>
are the design weights. At the QLS simple-random-sampling limit (equal
weights, no auxiliaries) this system reduces to the same closed-form
relation.</p>
</div>
</div>
<div class="section level2">
<h2 id="estimating-equations">Estimating Equations<a class="anchor" aria-label="anchor" href="#estimating-equations"></a>
</h2>
<p><strong>Unknown parameters</strong>:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Œ≤</mi><mo>‚àà</mo><msup><mi>‚Ñù</mi><mi>K</mi></msup></mrow><annotation encoding="application/x-tex">\beta \in \mathbb{R}^K</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi><mo>‚àà</mo><mi>‚Ñù</mi></mrow><annotation encoding="application/x-tex">z \in \mathbb{R}</annotation></semantics></math>
(for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mo>=</mo><mtext mathvariant="normal">plogis</mtext><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">W = \text{plogis}(z)</annotation></semantics></math>),
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Œª</mi><mi>x</mi></msub><mo>‚àà</mo><msup><mi>‚Ñù</mi><mi>L</mi></msup></mrow><annotation encoding="application/x-tex">\lambda_x \in \mathbb{R}^L</annotation></semantics></math>;
define
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Œ∏</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>Œ≤</mi><mo>,</mo><mi>z</mi><mo>,</mo><msub><mi>Œª</mi><mi>x</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\theta = (\beta, z, \lambda_x)</annotation></semantics></math>.</p>
<p>Define
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mi>i</mi></msub><mo>=</mo><mrow><mi mathvariant="normal">l</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">k</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">v</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Œ∑</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">w_i = \mathrm{linkinv}(\eta_i)</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Œº</mi><mrow><mi>Œ∑</mi><mo>,</mo><mi>i</mi></mrow></msub><mo>=</mo><mfrac><mrow><mi>d</mi><mi>w</mi></mrow><mrow><mi>d</mi><mi>Œ∑</mi></mrow></mfrac><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Œ∑</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mu_{\eta,i} = \frac{dw}{d\eta}(\eta_i)</annotation></semantics></math>
(denoted <code>mu.eta(eta_i)</code> in code).</p>
<p>In the <strong>IID (data-frame) path</strong> all base weights are
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo>‚â°</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">a_i \equiv 1</annotation></semantics></math>,
so we can use the closed-form Qin-Leung-Shao (QLS) relation between
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>W</mi><annotation encoding="application/x-tex">W</annotation></semantics></math>
and the EL multiplier for the response constraint. Writing
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mo>=</mo><mfrac><msub><mi>N</mi><mtext mathvariant="normal">pop</mtext></msub><msub><mi>n</mi><mtext mathvariant="normal">resp_weighted</mtext></msub></mfrac><mo>‚àí</mo><mn>1</mn><mo>,</mo><mspace width="2.0em"></mspace><msub><mi>n</mi><mtext mathvariant="normal">resp_weighted</mtext></msub><mo>=</mo><munder><mo>‚àë</mo><mi>i</mi></munder><msub><mi>a</mi><mi>i</mi></msub><mo>,</mo></mrow><annotation encoding="application/x-tex">
C = \frac{N_{\text{pop}}}{n_{\text{resp\_weighted}}} - 1,\qquad
n_{\text{resp\_weighted}} = \sum_i a_i,
</annotation></semantics></math> QLS show that
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Œª</mi><mi>W</mi></msub><mo>=</mo><mfrac><mi>C</mi><mrow><mn>1</mn><mo>‚àí</mo><mi>W</mi></mrow></mfrac><mo>=</mo><mfrac><mrow><msub><mi>N</mi><mtext mathvariant="normal">pop</mtext></msub><mi>/</mi><msub><mi>n</mi><mtext mathvariant="normal">resp_weighted</mtext></msub><mo>‚àí</mo><mn>1</mn></mrow><mrow><mn>1</mn><mo>‚àí</mo><mi>W</mi></mrow></mfrac><mi>.</mi></mrow><annotation encoding="application/x-tex">
\lambda_W = \frac{C}{1 - W} = \frac{N_{\text{pop}}/n_{\text{resp\_weighted}} - 1}{1 - W}.
</annotation></semantics></math> Our IID implementation follows this and
<em>profiles out</em>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Œª</mi><mi>W</mi></msub><annotation encoding="application/x-tex">\lambda_W</annotation></semantics></math>:
the unknowns for the Newton solver are
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mi>Œ≤</mi><mo>,</mo><mi>z</mi><mo>,</mo><msub><mi>Œª</mi><mi>x</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(\beta, z, \lambda_x)</annotation></semantics></math>.</p>
<p>In the <strong>survey path</strong>, base weights are general design
weights
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo>=</mo><msub><mi>d</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i = d_i</annotation></semantics></math>
and the corresponding QLS-style relation no longer has a simple closed
form. In that case we treat
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Œª</mi><mi>W</mi></msub><annotation encoding="application/x-tex">\lambda_W</annotation></semantics></math>
as an additional free parameter and include a separate equation linking
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Œª</mi><mi>W</mi></msub><annotation encoding="application/x-tex">\lambda_W</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>W</mi><annotation encoding="application/x-tex">W</annotation></semantics></math>
(see the ‚ÄúSurvey extension‚Äù section below).</p>
<p><strong>Denominator</strong>:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>i</mi></msub><mo>=</mo><mn>1</mn><mo>+</mo><msub><mi>Œª</mi><mi>W</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>w</mi><mi>i</mi></msub><mo>‚àí</mo><mi>W</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>X</mi><mi>i</mi></msub><mo>‚àí</mo><msub><mi>Œº</mi><mi>x</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>T</mi></msup><msub><mi>Œª</mi><mi>x</mi></msub></mrow><annotation encoding="application/x-tex">D_i = 1 + \lambda_W (w_i - W) + (X_i - \mu_x)^T \lambda_x</annotation></semantics></math>,
with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>i</mi></msub><mo>‚â•</mo><mi>œµ</mi></mrow><annotation encoding="application/x-tex">D_i \geq \epsilon</annotation></semantics></math>
enforced numerically.</p>
<p>Define the score term
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub><mo>=</mo><msub><mi>Œº</mi><mrow><mi>Œ∑</mi><mo>,</mo><mi>i</mi></mrow></msub><mi>/</mi><msub><mi>w</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">s_i = \mu_{\eta,i}/w_i</annotation></semantics></math>
(the unit-level contribution to the log-likelihood score with respect to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Œ∑</mi><annotation encoding="application/x-tex">\eta</annotation></semantics></math>).
For logit,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub><mo>=</mo><mn>1</mn><mo>‚àí</mo><msub><mi>w</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">s_i = 1 - w_i</annotation></semantics></math>;
for probit,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>s</mi><mi>i</mi></msub><annotation encoding="application/x-tex">s_i</annotation></semantics></math>
behaves like
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>œï</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Œ∑</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>/</mi><mi>Œ¶</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Œ∑</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\phi(\eta_i)/\Phi(\eta_i)</annotation></semantics></math>
when
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>w</mi><mi>i</mi></msub><annotation encoding="application/x-tex">w_i</annotation></semantics></math>
is bounded away from 0 via clipping (as implemented).</p>
<p>Intuition (why this score appears): for each respondent we observe
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>i</mi></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">R_i=1</annotation></semantics></math>,
so the Bernoulli log-likelihood contribution of the response model is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>log</mo><msub><mi>w</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Œ∑</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\log w_i(\eta_i)</annotation></semantics></math>.
Differentiating w.r.t. the linear predictor gives
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>‚àÇ</mi><mrow><mi>‚àÇ</mi><msub><mi>Œ∑</mi><mi>i</mi></msub></mrow></mfrac><mo>log</mo><msub><mi>w</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Œ∑</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mspace width="0.167em"></mspace><mo>=</mo><mspace width="0.167em"></mspace><mfrac><mn>1</mn><msub><mi>w</mi><mi>i</mi></msub></mfrac><mspace width="0.167em"></mspace><mfrac><mrow><mi>d</mi><msub><mi>w</mi><mi>i</mi></msub></mrow><mrow><mi>d</mi><msub><mi>Œ∑</mi><mi>i</mi></msub></mrow></mfrac><mspace width="0.167em"></mspace><mo>=</mo><mspace width="0.167em"></mspace><mfrac><msub><mi>Œº</mi><mrow><mi>Œ∑</mi><mo>,</mo><mi>i</mi></mrow></msub><msub><mi>w</mi><mi>i</mi></msub></mfrac><mspace width="0.278em"></mspace><mo>‚â°</mo><mspace width="0.278em"></mspace><msub><mi>s</mi><mi>i</mi></msub><mi>.</mi></mrow><annotation encoding="application/x-tex">
\frac{\partial}{\partial\eta_i} \log w_i(\eta_i) \,=\, \frac{1}{w_i}\, \frac{dw_i}{d\eta_i} \,=\, \frac{\mu_{\eta,i}}{w_i} \;\equiv\; s_i.
</annotation></semantics></math></p>
<p>Thus
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>s</mi><mi>i</mi></msub><annotation encoding="application/x-tex">s_i</annotation></semantics></math>
measures the local sensitivity of the observed-response likelihood to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Œ∑</mi><mi>i</mi></msub><annotation encoding="application/x-tex">\eta_i</annotation></semantics></math>.
In the logit family,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Œº</mi><mrow><mi>Œ∑</mi><mo>,</mo><mi>i</mi></mrow></msub><mo>=</mo><msub><mi>w</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>‚àí</mo><msub><mi>w</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mu_{\eta,i}=w_i(1-w_i)</annotation></semantics></math>
so
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub><mo>=</mo><mn>1</mn><mo>‚àí</mo><msub><mi>w</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">s_i=1-w_i</annotation></semantics></math>-the
familiar residual-like term; in the probit family,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub><mo>=</mo><mi>œï</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Œ∑</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>/</mi><mi>Œ¶</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Œ∑</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">s_i=\phi(\eta_i)/\Phi(\eta_i)</annotation></semantics></math>,
the (inverse) Mills ratio. The EL
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Œ≤</mi><annotation encoding="application/x-tex">\beta</annotation></semantics></math>-equations
balance this likelihood score against the EL penalty term
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Œª</mi><mi>W</mi></msub><mspace width="0.167em"></mspace><msub><mi>Œº</mi><mrow><mi>Œ∑</mi><mo>,</mo><mi>i</mi></mrow></msub><mi>/</mi><msub><mi>D</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\lambda_W\,\mu_{\eta,i}/D_i</annotation></semantics></math>,
enforcing the calibration constraints while fitting the response
model.</p>
<div class="section level3">
<h3 id="the-system-of-estimating-equations-ftheta-0">The System of Estimating Equations
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>Œ∏</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">F(\theta) = 0</annotation></semantics></math><a class="anchor" aria-label="anchor" href="#the-system-of-estimating-equations-ftheta-0"></a>
</h3>
<p><strong><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Œ≤</mi><annotation encoding="application/x-tex">\beta</annotation></semantics></math>-equations</strong>
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>K</mi><annotation encoding="application/x-tex">K</annotation></semantics></math>
equations):
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>‚àë</mo><msub><mi>a</mi><mi>i</mi></msub><msub><mi>Z</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>s</mi><mi>i</mi></msub><mo>‚àí</mo><msub><mi>Œª</mi><mi>W</mi></msub><msub><mi>Œº</mi><mrow><mi>Œ∑</mi><mo>,</mo><mi>i</mi></mrow></msub><mi>/</mi><msub><mi>D</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">]</mo></mrow><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\sum a_i Z_i [s_i - \lambda_W \mu_{\eta,i} / D_i] = 0</annotation></semantics></math></p>
<p><strong>W-equation</strong> (1 equation):
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>‚àë</mo><msub><mi>a</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>w</mi><mi>i</mi></msub><mo>‚àí</mo><mi>W</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>/</mi><msub><mi>D</mi><mi>i</mi></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\sum a_i (w_i - W) / D_i = 0</annotation></semantics></math></p>
<p><strong>Auxiliary constraints</strong>
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>
equations):
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>‚àë</mo><msub><mi>a</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>X</mi><mi>i</mi></msub><mo>‚àí</mo><msub><mi>Œº</mi><mi>x</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>/</mi><msub><mi>D</mi><mi>i</mi></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\sum a_i (X_i - \mu_x) / D_i = 0</annotation></semantics></math></p>
<p>These are exactly how <code>el_build_equation_system</code>
constructs the function in code
(<code>src_dev/engines/el/impl/equations.R</code>).</p>
<p>Intuition: the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Œ≤</mi><annotation encoding="application/x-tex">\beta</annotation></semantics></math>-equations
equate the score of the respondent log-likelihood with the EL penalty
term
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Œª</mi><mi>W</mi></msub><msub><mi>Œº</mi><mrow><mi>Œ∑</mi><mo>,</mo><mi>i</mi></mrow></msub><mi>/</mi><msub><mi>D</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\lambda_W \mu_{\eta,i}/D_i</annotation></semantics></math>;
the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>W</mi><annotation encoding="application/x-tex">W</annotation></semantics></math>-equation
centers the modeled response probabilities around the unconditional mean
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>W</mi><annotation encoding="application/x-tex">W</annotation></semantics></math>
under the EL weights; the auxiliary equations calibrate the centered
auxiliaries to zero mean under the EL weights.</p>
</div>
<div class="section level3">
<h3 id="code-cross-reference-equations-and-jacobian">Code cross-reference (equations and Jacobian)<a class="anchor" aria-label="anchor" href="#code-cross-reference-equations-and-jacobian"></a>
</h3>
<p>This table maps the theory blocks to the exact builders and
argument/variable names in:
<code>src_dev/engines/el/impl/equations.R</code> and
<code>src_dev/engines/el/impl/jacobian.R</code>.</p>
<div class="section level4">
<h4 id="estimating-equation-builders-equations-r">Estimating-equation builders (<code>equations.R</code>)<a class="anchor" aria-label="anchor" href="#estimating-equation-builders-equations-r"></a>
</h4>
<table class="table">
<colgroup>
<col width="25%">
<col width="25%">
<col width="25%">
<col width="25%">
</colgroup>
<thead><tr class="header">
<th>Theory block</th>
<th>IID (data.frame) implementation</th>
<th>Survey (survey.design) implementation</th>
<th>Code identifiers used inside the closure</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>Unknown vector
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Œ∏</mi><annotation encoding="application/x-tex">\theta</annotation></semantics></math>
</td>
<td>
<code>el_build_equation_system(...)(params)</code> with
<code>params = c(beta, z, lambda_x)</code>
</td>
<td>
<code>el_build_equation_system_survey(...)(params)</code> with
<code>params = c(beta, z, lambda_W, lambda_x)</code>
</td>
<td>
<code>beta_vec</code>, <code>z</code>,
<code>W &lt;- plogis(z)</code>, <code>lambda_x</code>, (survey)
<code>lambda_W</code>
</td>
</tr>
<tr class="even">
<td>Denominator
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>D</mi><mi>i</mi></msub><annotation encoding="application/x-tex">D_i</annotation></semantics></math>
</td>
<td><code>el_denominator(lambda_W, W_bounded, Xc_lambda, w_i, denom_floor)</code></td>
<td><code>el_denominator(lambda_W, W_bounded, Xc_lambda, w_i, denom_floor)</code></td>
<td>
<code>dpack$denom</code> (guarded),
<code>inv_denominator &lt;- dpack$inv</code>,
<code>active &lt;- dpack$active</code>
</td>
</tr>
<tr class="odd">
<td>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>w</mi><mi>i</mi></msub><annotation encoding="application/x-tex">w_i</annotation></semantics></math>
and derivatives</td>
<td><code>el_core_eta_state(family, eta_raw, ETA_CAP)</code></td>
<td><code>el_core_eta_state(family, eta_raw, ETA_CAP)</code></td>
<td>
<code>eta_raw</code>, <code>w_i</code>, <code>mu_eta_i</code>,
<code>s_eta_i</code>
</td>
</tr>
<tr class="even">
<td>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Œ≤</mi><annotation encoding="application/x-tex">\beta</annotation></semantics></math>
equations
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>g</mi><mi>Œ≤</mi></msub><annotation encoding="application/x-tex">g_\beta</annotation></semantics></math>
</td>
<td><code>eq_betas &lt;- shared_weighted_Xty(missingness_model_matrix, respondent_weights, beta_eq_term)</code></td>
<td>same</td>
<td>
<code>missingness_model_matrix</code>,
<code>respondent_weights</code>,
<code>beta_eq_term &lt;- s_eta_i - lambda_W * mu_eta_i * inv_denominator</code>
</td>
</tr>
<tr class="odd">
<td>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>W</mi><annotation encoding="application/x-tex">W</annotation></semantics></math>
constraint
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>g</mi><mi>W</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>2</mn><mo stretchy="true" form="postfix">)</mo></mrow></msubsup><annotation encoding="application/x-tex">g_W^{(2)}</annotation></semantics></math>
</td>
<td><code>eq_W &lt;- crossprod(respondent_weights * inv_denominator, (w_i - W_bounded))</code></td>
<td><code>eq_W_constraint &lt;- crossprod(respondent_weights * inv_denominator, (w_i - W_bounded))</code></td>
<td>
<code>w_i</code>, <code>W_bounded</code>,
<code>inv_denominator</code>
</td>
</tr>
<tr class="even">
<td>Auxiliary constraints
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>g</mi><mi>x</mi></msub><annotation encoding="application/x-tex">g_x</annotation></semantics></math>
</td>
<td><code>eq_constraints &lt;- shared_weighted_Xty(X_centered, respondent_weights, inv_denominator)</code></td>
<td>same</td>
<td><code>X_centered &lt;- sweep(auxiliary_matrix, 2, mu_x_scaled, "-")</code></td>
</tr>
<tr class="odd">
<td>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Œª</mi><mi>W</mi></msub><annotation encoding="application/x-tex">\lambda_W</annotation></semantics></math>
profiling / linkage</td>
<td>IID: <code>lambda_W &lt;- el_lambda_W(C_const, W_bounded)</code>
with <code>C_const &lt;- (N_pop/n_resp_weighted) - 1</code>
</td>
<td>Survey:
<code>eq_W_link &lt;- (T0/(1-W_bounded)) - lambda_W * sum_d_over_D</code>
</td>
<td>IID: <code>C_const</code>, <code>n_resp_weighted</code>; Survey:
<code>T0 &lt;- N_pop - n_resp_weighted</code>,
<code>sum_d_over_D &lt;- crossprod(respondent_weights, inv_denominator)</code>
</td>
</tr>
</tbody>
</table>
</div>
<div class="section level4">
<h4 id="analytic-jacobian-builders-jacobian-r">Analytic Jacobian builders (<code>jacobian.R</code>)<a class="anchor" aria-label="anchor" href="#analytic-jacobian-builders-jacobian-r"></a>
</h4>
<table class="table">
<colgroup>
<col width="25%">
<col width="25%">
<col width="25%">
<col width="25%">
</colgroup>
<thead><tr class="header">
<th>Object</th>
<th>IID (data.frame) builder</th>
<th>Survey (survey.design) builder</th>
<th>Notes on block ordering / names</th>
</tr></thead>
<tbody>
<tr class="odd">
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>Œ∏</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>‚àÇ</mi><mi>F</mi><mi>/</mi><mi>‚àÇ</mi><mi>Œ∏</mi></mrow><annotation encoding="application/x-tex">A(\theta) = \partial F/\partial\theta</annotation></semantics></math></td>
<td><code>el_build_jacobian(...)(params)</code></td>
<td><code>el_build_jacobian_survey(...)(params)</code></td>
<td>Both return a square matrix <code>full_mat</code> with parameter
ordering matching the corresponding <code>equations.R</code>
closure.</td>
</tr>
<tr class="even">
<td>Parameter ordering</td>
<td><code>params = c(beta, z, lambda_x)</code></td>
<td><code>params = c(beta, z, lambda_W, lambda_x)</code></td>
<td>Indices in code: IID uses <code>idx_beta</code>, <code>idx_W</code>;
survey uses <code>idx_beta</code>, <code>idx_z</code>,
<code>idx_lambdaW</code>, <code>idx_lambda_x</code>.</td>
</tr>
<tr class="odd">
<td>Equation ordering (rows)</td>
<td><code>c(beta eqs, W eq, aux eqs)</code></td>
<td><code>c(beta eqs, W constraint, aux eqs, W link)</code></td>
<td>Survey row indices are annotated in
<code><a href="../reference/el_build_jacobian_survey.html">el_build_jacobian_survey()</a></code> as <code>idx_eq_beta</code>,
<code>idx_eq_W</code>, <code>idx_eq_aux</code>,
<code>idx_eq_link</code>.</td>
</tr>
<tr class="even">
<td>Guard consistency</td>
<td><code>el_denominator(...); active &lt;- dpack$active</code></td>
<td>same</td>
<td>Terms involving derivatives of <code>1/D_i</code> are multiplied by
<code>active</code> to match the denominator floor in the
equations.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section level3">
<h3 id="remarks">Remarks<a class="anchor" aria-label="anchor" href="#remarks"></a>
</h3>
<ul>
<li>For logit and probit,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>s</mi><mi>i</mi></msub><annotation encoding="application/x-tex">s_i</annotation></semantics></math>
is the log-likelihood score
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>‚àÇ</mi><mo>log</mo><msub><mi>w</mi><mi>i</mi></msub><mi>/</mi><mi>‚àÇ</mi><msub><mi>Œ∑</mi><mi>i</mi></msub><mo>=</mo><msub><mi>Œº</mi><mrow><mi>Œ∑</mi><mo>,</mo><mi>i</mi></mrow></msub><mi>/</mi><msub><mi>w</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\partial\log w_i/\partial\eta_i = \mu_{\eta,i}/w_i</annotation></semantics></math>
(equals
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>‚àí</mo><msub><mi>w</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">1-w_i</annotation></semantics></math>
for logit; behaves like
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>œï</mi><mi>/</mi><mi>Œ¶</mi></mrow><annotation encoding="application/x-tex">\phi/\Phi</annotation></semantics></math>
for probit when
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>w</mi><mi>i</mi></msub><annotation encoding="application/x-tex">w_i</annotation></semantics></math>
is clipped away from 0). This follows the paper‚Äôs MLE derivation; EL
constraints supply the nonparametric part.</li>
</ul>
</div>
</div>
<div class="section level2">
<h2 id="survey-extension-design-weighted-qls-system">Survey extension: design-weighted QLS system<a class="anchor" aria-label="anchor" href="#survey-extension-design-weighted-qls-system"></a>
</h2>
<p>The original QLS paper derives these equations under simple random
sampling, where each respondent has equal weight. In practice we often
work with complex survey designs and design weights
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>i</mi></msub><mo>‚âà</mo><mn>1</mn><mi>/</mi><msub><mi>œÄ</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">d_i \approx 1/\pi_i</annotation></semantics></math>,
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>œÄ</mi><mi>i</mi></msub><annotation encoding="application/x-tex">\pi_i</annotation></semantics></math>
is the inclusion probability for unit
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>.
In our implementation we extend the QLS system using a
<strong>design-weighted empirical likelihood</strong>:</p>
<ul>
<li>For respondents
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>‚àà</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">i \in R</annotation></semantics></math>
we use base weights
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo>=</mo><msub><mi>d</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i = d_i</annotation></semantics></math>.</li>
<li>We approximate the unknown distribution of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mi>Y</mi><mo>,</mo><mi>X</mi><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(Y,X)</annotation></semantics></math>
by a discrete measure
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mtext mathvariant="normal">EL</mtext></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>A</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><munder><mo>‚àë</mo><mrow><mi>i</mi><mo>‚àà</mo><mi>R</mi></mrow></munder><msub><mi>d</mi><mi>i</mi></msub><msub><mi>p</mi><mi>i</mi></msub><mspace width="0.167em"></mspace><mn>ùüè</mn><mo stretchy="false" form="prefix">{</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>y</mi><mi>i</mi></msub><mo>,</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>‚àà</mo><mi>A</mi><mo stretchy="false" form="postfix">}</mo><mo>,</mo></mrow><annotation encoding="application/x-tex">
F_{\text{EL}}(A) = \sum_{i\in R} d_i p_i\,\mathbf{1}\{(y_i,x_i)\in A\},
</annotation></semantics></math> where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mi>i</mi></msub><mo>‚â•</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">p_i \ge 0</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>‚àë</mo><mi>i</mi></msub><msub><mi>d</mi><mi>i</mi></msub><msub><mi>p</mi><mi>i</mi></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\sum_i d_i p_i = 1</annotation></semantics></math>.</li>
<li>Expectations under
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>
are represented by design-weighted sums
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>‚àë</mo><mi>i</mi></msub><msub><mi>d</mi><mi>i</mi></msub><msub><mi>p</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mo>‚ãÖ</mo><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\sum_i d_i p_i(\cdot)</annotation></semantics></math>.</li>
</ul>
<p>We impose the following constraints, which are the design-weighted
analogues of QLS (3):</p>
<ul>
<li>Normalization:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><munder><mo>‚àë</mo><mrow><mi>i</mi><mo>‚àà</mo><mi>R</mi></mrow></munder><msub><mi>d</mi><mi>i</mi></msub><msub><mi>p</mi><mi>i</mi></msub><mo>=</mo><mn>1</mn><mi>.</mi></mrow><annotation encoding="application/x-tex">
\sum_{i\in R} d_i p_i = 1.
</annotation></semantics></math>
</li>
<li>Response-rate constraint:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><munder><mo>‚àë</mo><mrow><mi>i</mi><mo>‚àà</mo><mi>R</mi></mrow></munder><msub><mi>d</mi><mi>i</mi></msub><msub><mi>p</mi><mi>i</mi></msub><mo minsize="1.2" maxsize="1.2" stretchy="false" form="prefix">(</mo><msub><mi>w</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>Œ∏</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>‚àí</mo><mi>W</mi><mo minsize="1.2" maxsize="1.2" stretchy="false" form="postfix">)</mo><mo>=</mo><mn>0</mn><mi>.</mi></mrow><annotation encoding="application/x-tex">
\sum_{i\in R} d_i p_i \bigl(w_i(\theta) - W\bigr) = 0.
</annotation></semantics></math>
</li>
<li>Auxiliary constraints (vector case):
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><munder><mo>‚àë</mo><mrow><mi>i</mi><mo>‚àà</mo><mi>R</mi></mrow></munder><msub><mi>d</mi><mi>i</mi></msub><msub><mi>p</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>X</mi><mi>i</mi></msub><mo>‚àí</mo><msub><mi>Œº</mi><mi>x</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>0</mn><mi>.</mi></mrow><annotation encoding="application/x-tex">
\sum_{i\in R} d_i p_i (X_i - \mu_x) = 0.
</annotation></semantics></math>
</li>
</ul>
<p>Maximizing the design-weighted pseudo-likelihood under these
constraints yields EL weights of the same tilted form as in QLS:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>Œ∏</mi><mo>,</mo><mi>W</mi><mo>,</mo><msub><mi>Œª</mi><mi>x</mi></msub><mo>,</mo><msub><mi>Œª</mi><mi>W</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mspace width="0.278em"></mspace><mo>‚àù</mo><mspace width="0.278em"></mspace><mfrac><mn>1</mn><msub><mi>D</mi><mi>i</mi></msub></mfrac><mo>,</mo><mspace width="2.0em"></mspace><msub><mi>D</mi><mi>i</mi></msub><mo>=</mo><mn>1</mn><mo>+</mo><msub><mi>Œª</mi><mi>W</mi></msub><mo minsize="1.2" maxsize="1.2" stretchy="false" form="prefix">(</mo><msub><mi>w</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>Œ∏</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>‚àí</mo><mi>W</mi><mo minsize="1.2" maxsize="1.2" stretchy="false" form="postfix">)</mo><mo>+</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>X</mi><mi>i</mi></msub><mo>‚àí</mo><msub><mi>Œº</mi><mi>x</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>‚ä§</mi></msup><msub><mi>Œª</mi><mi>x</mi></msub><mo>,</mo></mrow><annotation encoding="application/x-tex">
p_i(\theta, W, \lambda_x, \lambda_W) \;\propto\; \frac{1}{D_i},\qquad
D_i = 1 + \lambda_W\bigl(w_i(\theta) - W\bigr) + (X_i - \mu_x)^\top \lambda_x,
</annotation></semantics></math> with the proportionality constant
chosen such that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>‚àë</mo><mi>i</mi></msub><msub><mi>d</mi><mi>i</mi></msub><msub><mi>p</mi><mi>i</mi></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\sum_i d_i p_i = 1</annotation></semantics></math>.
In our implementation the <strong>unnormalized EL masses</strong> are
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>m</mi><mi>i</mi></msub><mo>=</mo><mfrac><msub><mi>d</mi><mi>i</mi></msub><msub><mi>D</mi><mi>i</mi></msub></mfrac><mo>,</mo></mrow><annotation encoding="application/x-tex">
m_i = \frac{d_i}{D_i},
</annotation></semantics></math> and the probability-scale weights are
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>p</mi><mi>i</mi><mrow><mi mathvariant="normal">E</mi><mi mathvariant="normal">L</mi></mrow></msubsup><mo>=</mo><msub><mi>m</mi><mi>i</mi></msub><mi>/</mi><msub><mo>‚àë</mo><mi>j</mi></msub><msub><mi>m</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">p_i^{\mathrm{EL}} = m_i / \sum_j m_j</annotation></semantics></math>.</p>
<p>The corresponding design-weighted QLS estimating system in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mi>Œ≤</mi><mo>,</mo><mi>W</mi><mo>,</mo><msub><mi>Œª</mi><mi>W</mi></msub><mo>,</mo><msub><mi>Œª</mi><mi>x</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(\beta, W, \lambda_W, \lambda_x)</annotation></semantics></math>
can be written as:</p>
<ul>
<li>Auxiliary block:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>g</mi><mi>x</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>Œ≤</mi><mo>,</mo><mi>W</mi><mo>,</mo><msub><mi>Œª</mi><mi>W</mi></msub><mo>,</mo><msub><mi>Œª</mi><mi>x</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><munder><mo>‚àë</mo><mrow><mi>i</mi><mo>‚àà</mo><mi>R</mi></mrow></munder><msub><mi>d</mi><mi>i</mi></msub><mfrac><mrow><msub><mi>X</mi><mi>i</mi></msub><mo>‚àí</mo><msub><mi>Œº</mi><mi>x</mi></msub></mrow><msub><mi>D</mi><mi>i</mi></msub></mfrac><mo>=</mo><mn>0</mn><mi>.</mi></mrow><annotation encoding="application/x-tex">
g_x(\beta, W, \lambda_W, \lambda_x)
= \sum_{i\in R} d_i \frac{X_i - \mu_x}{D_i} = 0.
</annotation></semantics></math>
</li>
<li>Response-rate constraint:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>g</mi><mi>W</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>2</mn><mo stretchy="true" form="postfix">)</mo></mrow></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><mi>Œ≤</mi><mo>,</mo><mi>W</mi><mo>,</mo><msub><mi>Œª</mi><mi>W</mi></msub><mo>,</mo><msub><mi>Œª</mi><mi>x</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><munder><mo>‚àë</mo><mrow><mi>i</mi><mo>‚àà</mo><mi>R</mi></mrow></munder><msub><mi>d</mi><mi>i</mi></msub><mfrac><mrow><msub><mi>w</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>Œ≤</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>‚àí</mo><mi>W</mi></mrow><msub><mi>D</mi><mi>i</mi></msub></mfrac><mo>=</mo><mn>0</mn><mi>.</mi></mrow><annotation encoding="application/x-tex">
g_W^{(2)}(\beta, W, \lambda_W, \lambda_x)
= \sum_{i\in R} d_i \frac{w_i(\beta) - W}{D_i} = 0.
</annotation></semantics></math>
</li>
<li>Score equations for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Œ≤</mi><annotation encoding="application/x-tex">\beta</annotation></semantics></math>:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>g</mi><mi>Œ≤</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>Œ≤</mi><mo>,</mo><mi>W</mi><mo>,</mo><msub><mi>Œª</mi><mi>W</mi></msub><mo>,</mo><msub><mi>Œª</mi><mi>x</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><munder><mo>‚àë</mo><mrow><mi>i</mi><mo>‚àà</mo><mi>R</mi></mrow></munder><msub><mi>d</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">[</mo><mfrac><mrow><mi>‚àÇ</mi><mo>log</mo><msub><mi>w</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>Œ≤</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><mrow><mi>‚àÇ</mi><mi>Œ≤</mi></mrow></mfrac><mo>‚àí</mo><msub><mi>Œª</mi><mi>W</mi></msub><mfrac><mn>1</mn><msub><mi>D</mi><mi>i</mi></msub></mfrac><mfrac><mrow><mi>‚àÇ</mi><msub><mi>w</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>Œ≤</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><mrow><mi>‚àÇ</mi><mi>Œ≤</mi></mrow></mfrac><mo stretchy="true" form="postfix">]</mo></mrow><mo>=</mo><mn>0</mn><mi>.</mi></mrow><annotation encoding="application/x-tex">
g_\beta(\beta, W, \lambda_W, \lambda_x)
= \sum_{i\in R} d_i \left[
    \frac{\partial \log w_i(\beta)}{\partial \beta}
    - \lambda_W \frac{1}{D_i}
      \frac{\partial w_i(\beta)}{\partial \beta}
  \right] = 0.
</annotation></semantics></math>
</li>
<li>Linkage between
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Œª</mi><mi>W</mi></msub><annotation encoding="application/x-tex">\lambda_W</annotation></semantics></math>
and the nonrespondent total:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>g</mi><mi>W</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><mi>Œ≤</mi><mo>,</mo><mi>W</mi><mo>,</mo><msub><mi>Œª</mi><mi>W</mi></msub><mo>,</mo><msub><mi>Œª</mi><mi>x</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mfrac><msub><mi>T</mi><mn>0</mn></msub><mrow><mn>1</mn><mo>‚àí</mo><mi>W</mi></mrow></mfrac><mo>‚àí</mo><msub><mi>Œª</mi><mi>W</mi></msub><munder><mo>‚àë</mo><mrow><mi>i</mi><mo>‚àà</mo><mi>R</mi></mrow></munder><mfrac><msub><mi>d</mi><mi>i</mi></msub><msub><mi>D</mi><mi>i</mi></msub></mfrac><mo>=</mo><mn>0</mn><mo>,</mo></mrow><annotation encoding="application/x-tex">
g_W^{(1)}(\beta, W, \lambda_W, \lambda_x)
= \frac{T_0}{1 - W} - \lambda_W \sum_{i\in R} \frac{d_i}{D_i} = 0,
</annotation></semantics></math> where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>0</mn></msub><mo>=</mo><msub><mi>N</mi><mrow><mi mathvariant="normal">p</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">p</mi></mrow></msub><mo>‚àí</mo><msub><mo>‚àë</mo><mrow><mi>i</mi><mo>‚àà</mo><mi>R</mi></mrow></msub><msub><mi>d</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">T_0 = N_{\mathrm{pop}} - \sum_{i\in R} d_i</annotation></semantics></math>
on the analysis scale.</li>
</ul>
<p>In code this system is implemented by
<code><a href="../reference/el_build_equation_system_survey.html">el_build_equation_system_survey()</a></code> in
<code>src_dev/engines/el/impl/equations.R</code>. The parameter vector
is
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Œ∏</mi><mtext mathvariant="normal">survey</mtext></msub><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>Œ≤</mi><mo>,</mo><mi>z</mi><mo>,</mo><msub><mi>Œª</mi><mi>W</mi></msub><mo>,</mo><msub><mi>Œª</mi><mi>x</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mspace width="2.0em"></mspace><mi>z</mi><mo>=</mo><mo>logit</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>W</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo></mrow><annotation encoding="application/x-tex">
\theta_{\text{survey}} = (\beta, z, \lambda_W, \lambda_x),\qquad z = \operatorname{logit}(W),
</annotation></semantics></math> and the solver treats
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Œª</mi><mi>W</mi></msub><annotation encoding="application/x-tex">\lambda_W</annotation></semantics></math>
as an explicit unknown. When all design weights are equal and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>N</mi><mtext mathvariant="normal">pop</mtext></msub><annotation encoding="application/x-tex">N_{\text{pop}}</annotation></semantics></math>
and the respondent count match the simple random sampling setup, this
system reduces exactly to the original QLS equations (6)-(10).</p>
<p>For survey designs we build an analytic Jacobian for this
design-weighted system whenever the response family supplies a second
derivative <code>d2mu.deta2</code> (logit and probit). The Jacobian
structure mirrors the IID case but with the expanded parameter vector
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mi>Œ≤</mi><mo>,</mo><mi>z</mi><mo>,</mo><msub><mi>Œª</mi><mi>W</mi></msub><mo>,</mo><msub><mi>Œª</mi><mi>x</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(\beta, z, \lambda_W, \lambda_x)</annotation></semantics></math>
and the additional blocks for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>g</mi><mi>W</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></msubsup><annotation encoding="application/x-tex">g_W^{(1)}</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>g</mi><mi>W</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>2</mn><mo stretchy="true" form="postfix">)</mo></mrow></msubsup><annotation encoding="application/x-tex">g_W^{(2)}</annotation></semantics></math>.
When analytic derivatives are not available, <code>nleqslv</code> falls
back to numeric/Broyden Jacobians.</p>
<div class="section level3">
<h3 id="wu-style-strata-augmentation-survey-designs">Wu-style strata augmentation (survey designs)<a class="anchor" aria-label="anchor" href="#wu-style-strata-augmentation-survey-designs"></a>
</h3>
<p>For some stratified designs, especially when the NMAR mechanism
varies strongly across strata, it is important that the EL weights
preserve the <strong>stratum composition</strong> implied by the survey
design. Following ideas from Wu-style calibration, we augment the
auxiliary vector with stratum indicators when a
<code>survey.design</code> object is provided:</p>
<ul>
<li>Recover a strata factor from the design (prefer
<code>design$strata</code>; fall back to the original
<code>strata=</code> call when needed).</li>
<li>Build dummy variables for strata (dropping one reference
level).</li>
<li>Compute stratum totals
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>N</mi><mi>h</mi></msub><annotation encoding="application/x-tex">N_h</annotation></semantics></math>
on the analysis scale from the design weights and convert to stratum
shares
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>W</mi><mi>h</mi></msub><mo>=</mo><msub><mi>N</mi><mi>h</mi></msub><mi>/</mi><msub><mi>N</mi><mrow><mi mathvariant="normal">p</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">p</mi></mrow></msub></mrow><annotation encoding="application/x-tex">W_h = N_h / N_{\mathrm{pop}}</annotation></semantics></math>.</li>
<li>Append these stratum dummies to the auxiliary matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math>
and their targets
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>W</mi><mi>h</mi></msub><annotation encoding="application/x-tex">W_h</annotation></semantics></math>
to the auxiliary means.</li>
</ul>
<p>The EL constraints then include additional terms of the form
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><munder><mo>‚àë</mo><mrow><mi>i</mi><mo>‚àà</mo><mi>R</mi></mrow></munder><msub><mi>d</mi><mi>i</mi></msub><msub><mi>p</mi><mi>i</mi></msub><mo minsize="1.2" maxsize="1.2" stretchy="false" form="prefix">(</mo><mn>ùüè</mn><mo stretchy="false" form="prefix">{</mo><msub><mi>H</mi><mi>i</mi></msub><mo>=</mo><mi>h</mi><mo stretchy="false" form="postfix">}</mo><mo>‚àí</mo><msub><mi>W</mi><mi>h</mi></msub><mo minsize="1.2" maxsize="1.2" stretchy="false" form="postfix">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">
\sum_{i\in R} d_i p_i \bigl(\mathbf{1}\{H_i = h\} - W_h\bigr) = 0
</annotation></semantics></math> for each nonreference stratum
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>h</mi><annotation encoding="application/x-tex">h</annotation></semantics></math>.
This forces the EL weights to reproduce the design-implied stratum
shares while still adjusting within strata for NMAR. In the
implementation this augmentation is performed in the survey entry point
(<code>src_dev/engines/el/impl/survey.R</code>) before auxiliary means
are resolved, and the resulting augmented auxiliaries flow through to
<code><a href="../reference/el_build_equation_system.html">el_build_equation_system()</a></code> or
<code><a href="../reference/el_build_equation_system_survey.html">el_build_equation_system_survey()</a></code> depending on the data
type. The behavior is controlled by the logical
<code>strata_augmentation</code> argument of <code><a href="../reference/el_engine.html">el_engine()</a></code>
(default <code>TRUE</code>); it has an effect only when
<code>data</code> is a <code>survey.design</code> with defined
strata.</p>
<p>Implementation detail: when the user does not supply
<code>auxiliary_means</code>, the targets for the augmented stratum
indicators are obtained automatically as the design-weighted means of
those dummy columns in the full sample (via
<code><a href="../reference/el_resolve_auxiliaries.html">el_resolve_auxiliaries()</a></code>), which equals the design-implied
stratum shares on the analysis scale. When the user does supply
<code>auxiliary_means</code>, the augmentation appends the implied
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>W</mi><mi>h</mi></msub><annotation encoding="application/x-tex">W_h</annotation></semantics></math>
targets to that vector.</p>
<p>Our survey EL implementation should be viewed as a design-weighted
analogue of QLS, informed by the pseudo empirical likelihood literature
(Chen and Sitter 1999; Wu 2005), rather than a verbatim implementation
of any single paper.</p>
</div>
</div>
<div class="section level2">
<h2 id="analytic-jacobian-a-matrix-iid-path">Analytic Jacobian
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
Matrix, IID path)<a class="anchor" aria-label="anchor" href="#analytic-jacobian-a-matrix-iid-path"></a>
</h2>
<p>For the IID (data-frame) path we differentiate
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>Œ∏</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">F(\theta) = 0</annotation></semantics></math>
with respect to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Œ∏</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>Œ≤</mi><mo>,</mo><mi>z</mi><mo>,</mo><msub><mi>Œª</mi><mi>x</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\theta = (\beta, z, \lambda_x)</annotation></semantics></math>.
Let:</p>
<ul>
<li>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Œ∑</mi><mi>i</mi></msub><mo>=</mo><msub><mi>Z</mi><mi>i</mi></msub><mi>Œ≤</mi></mrow><annotation encoding="application/x-tex">\eta_i = Z_i \beta</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mi>i</mi></msub><mo>=</mo><mtext mathvariant="normal">linkinv</mtext><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Œ∑</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">w_i = \text{linkinv}(\eta_i)</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Œº</mi><mrow><mi>Œ∑</mi><mo>,</mo><mi>i</mi></mrow></msub><mo>=</mo><mfrac displaystyle="true"><mrow><mi>d</mi><mi>w</mi></mrow><mrow><mi>d</mi><mi>Œ∑</mi></mrow></mfrac><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Œ∑</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mu_{\eta,i} = \dfrac{dw}{d\eta}(\eta_i)</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Œº</mi><msub><mi>‚Ä≥</mi><mi>i</mi></msub><mo>=</mo><mfrac displaystyle="true"><mrow><msup><mi>d</mi><mn>2</mn></msup><mi>w</mi></mrow><mrow><mi>d</mi><msup><mi>Œ∑</mi><mn>2</mn></msup></mrow></mfrac><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Œ∑</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mu''_i = \dfrac{d^2 w}{d\eta^2}(\eta_i)</annotation></semantics></math>
</li>
<li>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mo>=</mo><mtext mathvariant="normal">plogis</mtext><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">W = \text{plogis}(z)</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>d</mi><mi>W</mi></mrow><mrow><mi>d</mi><mi>z</mi></mrow></mfrac><mo>=</mo><mi>W</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>‚àí</mo><mi>W</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\frac{dW}{dz} = W(1 - W)</annotation></semantics></math>
</li>
<li>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Œª</mi><mi>W</mi></msub><mo>=</mo><mfrac><mi>C</mi><mrow><mn>1</mn><mo>‚àí</mo><mi>W</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\lambda_W = \frac{C}{1 - W}</annotation></semantics></math>,
so
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>d</mi><msub><mi>Œª</mi><mi>W</mi></msub></mrow><mrow><mi>d</mi><mi>W</mi></mrow></mfrac><mo>=</mo><mfrac><mi>C</mi><msup><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>‚àí</mo><mi>W</mi><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup></mfrac></mrow><annotation encoding="application/x-tex">\frac{d\lambda_W}{dW} = \frac{C}{(1 - W)^2}</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>d</mi><msub><mi>Œª</mi><mi>W</mi></msub></mrow><mrow><mi>d</mi><mi>z</mi></mrow></mfrac><mo>=</mo><mfrac><mrow><mi>d</mi><msub><mi>Œª</mi><mi>W</mi></msub></mrow><mrow><mi>d</mi><mi>W</mi></mrow></mfrac><mo>‚ãÖ</mo><mfrac><mrow><mi>d</mi><mi>W</mi></mrow><mrow><mi>d</mi><mi>z</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{d\lambda_W}{dz} = \frac{d\lambda_W}{dW} \cdot \frac{dW}{dz}</annotation></semantics></math>
</li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mrow><mtext mathvariant="normal">centered</mtext><mo>,</mo><mi>i</mi></mrow></msub><mo>=</mo><msub><mi>X</mi><mi>i</mi></msub><mo>‚àí</mo><msub><mi>Œº</mi><mi>x</mi></msub></mrow><annotation encoding="application/x-tex">X_{\text{centered},i} = X_i - \mu_x</annotation></semantics></math></li>
</ul>
<div class="section level3">
<h3 id="intermediate-derivatives">Intermediate Derivatives<a class="anchor" aria-label="anchor" href="#intermediate-derivatives"></a>
</h3>
<ul>
<li>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub><mo>=</mo><msub><mi>Œº</mi><mrow><mi>Œ∑</mi><mo>,</mo><mi>i</mi></mrow></msub><mi>/</mi><msub><mi>w</mi><mi>i</mi></msub><mo>‚áí</mo><mspace width="0.278em"></mspace><mfrac><mrow><mi>d</mi><msub><mi>s</mi><mi>i</mi></msub></mrow><mrow><mi>d</mi><msub><mi>Œ∑</mi><mi>i</mi></msub></mrow></mfrac><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>Œº</mi><msub><mi>‚Ä≤</mi><mrow><mi>Œ∑</mi><mo>,</mo><mi>i</mi></mrow></msub><msub><mi>w</mi><mi>i</mi></msub><mo>‚àí</mo><msubsup><mi>Œº</mi><mrow><mi>Œ∑</mi><mo>,</mo><mi>i</mi></mrow><mn>2</mn></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mi>/</mi><msubsup><mi>w</mi><mi>i</mi><mn>2</mn></msubsup></mrow><annotation encoding="application/x-tex">s_i = \mu_{\eta,i}/w_i \Rightarrow \;\frac{ds_i}{d\eta_i} = (\mu'_{\eta,i}w_i - \mu_{\eta,i}^2)/w_i^2</annotation></semantics></math>
with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Œº</mi><msub><mi>‚Ä≤</mi><mrow><mi>Œ∑</mi><mo>,</mo><mi>i</mi></mrow></msub><mo>=</mo><mfrac displaystyle="true"><mrow><mi>d</mi><msub><mi>Œº</mi><mrow><mi>Œ∑</mi><mo>,</mo><mi>i</mi></mrow></msub></mrow><mrow><mi>d</mi><msub><mi>Œ∑</mi><mi>i</mi></msub></mrow></mfrac><mo>=</mo><mfrac displaystyle="true"><mrow><msup><mi>d</mi><mn>2</mn></msup><mi>w</mi></mrow><mrow><mi>d</mi><msubsup><mi>Œ∑</mi><mi>i</mi><mn>2</mn></msubsup></mrow></mfrac><mo>‚â°</mo><mi>Œº</mi><msub><mi>‚Ä≥</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\mu'_{\eta,i} = \dfrac{d\mu_{\eta,i}}{d\eta_i} = \dfrac{d^2 w}{d\eta_i^2} \equiv \mu''_i</annotation></semantics></math>
(this is <code>d2mu.deta2(eta_i)</code> in code)</li>
<li>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>i</mi></msub><mo>=</mo><mn>1</mn><mo>+</mo><msub><mi>Œª</mi><mi>W</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>w</mi><mi>i</mi></msub><mo>‚àí</mo><mi>W</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><msubsup><mi>X</mi><mrow><mtext mathvariant="normal">centered</mtext><mo>,</mo><mi>i</mi></mrow><mi>T</mi></msubsup><msub><mi>Œª</mi><mi>x</mi></msub></mrow><annotation encoding="application/x-tex">D_i = 1 + \lambda_W (w_i - W) + X_{\text{centered},i}^T \lambda_x</annotation></semantics></math><ul>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>‚àÇ</mi><msub><mi>D</mi><mi>i</mi></msub></mrow><mrow><mi>‚àÇ</mi><msub><mi>Œ∑</mi><mi>i</mi></msub></mrow></mfrac><mo>=</mo><msub><mi>Œª</mi><mi>W</mi></msub><msub><mi>Œº</mi><mrow><mi>Œ∑</mi><mo>,</mo><mi>i</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\frac{\partial D_i}{\partial \eta_i} = \lambda_W \mu_{\eta,i}</annotation></semantics></math></li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>‚àÇ</mi><msub><mi>D</mi><mi>i</mi></msub></mrow><mrow><mi>‚àÇ</mi><mi>z</mi></mrow></mfrac><mo>=</mo><mfrac><mrow><mi>‚àÇ</mi><msub><mi>Œª</mi><mi>W</mi></msub></mrow><mrow><mi>‚àÇ</mi><mi>z</mi></mrow></mfrac><mo>‚ãÖ</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>w</mi><mi>i</mi></msub><mo>‚àí</mo><mi>W</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>‚àí</mo><msub><mi>Œª</mi><mi>W</mi></msub><mo>‚ãÖ</mo><mfrac><mrow><mi>d</mi><mi>W</mi></mrow><mrow><mi>d</mi><mi>z</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\partial D_i}{\partial z} = \frac{\partial \lambda_W}{\partial z} \cdot (w_i - W) - \lambda_W \cdot \frac{dW}{dz}</annotation></semantics></math></li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>‚àÇ</mi><msub><mi>D</mi><mi>i</mi></msub></mrow><mrow><mi>‚àÇ</mi><msub><mi>Œª</mi><mi>x</mi></msub></mrow></mfrac><mo>=</mo><msub><mi>X</mi><mrow><mtext mathvariant="normal">centered</mtext><mo>,</mo><mi>i</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\frac{\partial D_i}{\partial \lambda_x} = X_{\text{centered},i}</annotation></semantics></math></li>
</ul>
</li>
</ul>
<p>Define
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext mathvariant="normal">inv</mtext><mi>i</mi></msub><mo>=</mo><mn>1</mn><mi>/</mi><msub><mi>D</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\text{inv}_i = 1 / D_i</annotation></semantics></math>
and the scalar term driving
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Œ≤</mi><annotation encoding="application/x-tex">\beta</annotation></semantics></math>-equations:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>i</mi></msub><mo>=</mo><msub><mi>s</mi><mi>i</mi></msub><mo>‚àí</mo><msub><mi>Œª</mi><mi>W</mi></msub><msub><mi>Œº</mi><mrow><mi>Œ∑</mi><mo>,</mo><mi>i</mi></mrow></msub><msub><mtext mathvariant="normal">inv</mtext><mi>i</mi></msub><mo>,</mo><mspace width="1.0em"></mspace><msub><mi>s</mi><mi>i</mi></msub><mo>=</mo><mfrac><msub><mi>Œº</mi><mrow><mi>Œ∑</mi><mo>,</mo><mi>i</mi></mrow></msub><msub><mi>w</mi><mi>i</mi></msub></mfrac><mi>.</mi></mrow><annotation encoding="application/x-tex">T_i = s_i - \lambda_W \mu_{\eta,i} \text{inv}_i,\quad s_i = \frac{\mu_{\eta,i}}{w_i}.</annotation></semantics></math></p>
<p>For the logit and probit families we use simpler closed-form
derivatives of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>s</mi><mi>i</mi></msub><annotation encoding="application/x-tex">s_i</annotation></semantics></math>
in code: for logit,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><msub><mi>s</mi><mi>i</mi></msub><mi>/</mi><mi>d</mi><msub><mi>Œ∑</mi><mi>i</mi></msub><mo>=</mo><mo>‚àí</mo><msub><mi>Œº</mi><mrow><mi>Œ∑</mi><mo>,</mo><mi>i</mi></mrow></msub></mrow><annotation encoding="application/x-tex">ds_i/d\eta_i = -\mu_{\eta,i}</annotation></semantics></math>
(because
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub><mo>=</mo><mn>1</mn><mo>‚àí</mo><msub><mi>w</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">s_i = 1 - w_i</annotation></semantics></math>);
for probit,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><msub><mi>s</mi><mi>i</mi></msub><mi>/</mi><mi>d</mi><msub><mi>Œ∑</mi><mi>i</mi></msub><mo>=</mo><mo>‚àí</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Œ∑</mi><mi>i</mi></msub><msub><mi>r</mi><mi>i</mi></msub><mo>+</mo><msubsup><mi>r</mi><mi>i</mi><mn>2</mn></msubsup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">ds_i/d\eta_i = -(\eta_i r_i + r_i^2)</annotation></semantics></math>
with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>r</mi><mi>i</mi></msub><mo>=</mo><mi>œï</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Œ∑</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>/</mi><mi>Œ¶</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Œ∑</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">r_i = \phi(\eta_i)/\Phi(\eta_i)</annotation></semantics></math>
the Mills ratio. The expression above is kept as the generic fallback
for other families.</p>
</div>
<div class="section level3">
<h3 id="compute-its-derivatives">Compute Its Derivatives<a class="anchor" aria-label="anchor" href="#compute-its-derivatives"></a>
</h3>
<p>Using
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mspace width="0.167em"></mspace><mi>Œº</mi><msub><mi>‚Ä≤</mi><mrow><mi>Œ∑</mi><mo>,</mo><mi>i</mi></mrow></msub><mo>=</mo><mi>d</mi><msub><mi>Œº</mi><mrow><mi>Œ∑</mi><mo>,</mo><mi>i</mi></mrow></msub><mi>/</mi><mi>d</mi><msub><mi>Œ∑</mi><mi>i</mi></msub><mo>=</mo><mrow><mi mathvariant="normal">d</mi><mn mathvariant="normal">2</mn><mi mathvariant="normal">m</mi><mi mathvariant="normal">u</mi><mspace width="0.167em"></mspace><mi mathvariant="normal">d</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">a</mi><mn mathvariant="normal">2</mn></mrow><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Œ∑</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\,\mu'_{\eta,i} = d\mu_{\eta,i}/d\eta_i = \mathrm{d2mu\,deta2}(\eta_i)</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mspace width="0.167em"></mspace><mi>d</mi><msub><mi>w</mi><mi>i</mi></msub><mi>/</mi><mi>d</mi><msub><mi>Œ∑</mi><mi>i</mi></msub><mo>=</mo><msub><mi>Œº</mi><mrow><mi>Œ∑</mi><mo>,</mo><mi>i</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\,dw_i/d\eta_i = \mu_{\eta,i}</annotation></semantics></math>,</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>‚àÇ</mi><msub><mi>s</mi><mi>i</mi></msub></mrow><mrow><mi>‚àÇ</mi><msub><mi>Œ∑</mi><mi>i</mi></msub></mrow></mfrac><mo>=</mo><mfrac><mrow><mi>Œº</mi><msub><mi>‚Ä≤</mi><mrow><mi>Œ∑</mi><mo>,</mo><mi>i</mi></mrow></msub><msub><mi>w</mi><mi>i</mi></msub><mo>‚àí</mo><msubsup><mi>Œº</mi><mrow><mi>Œ∑</mi><mo>,</mo><mi>i</mi></mrow><mn>2</mn></msubsup></mrow><msubsup><mi>w</mi><mi>i</mi><mn>2</mn></msubsup></mfrac><mi>.</mi></mrow><annotation encoding="application/x-tex">\frac{\partial s_i}{\partial \eta_i} = \frac{\mu'_{\eta,i} w_i - \mu_{\eta,i}^2}{w_i^2}.</annotation></semantics></math></p>
<p>Also
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mspace width="0.167em"></mspace><mfrac><mrow><mi>‚àÇ</mi><msub><mtext mathvariant="normal">inv</mtext><mi>i</mi></msub></mrow><mrow><mi>‚àÇ</mi><msub><mi>Œ∑</mi><mi>i</mi></msub></mrow></mfrac><mo>=</mo><mo>‚àí</mo><msubsup><mtext mathvariant="normal">inv</mtext><mi>i</mi><mn>2</mn></msubsup><mo>‚ãÖ</mo><mfrac><mrow><mi>‚àÇ</mi><msub><mi>D</mi><mi>i</mi></msub></mrow><mrow><mi>‚àÇ</mi><msub><mi>Œ∑</mi><mi>i</mi></msub></mrow></mfrac><mo>=</mo><mo>‚àí</mo><msubsup><mtext mathvariant="normal">inv</mtext><mi>i</mi><mn>2</mn></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Œª</mi><mi>W</mi></msub><msub><mi>Œº</mi><mrow><mi>Œ∑</mi><mo>,</mo><mi>i</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\,\frac{\partial \text{inv}_i}{\partial \eta_i} = -\text{inv}_i^2 \cdot \frac{\partial D_i}{\partial \eta_i} = -\text{inv}_i^2 (\lambda_W \mu_{\eta,i})</annotation></semantics></math>.
Therefore</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>‚àÇ</mi><msub><mi>T</mi><mi>i</mi></msub></mrow><mrow><mi>‚àÇ</mi><msub><mi>Œ∑</mi><mi>i</mi></msub></mrow></mfrac><mo>=</mo><mfrac><mrow><mi>Œº</mi><msub><mi>‚Ä≤</mi><mrow><mi>Œ∑</mi><mo>,</mo><mi>i</mi></mrow></msub><msub><mi>w</mi><mi>i</mi></msub><mo>‚àí</mo><msubsup><mi>Œº</mi><mrow><mi>Œ∑</mi><mo>,</mo><mi>i</mi></mrow><mn>2</mn></msubsup></mrow><msubsup><mi>w</mi><mi>i</mi><mn>2</mn></msubsup></mfrac><mo>‚àí</mo><msub><mi>Œª</mi><mi>W</mi></msub><mi>Œº</mi><msub><mi>‚Ä≤</mi><mrow><mi>Œ∑</mi><mo>,</mo><mi>i</mi></mrow></msub><msub><mtext mathvariant="normal">inv</mtext><mi>i</mi></msub><mo>+</mo><msubsup><mi>Œª</mi><mi>W</mi><mn>2</mn></msubsup><msup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Œº</mi><mrow><mi>Œ∑</mi><mo>,</mo><mi>i</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup><msubsup><mtext mathvariant="normal">inv</mtext><mi>i</mi><mn>2</mn></msubsup><mi>.</mi></mrow><annotation encoding="application/x-tex">\frac{\partial T_i}{\partial \eta_i} = \frac{\mu'_{\eta,i} w_i - \mu_{\eta,i}^2}{w_i^2} - \lambda_W \mu'_{\eta,i} \text{inv}_i + \lambda_W^2 (\mu_{\eta,i})^2 \text{inv}_i^2.</annotation></semantics></math></p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>‚àÇ</mi><msub><mi>T</mi><mi>i</mi></msub></mrow><mrow><mi>‚àÇ</mi><mi>z</mi></mrow></mfrac><mo>=</mo><mo>‚àí</mo><mfrac><mrow><mi>‚àÇ</mi><msub><mi>Œª</mi><mi>W</mi></msub></mrow><mrow><mi>‚àÇ</mi><mi>z</mi></mrow></mfrac><mo>‚ãÖ</mo><msub><mi>Œº</mi><mrow><mi>Œ∑</mi><mo>,</mo><mi>i</mi></mrow></msub><msub><mtext mathvariant="normal">inv</mtext><mi>i</mi></msub><mo>+</mo><msub><mi>Œª</mi><mi>W</mi></msub><msub><mi>Œº</mi><mrow><mi>Œ∑</mi><mo>,</mo><mi>i</mi></mrow></msub><msubsup><mtext mathvariant="normal">inv</mtext><mi>i</mi><mn>2</mn></msubsup><mo>‚ãÖ</mo><mfrac><mrow><mi>‚àÇ</mi><msub><mi>D</mi><mi>i</mi></msub></mrow><mrow><mi>‚àÇ</mi><mi>z</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\partial T_i}{\partial z} = -\frac{\partial \lambda_W}{\partial z} \cdot \mu_{\eta,i} \text{inv}_i + \lambda_W \mu_{\eta,i} \text{inv}_i^2 \cdot \frac{\partial D_i}{\partial z}</annotation></semantics></math></p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>‚àÇ</mi><msub><mi>T</mi><mi>i</mi></msub></mrow><mrow><mi>‚àÇ</mi><msub><mi>Œª</mi><mi>x</mi></msub></mrow></mfrac><mo>=</mo><msub><mi>Œª</mi><mi>W</mi></msub><msub><mi>Œº</mi><mrow><mi>Œ∑</mi><mo>,</mo><mi>i</mi></mrow></msub><msubsup><mtext mathvariant="normal">inv</mtext><mi>i</mi><mn>2</mn></msubsup><mo>‚ãÖ</mo><msub><mi>X</mi><mrow><mtext mathvariant="normal">centered</mtext><mo>,</mo><mi>i</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\frac{\partial T_i}{\partial \lambda_x} = \lambda_W \mu_{\eta,i} \text{inv}_i^2 \cdot X_{\text{centered},i}</annotation></semantics></math></p>
</div>
<div class="section level3">
<h3 id="assemble-jacobian-blocks-with-a_i-weights">Assemble Jacobian Blocks (with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>a</mi><mi>i</mi></msub><annotation encoding="application/x-tex">a_i</annotation></semantics></math>
weights)<a class="anchor" aria-label="anchor" href="#assemble-jacobian-blocks-with-a_i-weights"></a>
</h3>
<p><strong><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>J</mi><mrow><mi>Œ≤</mi><mi>Œ≤</mi></mrow></msub><annotation encoding="application/x-tex">J_{\beta\beta}</annotation></semantics></math>
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo>√ó</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">K \times K</annotation></semantics></math>)</strong>:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>J</mi><mn>11</mn></msub><mo>=</mo><mo>‚àë</mo><msub><mi>a</mi><mi>i</mi></msub><msubsup><mi>Z</mi><mi>i</mi><mi>T</mi></msubsup><mrow><mo stretchy="true" form="prefix">[</mo><mfrac><mrow><mi>‚àÇ</mi><msub><mi>T</mi><mi>i</mi></msub></mrow><mrow><mi>‚àÇ</mi><msub><mi>Œ∑</mi><mi>i</mi></msub></mrow></mfrac><mo stretchy="true" form="postfix">]</mo></mrow><msub><mi>Z</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">J_{11} = \sum a_i Z_i^T \left[ \frac{\partial T_i}{\partial \eta_i} \right] Z_i</annotation></semantics></math></p>
<p><strong><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>J</mi><mrow><mi>Œ≤</mi><mi>z</mi></mrow></msub><annotation encoding="application/x-tex">J_{\beta z}</annotation></semantics></math>
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo>√ó</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">K \times 1</annotation></semantics></math>)</strong>:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>J</mi><mn>12</mn></msub><mo>=</mo><mo>‚àë</mo><msub><mi>a</mi><mi>i</mi></msub><msubsup><mi>Z</mi><mi>i</mi><mi>T</mi></msubsup><mrow><mo stretchy="true" form="prefix">[</mo><mfrac><mrow><mi>‚àÇ</mi><msub><mi>T</mi><mi>i</mi></msub></mrow><mrow><mi>‚àÇ</mi><mi>z</mi></mrow></mfrac><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">J_{12} = \sum a_i Z_i^T \left[ \frac{\partial T_i}{\partial z} \right]</annotation></semantics></math></p>
<p><strong><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>J</mi><mrow><mi>Œ≤</mi><mi>Œª</mi></mrow></msub><annotation encoding="application/x-tex">J_{\beta \lambda}</annotation></semantics></math>
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo>√ó</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">K \times L</annotation></semantics></math>)</strong>:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>J</mi><mn>13</mn></msub><mo>=</mo><mo>‚àë</mo><msub><mi>a</mi><mi>i</mi></msub><msubsup><mi>Z</mi><mi>i</mi><mi>T</mi></msubsup><mrow><mo stretchy="true" form="prefix">[</mo><mfrac><mrow><mi>‚àÇ</mi><msub><mi>T</mi><mi>i</mi></msub></mrow><mrow><mi>‚àÇ</mi><msub><mi>Œª</mi><mi>x</mi></msub></mrow></mfrac><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">J_{13} = \sum a_i Z_i^T \left[ \frac{\partial T_i}{\partial \lambda_x} \right]</annotation></semantics></math></p>
<p><strong><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>J</mi><mrow><mi>z</mi><mi>Œ≤</mi></mrow></msub><annotation encoding="application/x-tex">J_{z\beta}</annotation></semantics></math>
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>√ó</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">1 \times K</annotation></semantics></math>)</strong>:
derivative of W-equation w.r.t.
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Œ≤</mi><annotation encoding="application/x-tex">\beta</annotation></semantics></math></p>
<p>Equation:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mi>W</mi></msub><mo>=</mo><mo>‚àë</mo><msub><mi>a</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>w</mi><mi>i</mi></msub><mo>‚àí</mo><mi>W</mi><mo stretchy="true" form="postfix">)</mo></mrow><msub><mtext mathvariant="normal">inv</mtext><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">G_W = \sum a_i (w_i - W) \text{inv}_i</annotation></semantics></math></p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>‚àÇ</mi><msub><mi>G</mi><mi>W</mi></msub></mrow><mrow><mi>‚àÇ</mi><msub><mi>Œ∑</mi><mi>i</mi></msub></mrow></mfrac><mo>=</mo><msub><mi>a</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>Œº</mi><mrow><mi>Œ∑</mi><mo>,</mo><mi>i</mi></mrow></msub><msub><mtext mathvariant="normal">inv</mtext><mi>i</mi></msub><mo>‚àí</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>w</mi><mi>i</mi></msub><mo>‚àí</mo><mi>W</mi><mo stretchy="true" form="postfix">)</mo></mrow><msubsup><mtext mathvariant="normal">inv</mtext><mi>i</mi><mn>2</mn></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><mrow><mi>‚àÇ</mi><msub><mi>D</mi><mi>i</mi></msub></mrow><mrow><mi>‚àÇ</mi><msub><mi>Œ∑</mi><mi>i</mi></msub></mrow></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">]</mo></mrow><mo>=</mo><msub><mi>a</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>Œº</mi><mrow><mi>Œ∑</mi><mo>,</mo><mi>i</mi></mrow></msub><msub><mtext mathvariant="normal">inv</mtext><mi>i</mi></msub><mo>‚àí</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>w</mi><mi>i</mi></msub><mo>‚àí</mo><mi>W</mi><mo stretchy="true" form="postfix">)</mo></mrow><msubsup><mtext mathvariant="normal">inv</mtext><mi>i</mi><mn>2</mn></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Œª</mi><mi>W</mi></msub><msub><mi>Œº</mi><mrow><mi>Œ∑</mi><mo>,</mo><mi>i</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">\frac{\partial G_W}{\partial \eta_i} = a_i \left[ \mu_{\eta,i} \text{inv}_i - (w_i - W) \text{inv}_i^2 \left(\frac{\partial D_i}{\partial \eta_i}\right) \right] = a_i \left[ \mu_{\eta,i} \text{inv}_i - (w_i - W) \text{inv}_i^2 (\lambda_W \mu_{\eta,i}) \right]</annotation></semantics></math></p>
<p>Then:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>J</mi><mn>21</mn></msub><mo>=</mo><mo>‚àë</mo><mfrac><mrow><mi>‚àÇ</mi><msub><mi>G</mi><mi>W</mi></msub></mrow><mrow><mi>‚àÇ</mi><msub><mi>Œ∑</mi><mi>i</mi></msub></mrow></mfrac><mo>‚ãÖ</mo><msub><mi>Z</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">J_{21} = \sum \frac{\partial G_W}{\partial \eta_i} \cdot Z_i</annotation></semantics></math></p>
<p><strong><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>J</mi><mrow><mi>z</mi><mi>z</mi></mrow></msub><annotation encoding="application/x-tex">J_{zz}</annotation></semantics></math>
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>√ó</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1 \times 1</annotation></semantics></math>)</strong>:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>‚àÇ</mi><msub><mi>G</mi><mi>W</mi></msub></mrow><mrow><mi>‚àÇ</mi><mi>z</mi></mrow></mfrac><mo>=</mo><mo>‚àë</mo><msub><mi>a</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">[</mo><mo>‚àí</mo><mfrac><mrow><mi>d</mi><mi>W</mi></mrow><mrow><mi>d</mi><mi>z</mi></mrow></mfrac><mo>‚ãÖ</mo><msub><mtext mathvariant="normal">inv</mtext><mi>i</mi></msub><mo>‚àí</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>w</mi><mi>i</mi></msub><mo>‚àí</mo><mi>W</mi><mo stretchy="true" form="postfix">)</mo></mrow><msubsup><mtext mathvariant="normal">inv</mtext><mi>i</mi><mn>2</mn></msubsup><mo>‚ãÖ</mo><mfrac><mrow><mi>‚àÇ</mi><msub><mi>D</mi><mi>i</mi></msub></mrow><mrow><mi>‚àÇ</mi><mi>z</mi></mrow></mfrac><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">\frac{\partial G_W}{\partial z} = \sum a_i \left[ -\frac{dW}{dz} \cdot \text{inv}_i - (w_i - W) \text{inv}_i^2 \cdot \frac{\partial D_i}{\partial z} \right]</annotation></semantics></math></p>
<p><strong><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>J</mi><mrow><mi>z</mi><mi>Œª</mi></mrow></msub><annotation encoding="application/x-tex">J_{z\lambda}</annotation></semantics></math>
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>√ó</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">1 \times L</annotation></semantics></math>)</strong>:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>‚àÇ</mi><msub><mi>G</mi><mi>W</mi></msub></mrow><mrow><mi>‚àÇ</mi><msub><mi>Œª</mi><mi>x</mi></msub></mrow></mfrac><mo>=</mo><mo>‚àë</mo><msub><mi>a</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">[</mo><mo>‚àí</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>w</mi><mi>i</mi></msub><mo>‚àí</mo><mi>W</mi><mo stretchy="true" form="postfix">)</mo></mrow><msubsup><mtext mathvariant="normal">inv</mtext><mi>i</mi><mn>2</mn></msubsup><msub><mi>X</mi><mrow><mtext mathvariant="normal">centered</mtext><mo>,</mo><mi>i</mi></mrow></msub><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">\frac{\partial G_W}{\partial \lambda_x} = \sum a_i \left[ -(w_i - W) \text{inv}_i^2 X_{\text{centered},i} \right]</annotation></semantics></math></p>
<p><strong><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>J</mi><mrow><mi>Œª</mi><mi>Œ≤</mi></mrow></msub><annotation encoding="application/x-tex">J_{\lambda\beta}</annotation></semantics></math>
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>√ó</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">L \times K</annotation></semantics></math>)</strong>:
constraints
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>Œª</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>:</mo><mo>‚àë</mo><msub><mi>a</mi><mi>i</mi></msub><msub><mtext mathvariant="normal">inv</mtext><mi>i</mi></msub><msub><mi>X</mi><mrow><mtext mathvariant="normal">centered</mtext><mo>,</mo><mi>i</mi></mrow></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">H(\lambda): \sum a_i \text{inv}_i X_{\text{centered},i} = 0</annotation></semantics></math></p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>‚àÇ</mi><mi>H</mi></mrow><mrow><mi>‚àÇ</mi><msub><mi>Œ∑</mi><mi>i</mi></msub></mrow></mfrac><mo>=</mo><mo>‚àí</mo><msub><mi>a</mi><mi>i</mi></msub><msubsup><mtext mathvariant="normal">inv</mtext><mi>i</mi><mn>2</mn></msubsup><mfrac><mrow><mi>‚àÇ</mi><msub><mi>D</mi><mi>i</mi></msub></mrow><mrow><mi>‚àÇ</mi><msub><mi>Œ∑</mi><mi>i</mi></msub></mrow></mfrac><msub><mi>X</mi><mrow><mtext mathvariant="normal">centered</mtext><mo>,</mo><mi>i</mi></mrow></msub><mo>=</mo><mo>‚àí</mo><msub><mi>a</mi><mi>i</mi></msub><msubsup><mtext mathvariant="normal">inv</mtext><mi>i</mi><mn>2</mn></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Œª</mi><mi>W</mi></msub><msub><mi>Œº</mi><mrow><mi>Œ∑</mi><mo>,</mo><mi>i</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><msub><mi>X</mi><mrow><mtext mathvariant="normal">centered</mtext><mo>,</mo><mi>i</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\frac{\partial H}{\partial \eta_i} = -a_i \text{inv}_i^2 \frac{\partial D_i}{\partial \eta_i} X_{\text{centered},i} = -a_i \text{inv}_i^2 (\lambda_W \mu_{\eta,i}) X_{\text{centered},i}</annotation></semantics></math></p>
<p>Thus, component-wise
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>J</mi><mn>31</mn></msub><mo>=</mo><msub><mo>‚àë</mo><mi>i</mi></msub><msub><mi>a</mi><mi>i</mi></msub><mspace width="0.167em"></mspace><mrow><mo stretchy="true" form="prefix">(</mo><mo>‚àí</mo><msub><mi>Œª</mi><mi>W</mi></msub><msub><mi>Œº</mi><mrow><mi>Œ∑</mi><mo>,</mo><mi>i</mi></mrow></msub><mspace width="0.167em"></mspace><msubsup><mtext mathvariant="normal">inv</mtext><mi>i</mi><mn>2</mn></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mspace width="0.167em"></mspace><msubsup><mi>X</mi><mrow><mtext mathvariant="normal">centered</mtext><mo>,</mo><mi>i</mi></mrow><mi>T</mi></msubsup><msub><mi>Z</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">J_{31} = \sum_i a_i\,(-\lambda_W \mu_{\eta,i}\,\text{inv}_i^2)\, X_{\text{centered},i}^T Z_i</annotation></semantics></math>.
In compact matrix form:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>J</mi><mn>31</mn></msub><mo>=</mo><msubsup><mi>X</mi><mtext mathvariant="normal">centered</mtext><mi>T</mi></msubsup><mo>diag</mo><mspace width="-0.167em"></mspace><mo minsize="1.2" maxsize="1.2" stretchy="false" form="prefix">(</mo><mo>‚àí</mo><msub><mi>a</mi><mi>i</mi></msub><mspace width="0.167em"></mspace><msub><mi>Œª</mi><mi>W</mi></msub><mspace width="0.167em"></mspace><msub><mi>Œº</mi><mrow><mi>Œ∑</mi><mo>,</mo><mi>i</mi></mrow></msub><mspace width="0.167em"></mspace><msubsup><mtext mathvariant="normal">inv</mtext><mi>i</mi><mn>2</mn></msubsup><mo minsize="1.2" maxsize="1.2" stretchy="false" form="postfix">)</mo><mi>Z</mi><mi>.</mi></mrow><annotation encoding="application/x-tex">J_{31} = X_{\text{centered}}^T \operatorname{diag}\!\big(-a_i\,\lambda_W\,\mu_{\eta,i}\,\text{inv}_i^2\big) Z.</annotation></semantics></math></p>
<p><strong><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>J</mi><mrow><mi>Œª</mi><mi>z</mi></mrow></msub><annotation encoding="application/x-tex">J_{\lambda z}</annotation></semantics></math>
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>√ó</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">L \times 1</annotation></semantics></math>)</strong>:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>‚àÇ</mi><mi>H</mi></mrow><mrow><mi>‚àÇ</mi><mi>z</mi></mrow></mfrac><mo>=</mo><mo>‚àí</mo><mo>‚àë</mo><msub><mi>a</mi><mi>i</mi></msub><msubsup><mtext mathvariant="normal">inv</mtext><mi>i</mi><mn>2</mn></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><mrow><mi>‚àÇ</mi><msub><mi>D</mi><mi>i</mi></msub></mrow><mrow><mi>‚àÇ</mi><mi>z</mi></mrow></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><msub><mi>X</mi><mrow><mtext mathvariant="normal">centered</mtext><mo>,</mo><mi>i</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\frac{\partial H}{\partial z} = -\sum a_i \text{inv}_i^2 \left(\frac{\partial D_i}{\partial z}\right) X_{\text{centered},i}</annotation></semantics></math></p>
<p><strong><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>J</mi><mrow><mi>Œª</mi><mi>Œª</mi></mrow></msub><annotation encoding="application/x-tex">J_{\lambda\lambda}</annotation></semantics></math>
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>√ó</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">L \times L</annotation></semantics></math>)</strong>:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>‚àÇ</mi><mi>H</mi></mrow><mrow><mi>‚àÇ</mi><msub><mi>Œª</mi><mi>x</mi></msub></mrow></mfrac><mo>=</mo><mo>‚àí</mo><msubsup><mi>X</mi><mtext mathvariant="normal">centered</mtext><mi>T</mi></msubsup><mo>diag</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>a</mi><mi>i</mi></msub><mspace width="0.167em"></mspace><msubsup><mtext mathvariant="normal">inv</mtext><mi>i</mi><mn>2</mn></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><msub><mi>X</mi><mtext mathvariant="normal">centered</mtext></msub><mi>.</mi></mrow><annotation encoding="application/x-tex">\frac{\partial H}{\partial \lambda_x} = -X_{\text{centered}}^T \operatorname{diag}(a_i\,\text{inv}_i^2) X_{\text{centered}}.</annotation></semantics></math></p>
<p>These expressions match the unguarded analytic derivatives; in the
code (<code>src_dev/engines/el/impl/jacobian.R</code>), any terms
involving derivatives of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mi>/</mi><msub><mi>D</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">1/D_i</annotation></semantics></math>
are additionally multiplied by the active mask
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>ùüô</mn><mo stretchy="false" form="prefix">{</mo><msubsup><mi>D</mi><mi>i</mi><mtext mathvariant="normal">raw</mtext></msubsup><mo>&gt;</mo><mi>Œ¥</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\mathbb{1}\{D_i^{\text{raw}} &gt; \delta\}</annotation></semantics></math>
to respect the denominator floor used for numerical stability.</p>
</div>
<div class="section level3">
<h3 id="why-analytic-a-helps">Why Analytic A Helps<a class="anchor" aria-label="anchor" href="#why-analytic-a-helps"></a>
</h3>
<ul>
<li>Newton-Raphson (as used in our outer solve) linearizes
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>Œ∏</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">F(\theta)</annotation></semantics></math>
near the current iterate:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>Œ∏</mi><mo>+</mo><mi>Œî</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>‚âà</mo><mi>F</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>Œ∏</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mi>A</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>Œ∏</mi><mo stretchy="true" form="postfix">)</mo></mrow><mspace width="0.167em"></mspace><mi>Œî</mi></mrow><annotation encoding="application/x-tex">F(\theta + \Delta) \approx F(\theta) + A(\theta)\,\Delta</annotation></semantics></math>.
The update
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Œî</mi><annotation encoding="application/x-tex">\Delta</annotation></semantics></math>
solves
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mspace width="0.167em"></mspace><mi>Œî</mi><mo>=</mo><mo>‚àí</mo><mi>F</mi></mrow><annotation encoding="application/x-tex">A\,\Delta = -F</annotation></semantics></math>,
hence a high-quality
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
is critical for fast, stable convergence.</li>
</ul>
</div>
<div class="section level3">
<h3 id="solving-strategy-and-initialization">Solving Strategy and Initialization<a class="anchor" aria-label="anchor" href="#solving-strategy-and-initialization"></a>
</h3>
<ul>
<li>In the IID path the unknowns are
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Œ∏</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>Œ≤</mi><mo>,</mo><mi>z</mi><mo>,</mo><msub><mi>Œª</mi><mi>x</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\theta = (\beta, z, \lambda_x)</annotation></semantics></math>
with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mo>=</mo><mrow><mi mathvariant="normal">p</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">g</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">s</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">W = \mathrm{plogis}(z)</annotation></semantics></math>.
In the survey path the unknowns are
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mi>Œ≤</mi><mo>,</mo><mi>z</mi><mo>,</mo><msub><mi>Œª</mi><mi>W</mi></msub><mo>,</mo><msub><mi>Œª</mi><mi>x</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(\beta, z, \lambda_W, \lambda_x)</annotation></semantics></math>,
with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Œª</mi><mi>W</mi></msub><annotation encoding="application/x-tex">\lambda_W</annotation></semantics></math>
treated as a free parameter. In both cases we solve the full stacked
system
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>Œ∏</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">F(\theta) = 0</annotation></semantics></math>
via Newton with the analytic Jacobian
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>=</mo><mi>‚àÇ</mi><mi>F</mi><mi>/</mi><mi>‚àÇ</mi><mi>Œ∏</mi></mrow><annotation encoding="application/x-tex">A = \partial F/\partial\theta</annotation></semantics></math>
using <code>nleqslv</code>.</li>
<li>Globalization and scaling: we rely on <code>nleqslv</code>‚Äôs
globalization (default <code>global = "qline"</code>,
<code>xscalm = "auto"</code>) and enforce denominator positivity
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>min</mo><mi>i</mi></msub><msub><mi>D</mi><mi>i</mi></msub><mo>‚â•</mo><mi>Œµ</mi></mrow><annotation encoding="application/x-tex">\min_i D_i \ge \varepsilon</annotation></semantics></math>)
within equation evaluations. Optional standardization of design matrices
improves conditioning.</li>
<li>Initialization: by default
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Œ≤</mi><annotation encoding="application/x-tex">\beta</annotation></semantics></math>
starts at zeros in the scaled space (unless the user supplies
<code>start$beta</code>), and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>z</mi><annotation encoding="application/x-tex">z</annotation></semantics></math>
is seeded at
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">l</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">g</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">t</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mtext mathvariant="normal">observed response rate</mtext><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathrm{logit}(\text{observed response rate})</annotation></semantics></math>.
An internal last-chance Broyden retry may be used if Newton fails to
converge; this is not a user-facing mode.</li>
</ul>
</div>
<div class="section level3">
<h3 id="practical-identifiability-and-diagnostics">Practical Identifiability and Diagnostics<a class="anchor" aria-label="anchor" href="#practical-identifiability-and-diagnostics"></a>
</h3>
<p>The EL system balances the parametric response-model score against
calibration constraints. Identifiability can weaken in the following
situations:</p>
<ul>
<li>Weak or nearly collinear auxiliaries: if
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mi>i</mi></msub><mo>‚àí</mo><msub><mi>Œº</mi><mi>x</mi></msub></mrow><annotation encoding="application/x-tex">X_i-\mu_x</annotation></semantics></math>
have little variation or are nearly collinear with the response score
direction, the constraint block in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>=</mo><mi>‚àÇ</mi><mi>F</mi><mi>/</mi><mi>‚àÇ</mi><mi>Œ∏</mi></mrow><annotation encoding="application/x-tex">A=\partial F/\partial\theta</annotation></semantics></math>
becomes ill-conditioned.</li>
<li>Inconsistent auxiliary means: if supplied
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Œº</mi><mi>x</mi></msub><annotation encoding="application/x-tex">\mu_x</annotation></semantics></math>
are far from what the respondent sample can support (under the response
model), denominators
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>D</mi><mi>i</mi></msub><annotation encoding="application/x-tex">D_i</annotation></semantics></math>
cluster near 0 and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Œ∫</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>A</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\kappa(A)</annotation></semantics></math>
inflates.</li>
<li>Heavy nonresponse or near-boundary
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>W</mi><annotation encoding="application/x-tex">W</annotation></semantics></math>:
when
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>W</mi><annotation encoding="application/x-tex">W</annotation></semantics></math>
approaches 0 or 1,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Œª</mi><mi>W</mi></msub><mo>=</mo><mi>C</mi><mi>/</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>‚àí</mo><mi>W</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\lambda_W=C/(1-W)</annotation></semantics></math>
can spike and amplify sensitivity.</li>
</ul>
<p>Diagnostics exposed by the implementation help assess these
issues:</p>
<ul>
<li>
<code>jacobian_condition_number</code>
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Œ∫</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>A</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\kappa(A)</annotation></semantics></math>),
<code>max_equation_residual</code>, denominator summaries (min, lower
quantiles, median), weight concentration (max share, top-5 share, ESS),
and the trimming fraction.</li>
</ul>
<p>Mitigations include standardizing predictors, trimming extreme
weights (<code>trim_cap</code>), adding informative response-model
predictors, and preferring bootstrap variance when diagnostics indicate
fragility.</p>
</div>
</div>
<div class="section level2">
<h2 id="survey-design-details">Survey Design Details<a class="anchor" aria-label="anchor" href="#survey-design-details"></a>
</h2>
<p>We extend QLS‚Äôs methodology to complex surveys in two complementary
ways:</p>
<ul>
<li><p><strong>Estimating equations with base weights:</strong> All sums
include the base weight
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>a</mi><mi>i</mi></msub><annotation encoding="application/x-tex">a_i</annotation></semantics></math>;
set
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>a</mi><mi>i</mi></msub><annotation encoding="application/x-tex">a_i</annotation></semantics></math>
to the survey design weight for respondents. Totals
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>N</mi><mtext mathvariant="normal">pop</mtext></msub><annotation encoding="application/x-tex">N_{\text{pop}}</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mtext mathvariant="normal">resp_weighted</mtext></msub><mo>=</mo><mo>‚àë</mo><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">n_{\text{resp\_weighted}}=\sum a_i</annotation></semantics></math>
are computed from the design weights and used throughout the
design-weighted system.</p></li>
<li><p><strong>Nonrespondent total
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>T</mi><mn>0</mn></msub><annotation encoding="application/x-tex">T_0</annotation></semantics></math>
in the linkage equation:</strong> In the survey-specific system we form
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>0</mn></msub><mo>=</mo><msub><mi>N</mi><mtext mathvariant="normal">pop</mtext></msub><mo>‚àí</mo><msub><mi>n</mi><mtext mathvariant="normal">resp_weighted</mtext></msub></mrow><annotation encoding="application/x-tex">T_0 = N_{\text{pop}} - n_{\text{resp\_weighted}}</annotation></semantics></math>
and enforce the linkage between
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>W</mi><annotation encoding="application/x-tex">W</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Œª</mi><mi>W</mi></msub><annotation encoding="application/x-tex">\lambda_W</annotation></semantics></math>
through the equation
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>0</mn></msub><mi>/</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>‚àí</mo><mi>W</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>‚àí</mo><msub><mi>Œª</mi><mi>W</mi></msub><mo>‚àë</mo><msub><mi>d</mi><mi>i</mi></msub><mi>/</mi><msub><mi>D</mi><mi>i</mi></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">T_0/(1-W) - \lambda_W \sum d_i/D_i = 0</annotation></semantics></math>
rather than using the closed-form
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Œª</mi><mi>W</mi></msub><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>N</mi><mtext mathvariant="normal">pop</mtext></msub><mi>/</mi><msub><mi>n</mi><mtext mathvariant="normal">resp_weighted</mtext></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>‚àí</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mi>/</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>‚àí</mo><mi>W</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\lambda_W = ((N_{\text{pop}}/n_{\text{resp\_weighted}}) - 1)/(1-W)</annotation></semantics></math>.</p></li>
<li><p><strong>Bootstrap variance via replicate weights:</strong> For
standard errors, we use bootstrap replicate-weight designs created with
<code><a href="https://bschneidr.github.io/svrep/reference/as_bootstrap_design.html" class="external-link">svrep::as_bootstrap_design</a></code>. For each replicate, the
estimator is re-fit on a reconstructed design using that replicate‚Äôs
weights, and <code><a href="https://rdrr.io/pkg/survey/man/svrVar.html" class="external-link">survey::svrVar</a></code> is used to compute the variance
of replicate estimates with appropriate scaling.</p></li>
</ul>
<div class="section level3">
<h3 id="weight-scale-note">Weight scale note<a class="anchor" aria-label="anchor" href="#weight-scale-note"></a>
</h3>
<p>The survey system is defined on an analysis scale through
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>N</mi><mtext mathvariant="normal">pop</mtext></msub><annotation encoding="application/x-tex">N_{\text{pop}}</annotation></semantics></math>
and the design weights
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>d</mi><mi>i</mi></msub><annotation encoding="application/x-tex">d_i</annotation></semantics></math>.
By default we set
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mtext mathvariant="normal">pop</mtext></msub><mo>=</mo><msub><mo>‚àë</mo><mi>i</mi></msub><msub><mi>d</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">N_{\text{pop}}=\sum_i d_i</annotation></semantics></math>
using <code>weights(design)</code>. If the design weights have been
rescaled (for example, to sum to the sample size for numerical reasons),
you should supply <code>n_total</code> on the intended population-total
scale so that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>0</mn></msub><mo>=</mo><msub><mi>N</mi><mtext mathvariant="normal">pop</mtext></msub><mo>‚àí</mo><msub><mo>‚àë</mo><mrow><mi>i</mi><mo>‚àà</mo><mi>R</mi></mrow></msub><msub><mi>d</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">T_0 = N_{\text{pop}}-\sum_{i\in R} d_i</annotation></semantics></math>
is computed consistently with your analysis.</p>
<p>This matches the paper‚Äôs guidance to adapt the likelihood/estimating
framework to stratification or unequal-probability sampling while
relying on standard survey resampling for uncertainty. Analytic variance
has not been implemented yet.</p>
<p>Degrees-of-freedom: For confidence intervals, we use survey
degrees-of-freedom (t-quantiles) when a <code>survey.design</code> is
supplied; otherwise, we use normal quantiles.</p>
</div>
</div>
<div class="section level2">
<h2 id="scaling-and-unscaling">Scaling and Unscaling<a class="anchor" aria-label="anchor" href="#scaling-and-unscaling"></a>
</h2>
<div class="section level3">
<h3 id="scaling-optional-standardizetrue">Scaling (optional; <code>standardize=TRUE</code>)<a class="anchor" aria-label="anchor" href="#scaling-optional-standardizetrue"></a>
</h3>
<ul>
<li>
<strong>Compute a <code>nmar_scaling_recipe</code></strong>: for
each column
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>j</mi><annotation encoding="application/x-tex">j</annotation></semantics></math>
in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Z</mi><annotation encoding="application/x-tex">Z</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math>
(excluding intercept), using (if present) the same base weights
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>a</mi><mi>i</mi></msub><annotation encoding="application/x-tex">a_i</annotation></semantics></math>
that enter the estimating equations:
<ul>
<li>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mtext mathvariant="normal">mean</mtext><mi>j</mi></msub><annotation encoding="application/x-tex">\text{mean}_j</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mtext mathvariant="normal">sd</mtext><mi>j</mi></msub><annotation encoding="application/x-tex">\text{sd}_j</annotation></semantics></math>;
if
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext mathvariant="normal">sd</mtext><mi>j</mi></msub><mo>‚âà</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\text{sd}_j \approx 0</annotation></semantics></math>,
set
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext mathvariant="normal">sd</mtext><mi>j</mi></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\text{sd}_j = 1</annotation></semantics></math>
to avoid blow-ups.</li>
</ul>
</li>
<li>
<strong>Transform</strong>:
<ul>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Z</mi><mtext mathvariant="normal">scaled</mtext></msub><mrow><mo stretchy="true" form="prefix">[</mo><mo>,</mo><mi>j</mi><mo stretchy="true" form="postfix">]</mo></mrow><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Z</mi><mtext mathvariant="normal">un</mtext></msub><mrow><mo stretchy="true" form="prefix">[</mo><mo>,</mo><mi>j</mi><mo stretchy="true" form="postfix">]</mo></mrow><mo>‚àí</mo><msub><mtext mathvariant="normal">mean</mtext><mi>j</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>/</mi><msub><mtext mathvariant="normal">sd</mtext><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">Z_{\text{scaled}}[,j] = (Z_{\text{un}}[,j] - \text{mean}_j) / \text{sd}_j</annotation></semantics></math></li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mtext mathvariant="normal">scaled</mtext></msub><mrow><mo stretchy="true" form="prefix">[</mo><mo>,</mo><mi>j</mi><mo stretchy="true" form="postfix">]</mo></mrow><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>X</mi><mtext mathvariant="normal">un</mtext></msub><mrow><mo stretchy="true" form="prefix">[</mo><mo>,</mo><mi>j</mi><mo stretchy="true" form="postfix">]</mo></mrow><mo>‚àí</mo><msub><mtext mathvariant="normal">mean</mtext><mi>j</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>/</mi><msub><mtext mathvariant="normal">sd</mtext><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">X_{\text{scaled}}[,j] = (X_{\text{un}}[,j] - \text{mean}_j) / \text{sd}_j</annotation></semantics></math></li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Œº</mi><mrow><mi>x</mi><mo>,</mo><mtext mathvariant="normal">scaled</mtext></mrow></msub><mrow><mo stretchy="true" form="prefix">[</mo><mi>j</mi><mo stretchy="true" form="postfix">]</mo></mrow><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Œº</mi><mrow><mi>x</mi><mo>,</mo><mtext mathvariant="normal">un</mtext></mrow></msub><mrow><mo stretchy="true" form="prefix">[</mo><mi>j</mi><mo stretchy="true" form="postfix">]</mo></mrow><mo>‚àí</mo><msub><mtext mathvariant="normal">mean</mtext><mi>j</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>/</mi><msub><mtext mathvariant="normal">sd</mtext><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">\mu_{x,\text{scaled}}[j] = (\mu_{x,\text{un}}[j] - \text{mean}_j) / \text{sd}_j</annotation></semantics></math></li>
</ul>
</li>
</ul>
</div>
<div class="section level3">
<h3 id="unscaling-beta-and-vcov">Unscaling
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Œ≤</mi><annotation encoding="application/x-tex">\beta</annotation></semantics></math>
and vcov<a class="anchor" aria-label="anchor" href="#unscaling-beta-and-vcov"></a>
</h3>
<ul>
<li>
<strong>Construct linear map</strong>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>D</mi><annotation encoding="application/x-tex">D</annotation></semantics></math>
of size
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo>√ó</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">K \times K</annotation></semantics></math>:
<ul>
<li>For columns
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>‚â†</mo></mrow><annotation encoding="application/x-tex">j \neq</annotation></semantics></math>
intercept:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mrow><mo stretchy="true" form="prefix">[</mo><mi>j</mi><mo>,</mo><mi>j</mi><mo stretchy="true" form="postfix">]</mo></mrow><mo>=</mo><mn>1</mn><mi>/</mi><msub><mtext mathvariant="normal">sd</mtext><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">D[j,j] = 1/\text{sd}_j</annotation></semantics></math>
</li>
<li>For intercept: adjust to absorb centering:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mrow><mo stretchy="true" form="prefix">[</mo><mtext mathvariant="normal">intercept</mtext><mo>,</mo><mi>j</mi><mo stretchy="true" form="postfix">]</mo></mrow><mo>=</mo><mo>‚àí</mo><msub><mtext mathvariant="normal">mean</mtext><mi>j</mi></msub><mi>/</mi><msub><mtext mathvariant="normal">sd</mtext><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">D[\text{intercept},j] = -\text{mean}_j/\text{sd}_j</annotation></semantics></math>
</li>
</ul>
</li>
<li>
<strong>Transform</strong>:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Œ≤</mi><mtext mathvariant="normal">unscaled</mtext></msub><mo>=</mo><mi>D</mi><msub><mi>Œ≤</mi><mtext mathvariant="normal">scaled</mtext></msub></mrow><annotation encoding="application/x-tex">\beta_{\text{unscaled}} = D \beta_{\text{scaled}}</annotation></semantics></math>;
if a covariance matrix is available,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext mathvariant="normal">vcov</mtext><mtext mathvariant="normal">unscaled</mtext></msub><mo>=</mo><mi>D</mi><mspace width="0.167em"></mspace><msub><mtext mathvariant="normal">vcov</mtext><mtext mathvariant="normal">scaled</mtext></msub><mspace width="0.167em"></mspace><msup><mi>D</mi><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">\text{vcov}_{\text{unscaled}} = D \, \text{vcov}_{\text{scaled}} \, D^T</annotation></semantics></math>
</li>
</ul>
<p>Code: centralized in <code>src_dev/shared/scaling.R</code>; engines
call <code><a href="../reference/validate_and_apply_nmar_scaling.html">validate_and_apply_nmar_scaling()</a></code> and
<code><a href="../reference/unscale_coefficients.html">unscale_coefficients()</a></code>. For the EL engine, only
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Œ≤</mi><annotation encoding="application/x-tex">\beta</annotation></semantics></math>
is currently unscaled because no analytic coefficient covariance is
computed.</p>
</div>
</div>
<div class="section level2">
<h2 id="bootstrap-variance">Bootstrap Variance<a class="anchor" aria-label="anchor" href="#bootstrap-variance"></a>
</h2>
<ul>
<li>
<strong>IID</strong>:
<ul>
<li>Resample rows with replacement
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>),
re-run estimator, compute
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtext mathvariant="normal">var</mtext><annotation encoding="application/x-tex">\text{var}</annotation></semantics></math>
of bootstrap
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>Y</mi><mo accent="true">ÃÇ</mo></mover><annotation encoding="application/x-tex">\hat{Y}</annotation></semantics></math>s;
warn if many failures; return
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msqrt><mtext mathvariant="normal">var</mtext></msqrt><annotation encoding="application/x-tex">\sqrt{\text{var}}</annotation></semantics></math>.</li>
</ul>
</li>
<li>
<strong>Survey</strong>:
<ul>
<li>Convert to bootstrap replicate-weight design via
<code><a href="https://bschneidr.github.io/svrep/reference/as_bootstrap_design.html" class="external-link">svrep::as_bootstrap_design</a></code>.</li>
<li>For each replicate, re-construct a temporary design and run
estimator; use <code><a href="https://rdrr.io/pkg/survey/man/svrVar.html" class="external-link">survey::svrVar</a></code> to compute variance of
replicate estimates (with scale/rscales).</li>
</ul>
</li>
</ul>
<p>Code mapping:</p>
<ul>
<li>Engine:
<code>el_engine(..., family, standardize, trim_cap, variance_method, ...)</code>
in <code>src_dev/engines/el/engine.R</code>
</li>
<li>Dispatch: <code>run_engine.nmar_engine_el(...)</code> in
<code>src_dev/engines/el/run_engine.R</code> adapts the formula and
forwards arguments to internal <code><a href="../reference/el.html">el()</a></code> methods.
<ul>
<li>
<code><a href="../reference/el_dataframe.html">el.data.frame()</a></code> / <code><a href="../reference/el_survey.html">el.survey.design()</a></code> in
<code>src_dev/engines/el/impl/dataframe.R</code> and
<code>src_dev/engines/el/impl/survey.R</code> prepare inputs, call
<code><a href="../reference/el_estimator_core.html">el_estimator_core()</a></code>, and wrap results.</li>
</ul>
</li>
<li>EL Core: <code>el_estimator_core(...)</code> in
<code>src_dev/engines/el/impl/core.R</code> runs:
<ul>
<li>Construct
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>Œ∏</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">F(\theta)</annotation></semantics></math>
via <code><a href="../reference/el_build_equation_system.html">el_build_equation_system()</a></code>
(<code>src_dev/engines/el/impl/equations.R</code>).</li>
<li>Solve
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>Œ∏</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">F(\theta)=0</annotation></semantics></math>
via <code>nleqslv</code> (Newton with analytic Jacobian when available,
Broyden fallback).</li>
<li>Build EL weights, mean, and diagnostics.</li>
</ul>
</li>
<li>Jacobian: <code>el_build_jacobian(...)</code> in
<code>src_dev/engines/el/impl/jacobian.R</code> returns analytic A
whenever family supplies <code>d2mu.deta2</code> (logit, probit).</li>
<li>Variance: Bootstrap variance is implemented in
<code>src_dev/shared/bootstrap.R</code>.</li>
<li>S3 result: <code>src_dev/engines/el/s3.R</code> defines EL-specific
print and summary methods (<code>print.nmar_result_el</code>,
<code>summary.nmar_result_el</code>). Generic methods such as
<code>tidy()</code>, <code>glance()</code>, <code><a href="https://rdrr.io/r/stats/weights.html" class="external-link">weights()</a></code>, and
<code><a href="https://rdrr.io/r/stats/coef.html" class="external-link">coef()</a></code> are defined for the parent <code>nmar_result</code>
class in <code>src_dev/S3/nmar_result_methods.R</code>.</li>
</ul>
<div class="section level3">
<h3 id="practical-notes">Practical Notes<a class="anchor" aria-label="anchor" href="#practical-notes"></a>
</h3>
<ul>
<li>Denominator guard:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>i</mi></msub><mo>‚â•</mo><mi>Œµ</mi></mrow><annotation encoding="application/x-tex">D_i \ge \varepsilon</annotation></semantics></math>
(default
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>10</mn><mrow><mo>‚àí</mo><mn>8</mn></mrow></msup><annotation encoding="application/x-tex">10^{-8}</annotation></semantics></math>)
across all steps; diagnostics report extreme fractions.</li>
<li>Eta cap option: you can adjust the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Œ∑</mi><annotation encoding="application/x-tex">\eta</annotation></semantics></math>
cap via <code>options(nmar.eta_cap = 60)</code> (default is 50) to suit
your data scale and link</li>
</ul>
</div>
<div class="section level3">
<h3 id="algorithm">Algorithm<a class="anchor" aria-label="anchor" href="#algorithm"></a>
</h3>
<p>We solve the full stacked system
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>Œ∏</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">F(\theta)=0</annotation></semantics></math>
with Newton using the analytic Jacobian
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>=</mo><mi>‚àÇ</mi><mi>F</mi><mi>/</mi><mi>‚àÇ</mi><mi>Œ∏</mi></mrow><annotation encoding="application/x-tex">A = \partial F/\partial \theta</annotation></semantics></math>
and globalization via <code>nleqslv</code>. Denominator positivity
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>min</mo><mi>i</mi></msub><msub><mi>D</mi><mi>i</mi></msub><mo>‚â•</mo><mi>Œµ</mi></mrow><annotation encoding="application/x-tex">\min_i D_i \ge \varepsilon</annotation></semantics></math>),
predictor standardization, and capped
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Œ∑</mi><annotation encoding="application/x-tex">\eta</annotation></semantics></math>
ensure numerical stability. For the IID path the estimating equations
are Qin, Leung and Shao (2002) up to the small numeric guards on
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Œ∑</mi><annotation encoding="application/x-tex">\eta</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>w</mi><mi>i</mi></msub><annotation encoding="application/x-tex">w_i</annotation></semantics></math>,
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>D</mi><mi>i</mi></msub><annotation encoding="application/x-tex">D_i</annotation></semantics></math>;
for survey designs we use a consistent design-weighted analogue.</p>
<pre class="text"><code>Input: Z (response design), X (auxiliary design), mu_x (population means),
       a (base weights), family (logit/probit), trim_cap, tolerances.
Initialize: beta = 0 in scaled space (or user-supplied start),
            z = logit(observed response rate), lambda_x = 0
            (and lambda_W = 0 for survey designs).
Repeat until convergence of F(theta) = 0:
  1) Compute eta = Z beta, w = linkinv(eta), W = plogis(z).
     - IID (data.frame): set lambda_W = ((N_pop/n_resp_weighted) - 1)/(1 - W).
     - survey.design: use the current lambda_W component of theta.
  2) Evaluate full stacked equations using guarded denominators
     D_i = 1 + lambda_W (w_i - W) + (X_i - mu_x)^T lambda_x.
  3) Compute analytic Jacobian A = dF/dtheta (if available; else numeric/Broyden).
  4) Newton step: solve A * step = -F with globalization; enforce min D_i &gt;= eps.
  5) Update theta &lt;- theta + step.
Return: p_i \propto a_i / D_i and \hat{Y} = Sum p_i Y_i / Sum p_i.</code></pre>
</div>
</div>
<div class="section level2">
<h2 id="references">References<a class="anchor" aria-label="anchor" href="#references"></a>
</h2>
<ul>
<li>Qin, J., Leung, D., and Shao, J. (2002). Estimation with survey data
under nonignorable nonresponse or informative sampling. Journal of the
American Statistical Association, 97(457), 193-200.</li>
<li>Chen, J., and Sitter, R. R. (1999). A pseudo empirical likelihood
approach to the effective use of auxiliary information in complex
surveys. Statistica Sinica, 9, 385-406.</li>
<li>Wu, C. (2005). Algorithms and R codes for the pseudo empirical
likelihood method in survey sampling. Survey Methodology, 31(2),
239-243.</li>
</ul>
</div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by Maciej Beresewicz, Igor Ko≈Çodziej, Mateusz Iwaniuk.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.2.0.</p>
</div>

    </footer>
</div>





  </body>
</html>
