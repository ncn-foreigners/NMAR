<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Empirical Likelihood Theory • NMAR</title>
<!-- favicons --><link rel="icon" type="image/png" sizes="96x96" href="../favicon-96x96.png">
<link rel="icon" type="”image/svg+xml”" href="../favicon.svg">
<link rel="apple-touch-icon" sizes="180x180" href="../apple-touch-icon.png">
<link rel="icon" sizes="any" href="../favicon.ico">
<link rel="manifest" href="../site.webmanifest">
<script src="../lightswitch.js"></script><script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Empirical Likelihood Theory">
<meta name="description" content="Mathematical details behind the empirical likelihood estimator for NMAR data (Qin, Leung, and Shao 2002), and how the theory maps to our implementation.
">
<meta property="og:description" content="Mathematical details behind the empirical likelihood estimator for NMAR data (Qin, Leung, and Shao 2002), and how the theory maps to our implementation.
">
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top " aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">NMAR</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.0.0.1</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="active nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles">
<li><a class="dropdown-item" href="../articles/tutorial_empirical_likelihood.html">Empirical Likelihood</a></li>
    <li><a class="dropdown-item" href="../articles/tutorial_exptilt.html">Exponential Tilting</a></li>
    <li><a class="dropdown-item" href="../articles/tutorial_exptilt_nonparam.html">Exponential Tilting (Nonparametric)</a></li>
    <li><hr class="dropdown-divider"></li>
    <li><a class="dropdown-item" href="../articles/index.html">More articles...</a></li>
  </ul>
</li>
<li class="nav-item"><a class="nav-link" href="../news/index.html">Changelog</a></li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json">
</form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/ncn-foreigners/NMAR/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>Empirical Likelihood Theory</h1>
            
      
      <small class="dont-index">Source: <a href="https://github.com/ncn-foreigners/NMAR/blob/package-dev/vignettes/el_empirical_likelihood_theory.Rmd" class="external-link"><code>vignettes/el_empirical_likelihood_theory.Rmd</code></a></small>
      <div class="d-none name"><code>el_empirical_likelihood_theory.Rmd</code></div>
    </div>

    
    
<p>This document explains every mathematical object, equation, and
derivation behind the empirical likelihood (EL) estimator implemented in
the <code>nmar</code> package, and maps each concept to code. It covers
both data-frame (IID) and survey design use cases, handles arbitrary
numbers of response-model and auxiliary covariates, and supports both
logit and probit response families.</p>
<div class="section level2">
<h2 id="notation">Notation<a class="anchor" aria-label="anchor" href="#notation"></a>
</h2>
<div class="section level3">
<h3 id="units">Units<a class="anchor" aria-label="anchor" href="#units"></a>
</h3>
<ul>
<li>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">i = 1, \ldots, n</annotation></semantics></math>
index respondents (those with observed
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Y</mi><annotation encoding="application/x-tex">Y</annotation></semantics></math>)</li>
<li>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>i</mi></msub><mo>∈</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">R_i \in \{0, 1\}</annotation></semantics></math>
is the response indicator; we work on observed subset
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>i</mi></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">R_i = 1</annotation></semantics></math>
</li>
</ul>
</div>
<div class="section level3">
<h3 id="data">Data<a class="anchor" aria-label="anchor" href="#data"></a>
</h3>
<ul>
<li>
<strong>Outcome</strong>:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Y</mi><mi>i</mi></msub><annotation encoding="application/x-tex">Y_i</annotation></semantics></math>
(observed when
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>i</mi></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">R_i = 1</annotation></semantics></math>;
missing otherwise)</li>
<li>
<strong>Response covariates</strong>: row vector
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Z</mi><mi>i</mi></msub><mo>∈</mo><msup><mi>ℝ</mi><mi>K</mi></msup></mrow><annotation encoding="application/x-tex">Z_i \in \mathbb{R}^K</annotation></semantics></math>,
from <code>model.matrix</code> of the response RHS</li>
<li>
<strong>Auxiliary covariates</strong>: row vector
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mi>i</mi></msub><mo>∈</mo><msup><mi>ℝ</mi><mi>L</mi></msup></mrow><annotation encoding="application/x-tex">X_i \in \mathbb{R}^L</annotation></semantics></math>
(possibly
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">L = 0</annotation></semantics></math>),
from auxiliary RHS (no intercept)</li>
<li>
<strong>Population auxiliary means</strong>:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>μ</mi><mi>x</mi></msub><mo>∈</mo><msup><mi>ℝ</mi><mi>L</mi></msup></mrow><annotation encoding="application/x-tex">\mu_x \in \mathbb{R}^L</annotation></semantics></math>,
known; names match columns of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math>
</li>
</ul>
</div>
<div class="section level3">
<h3 id="response-model-family-functions">Response Model (Family functions)<a class="anchor" aria-label="anchor" href="#response-model-family-functions"></a>
</h3>
<ul>
<li>
<strong>Linear predictor</strong>:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>η</mi><mi>i</mi></msub><mo>=</mo><msub><mi>Z</mi><mi>i</mi></msub><mspace width="0.167em"></mspace><mi>β</mi></mrow><annotation encoding="application/x-tex">\eta_i = Z_i \, \beta</annotation></semantics></math>
</li>
<li>
<strong>Response probability</strong>:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mi>i</mi></msub><mo>≡</mo><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>η</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mrow><mi mathvariant="normal">l</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">k</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">v</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>η</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">w_i \equiv g(\eta_i) = \mathrm{linkinv}(\eta_i)</annotation></semantics></math>
</li>
<li>
<strong>First derivative</strong>:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac displaystyle="true"><mrow><mi>d</mi><mi>w</mi></mrow><mrow><mi>d</mi><mi>η</mi></mrow></mfrac><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>η</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msub><mi>μ</mi><mrow><mi>η</mi><mo>,</mo><mi>i</mi></mrow></msub><mo>=</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">a</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>η</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\dfrac{dw}{d\eta}(\eta_i) = \mu_{\eta,i} = \mathrm{mu.eta}(\eta_i)</annotation></semantics></math>
</li>
<li>
<strong>Second derivative</strong>:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac displaystyle="true"><mrow><msup><mi>d</mi><mn>2</mn></msup><mi>w</mi></mrow><mrow><mi>d</mi><msup><mi>η</mi><mn>2</mn></msup></mrow></mfrac><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>η</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mrow><mi mathvariant="normal">d</mi><mn mathvariant="normal">2</mn><mi mathvariant="normal">m</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">a</mi><mn mathvariant="normal">2</mn></mrow><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>η</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\dfrac{d^2 w}{d\eta^2}(\eta_i) = \mathrm{d2mu.deta2}(\eta_i)</annotation></semantics></math>
Here <code>linkinv</code>, <code>mu.eta</code>, and
<code>d2mu.deta2</code> refer to the chosen response family (logit or
probit). We follow the paper’s
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>w</mi><mi>i</mi></msub><annotation encoding="application/x-tex">w_i</annotation></semantics></math>
notation for the response probability and reserve
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>p</mi><mi>i</mi><mtext mathvariant="normal">EL</mtext></msubsup><annotation encoding="application/x-tex">p_i^{\text{EL}}</annotation></semantics></math>
for empirical-likelihood weights.</li>
</ul>
</div>
<div class="section level3">
<h3 id="weight-re-parameterization">Weight Re-parameterization<a class="anchor" aria-label="anchor" href="#weight-re-parameterization"></a>
</h3>
<ul>
<li>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mo>∈</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">W \in (0,1)</annotation></semantics></math>
nuisance scalar; we parameterize via
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi><mo>=</mo><mtext mathvariant="normal">logit</mtext><mrow><mo stretchy="true" form="prefix">(</mo><mi>W</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">z = \text{logit}(W)</annotation></semantics></math>
for stability and set
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mo>=</mo><mtext mathvariant="normal">plogis</mtext><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">W = \text{plogis}(z)</annotation></semantics></math>
</li>
<li>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>λ</mi><mi>W</mi></msub><mo>∈</mo><mi>ℝ</mi></mrow><annotation encoding="application/x-tex">\lambda_W \in \mathbb{R}</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>λ</mi><mi>x</mi></msub><mo>∈</mo><msup><mi>ℝ</mi><mi>L</mi></msup></mrow><annotation encoding="application/x-tex">\lambda_x \in \mathbb{R}^L</annotation></semantics></math>
are EL Lagrange multipliers for constraints; collected together in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>θ</mi><annotation encoding="application/x-tex">\theta</annotation></semantics></math>
</li>
</ul>
</div>
<div class="section level3">
<h3 id="el-weights">EL Weights<a class="anchor" aria-label="anchor" href="#el-weights"></a>
</h3>
<ul>
<li>
<strong>Denominator</strong>:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>i</mi></msub><mo>=</mo><mn>1</mn><mo>+</mo><msub><mi>λ</mi><mi>W</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>w</mi><mi>i</mi></msub><mo>−</mo><mi>W</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>X</mi><mi>i</mi></msub><mo>−</mo><msub><mi>μ</mi><mi>x</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>T</mi></msup><msub><mi>λ</mi><mi>x</mi></msub></mrow><annotation encoding="application/x-tex">D_i = 1 + \lambda_W (w_i - W) + (X_i - \mu_x)^T \lambda_x</annotation></semantics></math>
</li>
<li>
<strong>Base sampling weights</strong>:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">a_i = 1</annotation></semantics></math>
(IID) or
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo>=</mo></mrow><annotation encoding="application/x-tex">a_i =</annotation></semantics></math>
survey base weight for respondent
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>
</li>
<li>
<strong>EL weights for respondents</strong>:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>p</mi><mi>i</mi><mtext mathvariant="normal">EL</mtext></msubsup><mo>∝</mo><msub><mi>a</mi><mi>i</mi></msub><mi>/</mi><msub><mi>D</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">p_i^{\text{EL}} \propto a_i / D_i</annotation></semantics></math>
(proportionality normalized by totals below)</li>
</ul>
</div>
<div class="section level3">
<h3 id="estimator">Estimator<a class="anchor" aria-label="anchor" href="#estimator"></a>
</h3>
<ul>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>Y</mi><mo accent="true">̂</mo></mover><mo>=</mo><mo>∑</mo><msubsup><mi>p</mi><mi>i</mi><mtext mathvariant="normal">EL</mtext></msubsup><msub><mi>Y</mi><mi>i</mi></msub><mi>/</mi><mo>∑</mo><msubsup><mi>p</mi><mi>i</mi><mtext mathvariant="normal">EL</mtext></msubsup></mrow><annotation encoding="application/x-tex">\hat{Y} = \sum p_i^{\text{EL}} Y_i / \sum p_i^{\text{EL}}</annotation></semantics></math></li>
</ul>
</div>
<div class="section level3">
<h3 id="notation-at-a-glance">Notation at a Glance<a class="anchor" aria-label="anchor" href="#notation-at-a-glance"></a>
</h3>
<table class="table">
<colgroup>
<col width="50%">
<col width="50%">
</colgroup>
<thead><tr class="header">
<th>Symbol</th>
<th>Meaning</th>
</tr></thead>
<tbody>
<tr class="odd">
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math></td>
<td>Respondent index (rows with observed
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Y</mi><annotation encoding="application/x-tex">Y</annotation></semantics></math>)</td>
</tr>
<tr class="even">
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Y</mi><mi>i</mi></msub><annotation encoding="application/x-tex">Y_i</annotation></semantics></math></td>
<td>Outcome for unit
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>
(observed if
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>i</mi></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">R_i=1</annotation></semantics></math>)</td>
</tr>
<tr class="odd">
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Z</mi><mi>i</mi></msub><annotation encoding="application/x-tex">Z_i</annotation></semantics></math></td>
<td>Row of response design matrix (includes intercept)</td>
</tr>
<tr class="even">
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>X</mi><mi>i</mi></msub><annotation encoding="application/x-tex">X_i</annotation></semantics></math></td>
<td>Row of auxiliary design (no intercept)</td>
</tr>
<tr class="odd">
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>μ</mi><mi>x</mi></msub><annotation encoding="application/x-tex">\mu_x</annotation></semantics></math></td>
<td>Known population means of auxiliaries (vector)</td>
</tr>
<tr class="even">
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>β</mi><annotation encoding="application/x-tex">\beta</annotation></semantics></math></td>
<td>Response-model coefficients</td>
</tr>
<tr class="odd">
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>η</mi><mi>i</mi></msub><mo>=</mo><msub><mi>Z</mi><mi>i</mi></msub><mi>β</mi></mrow><annotation encoding="application/x-tex">\eta_i=Z_i\beta</annotation></semantics></math></td>
<td>Linear predictor for response model</td>
</tr>
<tr class="even">
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>w</mi><mi>i</mi></msub><annotation encoding="application/x-tex">w_i</annotation></semantics></math></td>
<td>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">l</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">k</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">v</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>η</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathrm{linkinv}(\eta_i)</annotation></semantics></math>
(logit:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">p</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">g</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">s</mi></mrow><annotation encoding="application/x-tex">\mathrm{plogis}</annotation></semantics></math>;
probit:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Φ</mi><annotation encoding="application/x-tex">\Phi</annotation></semantics></math>)</td>
</tr>
<tr class="odd">
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>μ</mi><mrow><mi>η</mi><mo>,</mo><mi>i</mi></mrow></msub><annotation encoding="application/x-tex">\mu_{\eta,i}</annotation></semantics></math></td>
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac displaystyle="true"><mrow><mi>d</mi><msub><mi>w</mi><mi>i</mi></msub></mrow><mrow><mi>d</mi><msub><mi>η</mi><mi>i</mi></msub></mrow></mfrac><annotation encoding="application/x-tex">\dfrac{dw_i}{d\eta_i}</annotation></semantics></math></td>
</tr>
<tr class="even">
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>λ</mi><mi>W</mi></msub><annotation encoding="application/x-tex">\lambda_W</annotation></semantics></math></td>
<td>Multiplier for the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>W</mi><annotation encoding="application/x-tex">W</annotation></semantics></math>-constraint
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∑</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>w</mi><mi>i</mi></msub><mo>−</mo><mi>W</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>/</mi><msub><mi>D</mi><mi>i</mi></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\sum (w_i-W)/D_i=0</annotation></semantics></math>
</td>
</tr>
<tr class="odd">
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>λ</mi><mi>x</mi></msub><annotation encoding="application/x-tex">\lambda_x</annotation></semantics></math></td>
<td>Multipliers for auxiliary constraints
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∑</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>X</mi><mi>i</mi></msub><mo>−</mo><msub><mi>μ</mi><mi>x</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>/</mi><msub><mi>D</mi><mi>i</mi></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\sum (X_i-\mu_x)/D_i=0</annotation></semantics></math>
</td>
</tr>
<tr class="even">
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>D</mi><mi>i</mi></msub><annotation encoding="application/x-tex">D_i</annotation></semantics></math></td>
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>+</mo><msub><mi>λ</mi><mi>W</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>w</mi><mi>i</mi></msub><mo>−</mo><mi>W</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>X</mi><mi>i</mi></msub><mo>−</mo><msub><mi>μ</mi><mi>x</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>T</mi></msup><msub><mi>λ</mi><mi>x</mi></msub></mrow><annotation encoding="application/x-tex">1+\lambda_W(w_i-W)+(X_i-\mu_x)^T\lambda_x</annotation></semantics></math></td>
</tr>
<tr class="odd">
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>a</mi><mi>i</mi></msub><annotation encoding="application/x-tex">a_i</annotation></semantics></math></td>
<td>Base weight (IID: 1; survey: design weight)</td>
</tr>
<tr class="even">
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>p</mi><mi>i</mi><mrow><mi mathvariant="normal">E</mi><mi mathvariant="normal">L</mi></mrow></msubsup><annotation encoding="application/x-tex">p_i^{\mathrm{EL}}</annotation></semantics></math></td>
<td>Empirical-likelihood weight
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∝</mo><msub><mi>a</mi><mi>i</mi></msub><mi>/</mi><msub><mi>D</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\propto a_i/D_i</annotation></semantics></math>
</td>
</tr>
<tr class="odd">
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>Y</mi><mo accent="true">̂</mo></mover><annotation encoding="application/x-tex">\hat Y</annotation></semantics></math></td>
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∑</mo><msubsup><mi>p</mi><mi>i</mi><mrow><mi mathvariant="normal">E</mi><mi mathvariant="normal">L</mi></mrow></msubsup><msub><mi>Y</mi><mi>i</mi></msub><mi>/</mi><mo>∑</mo><msubsup><mi>p</mi><mi>i</mi><mrow><mi mathvariant="normal">E</mi><mi mathvariant="normal">L</mi></mrow></msubsup></mrow><annotation encoding="application/x-tex">\sum p_i^{\mathrm{EL}} Y_i/\sum p_i^{\mathrm{EL}}</annotation></semantics></math></td>
</tr>
<tr class="even">
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>θ</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">F(\theta)</annotation></semantics></math></td>
<td>Estimating system (beta, W, and auxiliary equations)</td>
</tr>
<tr class="odd">
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math></td>
<td>Jacobian
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>∂</mi><mi>F</mi><mi>/</mi><mi>∂</mi><mi>θ</mi></mrow><annotation encoding="application/x-tex">\partial F/\partial \theta</annotation></semantics></math>
</td>
</tr>
<tr class="even">
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math></td>
<td>Covariance of total score vector</td>
</tr>
<tr class="odd">
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>θ</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">g(\theta)</annotation></semantics></math></td>
<td>Functional mapping parameters to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>Y</mi><mo accent="true">̂</mo></mover><annotation encoding="application/x-tex">\hat Y</annotation></semantics></math>
</td>
</tr>
<tr class="even">
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">V</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">r</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mover><mi>Y</mi><mo accent="true">̂</mo></mover><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathrm{Var}(\hat Y)</annotation></semantics></math></td>
<td>Delta:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>∇</mi><mi>g</mi><mspace width="0.167em"></mspace><msup><mi>A</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mi>B</mi><msup><mi>A</mi><mrow><mo>−</mo><mi>T</mi></mrow></msup><mspace width="0.167em"></mspace><mi>∇</mi><msup><mi>g</mi><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">\nabla g\,A^{-1}BA^{-T}\,\nabla g^T</annotation></semantics></math>
</td>
</tr>
</tbody>
</table>
</div>
<div class="section level3">
<h3 id="engines">Engines<a class="anchor" aria-label="anchor" href="#engines"></a>
</h3>
<ul>
<li>Family: “logit” (default) or “probit”; both use the log-likelihood
score w.r.t.
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>η</mi><annotation encoding="application/x-tex">\eta</annotation></semantics></math>:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub><mo>=</mo><mi>∂</mi><mo>log</mo><msub><mi>w</mi><mi>i</mi></msub><mi>/</mi><mi>∂</mi><msub><mi>η</mi><mi>i</mi></msub><mo>=</mo><msub><mi>μ</mi><mrow><mi>η</mi><mo>,</mo><mi>i</mi></mrow></msub><mi>/</mi><msub><mi>w</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">s_i = \partial\log w_i/\partial\eta_i = \mu_{\eta,i}/w_i</annotation></semantics></math>
(for respondents,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>δ</mi><mi>i</mi></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\delta_i=1</annotation></semantics></math>)</li>
<li>Scaling: optional standardization of design matrices and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>μ</mi><mi>x</mi></msub><annotation encoding="application/x-tex">\mu_x</annotation></semantics></math>
via nmar_scaling_recipe</li>
</ul>
</div>
</div>
<div class="section level2">
<h2 id="from-paper-to-implementation-core-ideas">From Paper to Implementation: Core Ideas<a class="anchor" aria-label="anchor" href="#from-paper-to-implementation-core-ideas"></a>
</h2>
<p>The paper (Qin-Leung-Shao, JASA 2002) sets EL under nonignorable
response using:</p>
<ul>
<li>
<strong>Empirical likelihood weights</strong> for respondents that
satisfy:
<ul>
<li>Zero-sum residual:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∑</mo><msubsup><mi>p</mi><mi>i</mi><mtext mathvariant="normal">EL</mtext></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>w</mi><mi>i</mi></msub><mo>−</mo><mi>W</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\sum p_i^{\text{EL}} (w_i - W) = 0</annotation></semantics></math>
</li>
<li>Auxiliary moments:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∑</mo><msubsup><mi>p</mi><mi>i</mi><mtext mathvariant="normal">EL</mtext></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>X</mi><mi>i</mi></msub><mo>−</mo><msub><mi>μ</mi><mi>x</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\sum p_i^{\text{EL}} (X_i - \mu_x) = 0</annotation></semantics></math>
</li>
</ul>
</li>
<li>A <strong>response model probability</strong>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mi>i</mi></msub><mo>=</mo><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>η</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">w_i = g(\eta_i)</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>η</mi><mi>i</mi></msub><mo>=</mo><msub><mi>Z</mi><mi>i</mi></msub><mspace width="0.167em"></mspace><mi>β</mi></mrow><annotation encoding="application/x-tex">\eta_i = Z_i \, \beta</annotation></semantics></math>
</li>
</ul>
<p>In our code, we adopt the same EL structure and estimating equations.
We extend it to arbitrary
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Z</mi><annotation encoding="application/x-tex">Z</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math>,
and to survey designs via design-based covariance for variance
estimation. Because
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>Y</mi><mo accent="true">̂</mo></mover><annotation encoding="application/x-tex">\hat Y</annotation></semantics></math>
is a ratio-of-weights estimator, any common normalization of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>p</mi><mi>i</mi><mtext mathvariant="normal">EL</mtext></msubsup><mo>∝</mo><msub><mi>a</mi><mi>i</mi></msub><mi>/</mi><msub><mi>D</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">p_i^{\text{EL}} \propto a_i/D_i</annotation></semantics></math>
cancels in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>Y</mi><mo accent="true">̂</mo></mover><annotation encoding="application/x-tex">\hat Y</annotation></semantics></math>;
only relative weights matter (the KKT multipliers
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>
enforce the constraints; normalization affects only a common scale that
vanishes in the ratio).</p>
<div class="section level3">
<h3 id="equation-crosswalk-qls-2002---this-vignettecode">Equation Crosswalk (QLS 2002 -&gt; This Vignette/Code)<a class="anchor" aria-label="anchor" href="#equation-crosswalk-qls-2002---this-vignettecode"></a>
</h3>
<ul>
<li>QLS (5): Discrete mass form for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>p</mi><mi>i</mi></msub><annotation encoding="application/x-tex">p_i</annotation></semantics></math>
with two multipliers -&gt; Our
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>i</mi></msub><mo>=</mo><mn>1</mn><mo>+</mo><msub><mi>λ</mi><mi>W</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>w</mi><mi>i</mi></msub><mo>−</mo><mi>W</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>X</mi><mi>i</mi></msub><mo>−</mo><msub><mi>μ</mi><mi>x</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>T</mi></msup><msub><mi>λ</mi><mi>x</mi></msub></mrow><annotation encoding="application/x-tex">D_i = 1 + \lambda_W (w_i - W) + (X_i - \mu_x)^T \lambda_x</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>p</mi><mi>i</mi><mtext mathvariant="normal">EL</mtext></msubsup><mo>∝</mo><msub><mi>a</mi><mi>i</mi></msub><mi>/</mi><msub><mi>D</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">p_i^{\text{EL}} \propto a_i/D_i</annotation></semantics></math>.</li>
<li>QLS (7):
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∑</mo><mfrac displaystyle="true"><mrow><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><mover><mi>x</mi><mo accent="true">‾</mo></mover></mrow><mrow><mn>1</mn><mo>+</mo><mi>⋯</mi></mrow></mfrac><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\sum \dfrac{x_i - \bar x}{1 + \cdots} = 0</annotation></semantics></math>
-&gt; Our auxiliary constraints
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∑</mo><msub><mi>a</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>X</mi><mi>i</mi></msub><mo>−</mo><msub><mi>μ</mi><mi>x</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>/</mi><msub><mi>D</mi><mi>i</mi></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\sum a_i (X_i - \mu_x)/D_i = 0</annotation></semantics></math>.</li>
<li>QLS (8):
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∑</mo><mfrac displaystyle="true"><mrow><msub><mi>w</mi><mi>i</mi></msub><mo>−</mo><mi>W</mi></mrow><mrow><mn>1</mn><mo>+</mo><mi>⋯</mi></mrow></mfrac><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\sum \dfrac{w_i - W}{1 + \cdots} = 0</annotation></semantics></math>
-&gt; Our
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>W</mi><annotation encoding="application/x-tex">W</annotation></semantics></math>-equation
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∑</mo><msub><mi>a</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>w</mi><mi>i</mi></msub><mo>−</mo><mi>W</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>/</mi><msub><mi>D</mi><mi>i</mi></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\sum a_i (w_i - W)/D_i = 0</annotation></semantics></math>.</li>
<li>QLS (10):
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>λ</mi><mo accent="true">̂</mo></mover><mn>2</mn></msub><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>N</mi><mi>/</mi><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mi>/</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><mi>W</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\hat{\lambda}_2 = (N/n - 1)/(1 - W)</annotation></semantics></math>
-&gt; Our
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>λ</mi><mi>W</mi></msub><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>N</mi><mtext mathvariant="normal">pop</mtext></msub><mi>/</mi><msub><mi>n</mi><mtext mathvariant="normal">resp_weighted</mtext></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mi>/</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><mi>W</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\lambda_W = ((N_{\text{pop}}/n_{\text{resp\_weighted}}) - 1)/(1 - W)</annotation></semantics></math>
(design-weighted generalization).</li>
<li>Estimator
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>Y</mi><mo accent="true">̂</mo></mover><annotation encoding="application/x-tex">\hat Y</annotation></semantics></math>
in QLS -&gt; Our ratio
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>Y</mi><mo accent="true">̂</mo></mover><mo>=</mo><mo>∑</mo><msubsup><mi>p</mi><mi>i</mi><mrow><mi mathvariant="normal">E</mi><mi mathvariant="normal">L</mi></mrow></msubsup><msub><mi>Y</mi><mi>i</mi></msub><mi>/</mi><mo>∑</mo><msubsup><mi>p</mi><mi>i</mi><mrow><mi mathvariant="normal">E</mi><mi mathvariant="normal">L</mi></mrow></msubsup></mrow><annotation encoding="application/x-tex">\hat Y = \sum p_i^{\mathrm{EL}} Y_i/\sum p_i^{\mathrm{EL}}</annotation></semantics></math>
using
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>p</mi><mi>i</mi><mrow><mi mathvariant="normal">E</mi><mi mathvariant="normal">L</mi></mrow></msubsup><mo>∝</mo><msub><mi>a</mi><mi>i</mi></msub><mi>/</mi><msub><mi>D</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">p_i^{\mathrm{EL}} \propto a_i/D_i</annotation></semantics></math>.</li>
</ul>
</div>
<div class="section level3">
<h3 id="likelihood-and-profiling-sketch">Likelihood and Profiling (sketch)<a class="anchor" aria-label="anchor" href="#likelihood-and-profiling-sketch"></a>
</h3>
<p>The paper’s semiparametric likelihood (their Eq. (2)) combines the
response mechanism
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mi>i</mi></msub><mo>=</mo><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>η</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">w_i = g(\eta_i)</annotation></semantics></math>
with the nonparametric distribution
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>
of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mi>Y</mi><mo>,</mo><mi>X</mi><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(Y,X)</annotation></semantics></math>:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ℒ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>β</mi><mo>,</mo><mi>W</mi><mo>,</mo><mi>F</mi><mo stretchy="true" form="postfix">)</mo></mrow><mspace width="0.278em"></mspace><mo>∝</mo><mspace width="0.278em"></mspace><munderover><mo>∏</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mi>w</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Y</mi><mi>i</mi></msub><mo>,</mo><msub><mi>X</mi><mi>i</mi></msub><mo>;</mo><mi>β</mi><mo stretchy="true" form="postfix">)</mo></mrow><mspace width="0.167em"></mspace><mi>d</mi><mi>F</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Y</mi><mi>i</mi></msub><mo>,</mo><msub><mi>X</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mspace width="0.278em"></mspace><mo>×</mo><mspace width="0.278em"></mspace><msup><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><mi>W</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mi>N</mi><mo>−</mo><mi>n</mi></mrow></msup><mo>,</mo></mrow><annotation encoding="application/x-tex">
\mathcal{L}(\beta, W, F) 
\;\propto\; \prod_{i=1}^{n} w(Y_i, X_i; \beta) \, dF(Y_i, X_i) 
\;\times\; (1 - W)^{N - n},
</annotation></semantics></math></p>
<p>subject to (i)
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∫</mo><mi>d</mi><mi>F</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\int dF = 1</annotation></semantics></math>,
(ii)
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∫</mo><mi>X</mi><mspace width="0.167em"></mspace><mi>d</mi><mi>F</mi><mo>=</mo><msub><mi>μ</mi><mi>x</mi></msub></mrow><annotation encoding="application/x-tex">\int X \, dF = \mu_x</annotation></semantics></math>,
and (iii)
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∫</mo><mi>w</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>Y</mi><mo>,</mo><mi>X</mi><mo>;</mo><mi>β</mi><mo stretchy="true" form="postfix">)</mo></mrow><mspace width="0.167em"></mspace><mi>d</mi><mi>F</mi><mo>=</mo><mi>W</mi></mrow><annotation encoding="application/x-tex">\int w(Y,X;\beta) \, dF = W</annotation></semantics></math>.
Discretizing
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>
at observed respondents by assigning unknown masses
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>p</mi><mi>i</mi></msub><annotation encoding="application/x-tex">p_i</annotation></semantics></math>
and introducing multipliers
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>,
the KKT conditions yield the familiar EL weight form with
denominator</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>i</mi></msub><mspace width="0.278em"></mspace><mo>=</mo><mspace width="0.278em"></mspace><mn>1</mn><mo>+</mo><msub><mi>λ</mi><mi>W</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>w</mi><mi>i</mi></msub><mo>−</mo><mi>W</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>X</mi><mi>i</mi></msub><mo>−</mo><msub><mi>μ</mi><mi>x</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>⊤</mi></msup><msub><mi>λ</mi><mi>x</mi></msub><mo>,</mo></mrow><annotation encoding="application/x-tex">
D_i \;=\; 1 + \lambda_W (w_i - W) + (X_i - \mu_x)^\top \lambda_x,
</annotation></semantics></math></p>
<p>and, with base weights
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>a</mi><mi>i</mi></msub><annotation encoding="application/x-tex">a_i</annotation></semantics></math>,
the working weights are
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>p</mi><mi>i</mi><mtext mathvariant="normal">EL</mtext></msubsup><mo>∝</mo><msub><mi>a</mi><mi>i</mi></msub><mi>/</mi><msub><mi>D</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">p_i^{\text{EL}} \propto a_i / D_i</annotation></semantics></math>.</p>
<p>Remark on conditioning: QLS’s Eq. (2) writes the first product as
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>∏</mo><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">[</mo><mspace width="0.167em"></mspace><mi>w</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>y</mi><mi>i</mi></msub><mo>,</mo><msub><mi>x</mi><mi>i</mi></msub><mo>;</mo><mi>β</mi><mo stretchy="true" form="postfix">)</mo></mrow><mspace width="0.167em"></mspace><mi>d</mi><mi>F</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>y</mi><mi>i</mi></msub><mo>,</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>/</mi><mi>W</mi><mspace width="0.167em"></mspace><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">\prod_i [\, w(y_i,x_i;\beta)\,dF(y_i,x_i)/W\,]</annotation></semantics></math>
so that it explicitly represents the likelihood of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Y</mi><mi>i</mi></msub><mo>,</mo><msub><mi>X</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(Y_i,X_i)</annotation></semantics></math>
conditional on
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>i</mi></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">R_i=1</annotation></semantics></math>.
Multiplying by the binomial term
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>W</mi><mi>n</mi></msup><msup><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><mi>W</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mi>N</mi><mo>−</mo><mi>n</mi></mrow></msup></mrow><annotation encoding="application/x-tex">W^n(1-W)^{N-n}</annotation></semantics></math>
yields the same overall likelihood as above because the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>W</mi><mrow><mo>−</mo><mi>n</mi></mrow></msup><annotation encoding="application/x-tex">W^{-n}</annotation></semantics></math>
in the first factor cancels the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>W</mi><mi>n</mi></msup><annotation encoding="application/x-tex">W^n</annotation></semantics></math>
in the second. Both factorizations lead to the same estimating equations
and the same profiled log-likelihood form used subsequently in QLS after
introducing the multipliers.</p>
</div>
<div class="section level3">
<h3 id="kkt-and-denominator-details">KKT and Denominator (details)<a class="anchor" aria-label="anchor" href="#kkt-and-denominator-details"></a>
</h3>
<p>Introducing Lagrange multipliers
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>λ</mi><mn>0</mn></msub><mo>,</mo><msub><mi>λ</mi><mi>x</mi></msub><mo>,</mo><msub><mi>λ</mi><mi>W</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(\lambda_0,\lambda_x,\lambda_W)</annotation></semantics></math>
for these constraints and profiling the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>p</mi><mi>i</mi></msub><annotation encoding="application/x-tex">p_i</annotation></semantics></math>’s
gives the KKT stationarity conditions</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>∂</mi><mrow><mi>∂</mi><msub><mi>p</mi><mi>i</mi></msub></mrow></mfrac><mo minsize="1.8" maxsize="1.8" stretchy="false" form="prefix">[</mo><munder><mo>∑</mo><mi>j</mi></munder><mo>log</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>a</mi><mi>j</mi></msub><msub><mi>p</mi><mi>j</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><msub><mi>λ</mi><mn>0</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><munder><mo>∑</mo><mi>j</mi></munder><msub><mi>p</mi><mi>j</mi></msub><mo>−</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><msubsup><mi>λ</mi><mi>x</mi><mi>T</mi></msubsup><munder><mo>∑</mo><mi>j</mi></munder><msub><mi>p</mi><mi>j</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>X</mi><mi>j</mi></msub><mo>−</mo><msub><mi>μ</mi><mi>x</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><msub><mi>λ</mi><mi>W</mi></msub><munder><mo>∑</mo><mi>j</mi></munder><msub><mi>p</mi><mi>j</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>w</mi><mi>j</mi></msub><mo>−</mo><mi>W</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo minsize="1.8" maxsize="1.8" stretchy="false" form="postfix">]</mo><mo>=</mo><mn>0</mn><mo>,</mo></mrow><annotation encoding="application/x-tex">
\frac{\partial}{\partial p_i} \Big[ \sum_j \log(a_j p_j) - \lambda_0 (\sum_j p_j - 1) - \lambda_x^T \sum_j p_j (X_j - \mu_x) - \lambda_W \sum_j p_j (w_j - W) \Big] = 0,
</annotation></semantics></math></p>
<p>which solve to</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mi>i</mi></msub><mspace width="0.278em"></mspace><mo>∝</mo><mspace width="0.278em"></mspace><mfrac><mn>1</mn><mrow><mspace width="0.167em"></mspace><mn>1</mn><mo>+</mo><msubsup><mi>λ</mi><mi>x</mi><mi>T</mi></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>X</mi><mi>i</mi></msub><mo>−</mo><msub><mi>μ</mi><mi>x</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><msub><mi>λ</mi><mi>W</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>w</mi><mi>i</mi></msub><mo>−</mo><mi>W</mi><mo stretchy="true" form="postfix">)</mo></mrow><mspace width="0.167em"></mspace></mrow></mfrac><mspace width="0.278em"></mspace><mo>≡</mo><mspace width="0.278em"></mspace><mfrac><mn>1</mn><msub><mi>D</mi><mi>i</mi></msub></mfrac><mi>.</mi></mrow><annotation encoding="application/x-tex">
p_i \;\propto\; \frac{1}{\,1 + \lambda_x^T (X_i-\mu_x) + \lambda_W (w_i - W)\,} \;\equiv\; \frac{1}{D_i}.
</annotation></semantics></math></p>
<p>Normalizing to enforce
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∑</mo><msub><mi>p</mi><mi>i</mi></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\sum p_i = 1</annotation></semantics></math>
yields
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mi>i</mi></msub><mo>=</mo><mfrac><msubsup><mi>D</mi><mi>i</mi><mrow><mo>−</mo><mn>1</mn></mrow></msubsup><mrow><msub><mo>∑</mo><mi>j</mi></msub><msubsup><mi>D</mi><mi>j</mi><mrow><mo>−</mo><mn>1</mn></mrow></msubsup></mrow></mfrac></mrow><annotation encoding="application/x-tex">p_i = \frac{D_i^{-1}}{\sum_j D_j^{-1}}</annotation></semantics></math>.
In the presence of base sampling weights
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>a</mi><mi>i</mi></msub><annotation encoding="application/x-tex">a_i</annotation></semantics></math>
(survey designs), the same derivation gives the natural
generalization</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>p</mi><mi>i</mi><mtext mathvariant="normal">EL</mtext></msubsup><mspace width="0.278em"></mspace><mo>∝</mo><mspace width="0.278em"></mspace><mfrac><msub><mi>a</mi><mi>i</mi></msub><msub><mi>D</mi><mi>i</mi></msub></mfrac><mspace width="1.0em"></mspace><mtext mathvariant="normal">with</mtext><mspace width="1.0em"></mspace><msub><mi>D</mi><mi>i</mi></msub><mo>=</mo><mn>1</mn><mo>+</mo><msub><mi>λ</mi><mi>W</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>w</mi><mi>i</mi></msub><mo>−</mo><mi>W</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>X</mi><mi>i</mi></msub><mo>−</mo><msub><mi>μ</mi><mi>x</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>T</mi></msup><msub><mi>λ</mi><mi>x</mi></msub><mi>.</mi></mrow><annotation encoding="application/x-tex">
p_i^{\text{EL}} \;\propto\; \frac{a_i}{D_i} \quad \text{with} \quad D_i = 1 + \lambda_W (w_i - W) + (X_i - \mu_x)^T\lambda_x.
</annotation></semantics></math></p>
<p>This is exactly the working form used in our estimator. The EL
weights
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>p</mi><mi>i</mi><mtext mathvariant="normal">EL</mtext></msubsup><annotation encoding="application/x-tex">p_i^{\text{EL}}</annotation></semantics></math>
are then used to build the mean estimator</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>Y</mi><mo accent="true">̂</mo></mover><mspace width="0.278em"></mspace><mo>=</mo><mspace width="0.278em"></mspace><mfrac><mrow><munder><mo>∑</mo><mi>i</mi></munder><msubsup><mi>p</mi><mi>i</mi><mtext mathvariant="normal">EL</mtext></msubsup><msub><mi>Y</mi><mi>i</mi></msub></mrow><mrow><munder><mo>∑</mo><mi>i</mi></munder><msubsup><mi>p</mi><mi>i</mi><mtext mathvariant="normal">EL</mtext></msubsup></mrow></mfrac><mi>.</mi></mrow><annotation encoding="application/x-tex">
\hat Y \;=\; \frac{\sum_i p_i^{\text{EL}} Y_i}{\sum_i p_i^{\text{EL}}}.
</annotation></semantics></math></p>
<p>The remaining unknowns
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mi>β</mi><mo>,</mo><mi>W</mi><mo>,</mo><msub><mi>λ</mi><mi>x</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(\beta, W, \lambda_x)</annotation></semantics></math>
are determined by the estimating equations below.</p>
</div>
<div class="section level3">
<h3 id="clarification-relationship-between-w-and-lambda_w">Clarification: Relationship Between
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>W</mi><annotation encoding="application/x-tex">W</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>λ</mi><mi>W</mi></msub><annotation encoding="application/x-tex">\lambda_W</annotation></semantics></math><a class="anchor" aria-label="anchor" href="#clarification-relationship-between-w-and-lambda_w"></a>
</h3>
<p>In our reparameterization, the EL multiplier for the probability
constraint is expressed as:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>λ</mi><mi>W</mi></msub><mo>=</mo><mfrac><mi>C</mi><mrow><mn>1</mn><mo>−</mo><mi>W</mi></mrow></mfrac><mo>,</mo><mspace width="1.0em"></mspace><mrow><mtext mathvariant="normal">with </mtext><mspace width="0.333em"></mspace></mrow><mi>C</mi><mo>=</mo><mfrac><msub><mi>N</mi><mtext mathvariant="normal">pop</mtext></msub><msub><mi>n</mi><mtext mathvariant="normal">resp_weighted</mtext></msub></mfrac><mo>−</mo><mn>1</mn><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> and </mtext><mspace width="0.333em"></mspace></mrow><mi>W</mi><mo>=</mo><mtext mathvariant="normal">plogis</mtext><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\lambda_W = \frac{C}{1 - W}, \quad \text{with } C = \frac{N_{\text{pop}}}{n_{\text{resp\_weighted}}} - 1 \text{ and } W = \text{plogis}(z)</annotation></semantics></math></p>
<p>Intuition: In the EL KKT system, the constraint
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∑</mo><msubsup><mi>p</mi><mi>i</mi><mtext mathvariant="normal">EL</mtext></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>w</mi><mi>i</mi></msub><mo>−</mo><mi>W</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\sum p_i^{\text{EL}} (w_i - W) = 0</annotation></semantics></math>
sits alongside normalization and (optionally) auxiliary constraints.
Incorporating base weights
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>a</mi><mi>i</mi></msub><annotation encoding="application/x-tex">a_i</annotation></semantics></math>
and the ratio between population and respondent totals induces a scaling
of the multiplier linked to the mass constraint. Writing
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>λ</mi><mi>W</mi></msub><annotation encoding="application/x-tex">\lambda_W</annotation></semantics></math>
in this scaled form keeps the parameter on a numerically stable scale
and lets the derivative structure (w.r.t.
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>z</mi><annotation encoding="application/x-tex">z</annotation></semantics></math>
via
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>W</mi><annotation encoding="application/x-tex">W</annotation></semantics></math>)
be handled cleanly. This is consistent with the EL structure when the
baseline mass is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>n</mi><mtext mathvariant="normal">resp_weighted</mtext></msub><annotation encoding="application/x-tex">n_{\text{resp\_weighted}}</annotation></semantics></math>
and the “full population” target is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>N</mi><mtext mathvariant="normal">pop</mtext></msub><annotation encoding="application/x-tex">N_{\text{pop}}</annotation></semantics></math>,
and it is exactly what the code uses to match the normalization implied
by base weights.</p>
<p>Derivation sketch (KKT): The discretized semiparametric likelihood
(QLS, 2002) maximizes, over the unknown masses
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><msub><mi>p</mi><mi>i</mi></msub><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\{p_i\}</annotation></semantics></math>
at observed points and over
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mi>β</mi><mo>,</mo><mi>W</mi><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(\beta, W)</annotation></semantics></math>,</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>ℓ</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>β</mi><mo>,</mo><mi>W</mi><mo>,</mo><msub><mi>λ</mi><mi>x</mi></msub><mo>,</mo><msub><mi>λ</mi><mi>W</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mspace width="0.278em"></mspace><mo>=</mo><mspace width="0.278em"></mspace><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mo>log</mo><msub><mi>w</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>β</mi><mo stretchy="true" form="postfix">)</mo></mrow><mspace width="0.278em"></mspace><mo>+</mo><mspace width="0.278em"></mspace><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>N</mi><mtext mathvariant="normal">pop</mtext></msub><mo>−</mo><msub><mi>n</mi><mtext mathvariant="normal">resp_weighted</mtext></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>log</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><mi>W</mi><mo stretchy="true" form="postfix">)</mo></mrow><mspace width="0.278em"></mspace><mo>−</mo><mspace width="0.278em"></mspace><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mo>log</mo><mspace width="-0.167em"></mspace><mo minsize="1.8" maxsize="1.8" stretchy="false" form="prefix">(</mo><mn>1</mn><mo>+</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>X</mi><mi>i</mi></msub><mo>−</mo><msub><mi>μ</mi><mi>x</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>⊤</mi></msup><msub><mi>λ</mi><mi>x</mi></msub><mo>+</mo><msub><mi>λ</mi><mi>W</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>w</mi><mi>i</mi></msub><mo>−</mo><mi>W</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo minsize="1.8" maxsize="1.8" stretchy="false" form="postfix">)</mo><mo>,</mo></mrow><annotation encoding="application/x-tex">
\ell(\beta, W, \lambda_x, \lambda_W) 
\;=\; \sum_{i=1}^{n} \log w_i(\beta)
\; +\; (N_{\text{pop}} - n_{\text{resp\_weighted}}) \log(1 - W)
\; -\; \sum_{i=1}^{n} \log\!\Big(1 + (X_i - \mu_x)^\top \lambda_x + \lambda_W (w_i - W)\Big),
</annotation></semantics></math></p>
<p>subject to the normalization and moment constraints that generate the
EL denominator. For the weighted-EL variant we work with unnormalized
respondent weights proportional to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mi>/</mi><msub><mi>D</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i/D_i</annotation></semantics></math>;
choosing the conventional normalization</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mfrac><msub><mi>a</mi><mi>i</mi></msub><msub><mi>D</mi><mi>i</mi></msub></mfrac><mspace width="0.167em"></mspace><mo>=</mo><mspace width="0.167em"></mspace><msub><mi>n</mi><mtext mathvariant="normal">resp_weighted</mtext></msub><mo>≡</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">
\sum_{i=1}^{n} \frac{a_i}{D_i} \,=\, n_{\text{resp\_weighted}} \equiv \sum_{i=1}^{n} a_i
</annotation></semantics></math></p>
<p>recovers the same estimating system (and any common normalization
cancels in the ratio estimator
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>Y</mi><mo accent="true">̂</mo></mover><mo>=</mo><mo>∑</mo><msub><mi>p</mi><mi>i</mi></msub><msub><mi>Y</mi><mi>i</mi></msub><mi>/</mi><mo>∑</mo><msub><mi>p</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\hat Y = \sum p_i Y_i/\sum p_i</annotation></semantics></math>).
Taking derivatives (KKT conditions) and using that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>∂</mi><mi>/</mi><mi>∂</mi><mi>W</mi></mrow><annotation encoding="application/x-tex">\partial/\partial W</annotation></semantics></math>
of the second and third terms produces opposing contributions, one
obtains the system equivalent to QLS (7)-(10). In particular, the
first-order condition w.r.t. the multiplier associated with the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>W</mi><annotation encoding="application/x-tex">W</annotation></semantics></math>-constraint
yields, together with the derivative w.r.t.
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>W</mi><annotation encoding="application/x-tex">W</annotation></semantics></math>,
the closed form</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>λ</mi><mi>W</mi></msub><mspace width="0.278em"></mspace><mo>=</mo><mspace width="0.278em"></mspace><mfrac><mrow><mfrac displaystyle="false"><msub><mi>N</mi><mtext mathvariant="normal">pop</mtext></msub><msub><mi>n</mi><mtext mathvariant="normal">resp_weighted</mtext></msub></mfrac><mo>−</mo><mn>1</mn></mrow><mrow><mn>1</mn><mo>−</mo><mi>W</mi></mrow></mfrac><mspace width="0.278em"></mspace><mo>=</mo><mspace width="0.278em"></mspace><mfrac><mi>C</mi><mrow><mn>1</mn><mo>−</mo><mi>W</mi></mrow></mfrac><mo>,</mo></mrow><annotation encoding="application/x-tex">
\lambda_W 
\;=\; \frac{\tfrac{N_{\text{pop}}}{n_{\text{resp\_weighted}}} - 1}{1 - W}
\;=\; \frac{C}{1 - W},
</annotation></semantics></math></p>
<p>which generalizes QLS (10) to the design-weighted case
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mtext mathvariant="normal">resp_weighted</mtext></msub><mo>=</mo><msub><mo>∑</mo><mi>i</mi></msub><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">n_{\text{resp\_weighted}} = \sum_i a_i</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mtext mathvariant="normal">pop</mtext></msub><mo>=</mo><msub><mo>∑</mo><mtext mathvariant="normal">all</mtext></msub><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">N_{\text{pop}} = \sum_{\text{all}} a_i</annotation></semantics></math>).
A quick derivation sketch mirrors QLS (7)-(10): the W-FOC yields
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>∑</mo><mi>i</mi></msub><msub><mi>a</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>w</mi><mi>i</mi></msub><mo>−</mo><mi>W</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>/</mi><msub><mi>D</mi><mi>i</mi></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\sum_i a_i (w_i - W) / D_i = 0</annotation></semantics></math>;
combining with the implicit normalization
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>∑</mo><mi>i</mi></msub><msub><mi>a</mi><mi>i</mi></msub><mi>/</mi><msub><mi>D</mi><mi>i</mi></msub><mo>=</mo><msub><mi>n</mi><mtext mathvariant="normal">resp_weighted</mtext></msub></mrow><annotation encoding="application/x-tex">\sum_i a_i / D_i = n_{\text{resp\_weighted}}</annotation></semantics></math>
and the binomial part for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>W</mi><annotation encoding="application/x-tex">W</annotation></semantics></math>
gives
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>λ</mi><mi>W</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><mi>W</mi><mo stretchy="true" form="postfix">)</mo></mrow><mspace width="0.167em"></mspace><msub><mi>n</mi><mtext mathvariant="normal">resp_weighted</mtext></msub><mo>=</mo><msub><mi>N</mi><mtext mathvariant="normal">pop</mtext></msub><mo>−</mo><msub><mi>n</mi><mtext mathvariant="normal">resp_weighted</mtext></msub></mrow><annotation encoding="application/x-tex">\lambda_W (1-W)\, n_{\text{resp\_weighted}} = N_{\text{pop}} - n_{\text{resp\_weighted}}</annotation></semantics></math>,
hence
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>λ</mi><mi>W</mi></msub><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>N</mi><mtext mathvariant="normal">pop</mtext></msub><mi>/</mi><msub><mi>n</mi><mtext mathvariant="normal">resp_weighted</mtext></msub><mo>−</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mi>/</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><mi>W</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\lambda_W = (N_{\text{pop}}/n_{\text{resp\_weighted}} - 1)/(1-W)</annotation></semantics></math>.
This is the expression implemented in the estimator and used throughout
the Jacobian and variance calculations.</p>
</div>
</div>
<div class="section level2">
<h2 id="estimating-equations">Estimating Equations<a class="anchor" aria-label="anchor" href="#estimating-equations"></a>
</h2>
<p><strong>Unknown parameters</strong>:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi><mo>∈</mo><msup><mi>ℝ</mi><mi>K</mi></msup></mrow><annotation encoding="application/x-tex">\beta \in \mathbb{R}^K</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi><mo>∈</mo><mi>ℝ</mi></mrow><annotation encoding="application/x-tex">z \in \mathbb{R}</annotation></semantics></math>
(for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mo>=</mo><mtext mathvariant="normal">plogis</mtext><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">W = \text{plogis}(z)</annotation></semantics></math>),
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>λ</mi><mi>x</mi></msub><mo>∈</mo><msup><mi>ℝ</mi><mi>L</mi></msup></mrow><annotation encoding="application/x-tex">\lambda_x \in \mathbb{R}^L</annotation></semantics></math>;
define
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>β</mi><mo>,</mo><mi>z</mi><mo>,</mo><msub><mi>λ</mi><mi>x</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\theta = (\beta, z, \lambda_x)</annotation></semantics></math>.</p>
<p>Define
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mi>i</mi></msub><mo>=</mo><mrow><mi mathvariant="normal">l</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">k</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">v</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>η</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">w_i = \mathrm{linkinv}(\eta_i)</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>μ</mi><mrow><mi>η</mi><mo>,</mo><mi>i</mi></mrow></msub><mo>=</mo><mfrac><mrow><mi>d</mi><mi>w</mi></mrow><mrow><mi>d</mi><mi>η</mi></mrow></mfrac><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>η</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mu_{\eta,i} = \frac{dw}{d\eta}(\eta_i)</annotation></semantics></math>
(denoted <code>mu.eta(eta_i)</code> in code).</p>
<p>Define
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mo>=</mo><mfrac><msub><mi>N</mi><mtext mathvariant="normal">pop</mtext></msub><msub><mi>n</mi><mtext mathvariant="normal">resp_weighted</mtext></msub></mfrac><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">C = \frac{N_{\text{pop}}}{n_{\text{resp\_weighted}}} - 1</annotation></semantics></math>,
with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mtext mathvariant="normal">resp_weighted</mtext></msub><mo>=</mo><mo>∑</mo><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">n_{\text{resp\_weighted}} = \sum a_i</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>N</mi><mtext mathvariant="normal">pop</mtext></msub><annotation encoding="application/x-tex">N_{\text{pop}}</annotation></semantics></math>
known (sum of design weights for survey;
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
for IID). Then
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>λ</mi><mi>W</mi></msub><mo>=</mo><mfrac><mi>C</mi><mrow><mn>1</mn><mo>−</mo><mi>W</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\lambda_W = \frac{C}{1 - W}</annotation></semantics></math>.</p>
<p><strong>Denominator</strong>:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>i</mi></msub><mo>=</mo><mn>1</mn><mo>+</mo><msub><mi>λ</mi><mi>W</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>w</mi><mi>i</mi></msub><mo>−</mo><mi>W</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>X</mi><mi>i</mi></msub><mo>−</mo><msub><mi>μ</mi><mi>x</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>T</mi></msup><msub><mi>λ</mi><mi>x</mi></msub></mrow><annotation encoding="application/x-tex">D_i = 1 + \lambda_W (w_i - W) + (X_i - \mu_x)^T \lambda_x</annotation></semantics></math>,
with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>i</mi></msub><mo>≥</mo><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">D_i \geq \epsilon</annotation></semantics></math>
enforced numerically.</p>
<p>Define the score term
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub><mo>=</mo><msub><mi>μ</mi><mrow><mi>η</mi><mo>,</mo><mi>i</mi></mrow></msub><mi>/</mi><msub><mi>w</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">s_i = \mu_{\eta,i}/w_i</annotation></semantics></math>
(the unit-level contribution to the log-likelihood score with respect to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>η</mi><annotation encoding="application/x-tex">\eta</annotation></semantics></math>).
For logit,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub><mo>=</mo><mn>1</mn><mo>−</mo><msub><mi>w</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">s_i = 1 - w_i</annotation></semantics></math>;
for probit,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub><mo>=</mo><mi>ϕ</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>η</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>/</mi><mi>Φ</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>η</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">s_i = \phi(\eta_i)/\Phi(\eta_i)</annotation></semantics></math>
(computed stably in code).</p>
<p>Intuition (why this score appears): for each respondent we observe
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>i</mi></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">R_i=1</annotation></semantics></math>,
so the Bernoulli log-likelihood contribution of the response model is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>log</mo><msub><mi>w</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>η</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\log w_i(\eta_i)</annotation></semantics></math>.
Differentiating w.r.t. the linear predictor gives
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>∂</mi><mrow><mi>∂</mi><msub><mi>η</mi><mi>i</mi></msub></mrow></mfrac><mo>log</mo><msub><mi>w</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>η</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mspace width="0.167em"></mspace><mo>=</mo><mspace width="0.167em"></mspace><mfrac><mn>1</mn><msub><mi>w</mi><mi>i</mi></msub></mfrac><mspace width="0.167em"></mspace><mfrac><mrow><mi>d</mi><msub><mi>w</mi><mi>i</mi></msub></mrow><mrow><mi>d</mi><msub><mi>η</mi><mi>i</mi></msub></mrow></mfrac><mspace width="0.167em"></mspace><mo>=</mo><mspace width="0.167em"></mspace><mfrac><msub><mi>μ</mi><mrow><mi>η</mi><mo>,</mo><mi>i</mi></mrow></msub><msub><mi>w</mi><mi>i</mi></msub></mfrac><mspace width="0.278em"></mspace><mo>≡</mo><mspace width="0.278em"></mspace><msub><mi>s</mi><mi>i</mi></msub><mi>.</mi></mrow><annotation encoding="application/x-tex">
\frac{\partial}{\partial\eta_i} \log w_i(\eta_i) \,=\, \frac{1}{w_i}\, \frac{dw_i}{d\eta_i} \,=\, \frac{\mu_{\eta,i}}{w_i} \;\equiv\; s_i.
</annotation></semantics></math></p>
<p>Thus
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>s</mi><mi>i</mi></msub><annotation encoding="application/x-tex">s_i</annotation></semantics></math>
measures the local sensitivity of the observed-response likelihood to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>η</mi><mi>i</mi></msub><annotation encoding="application/x-tex">\eta_i</annotation></semantics></math>.
In the logit family,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>μ</mi><mrow><mi>η</mi><mo>,</mo><mi>i</mi></mrow></msub><mo>=</mo><msub><mi>w</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><msub><mi>w</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mu_{\eta,i}=w_i(1-w_i)</annotation></semantics></math>
so
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub><mo>=</mo><mn>1</mn><mo>−</mo><msub><mi>w</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">s_i=1-w_i</annotation></semantics></math>-the
familiar residual-like term; in the probit family,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub><mo>=</mo><mi>ϕ</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>η</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>/</mi><mi>Φ</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>η</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">s_i=\phi(\eta_i)/\Phi(\eta_i)</annotation></semantics></math>,
the (inverse) Mills ratio. The EL
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>β</mi><annotation encoding="application/x-tex">\beta</annotation></semantics></math>-equations
balance this likelihood score against the EL penalty term
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>λ</mi><mi>W</mi></msub><mspace width="0.167em"></mspace><msub><mi>μ</mi><mrow><mi>η</mi><mo>,</mo><mi>i</mi></mrow></msub><mi>/</mi><msub><mi>D</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\lambda_W\,\mu_{\eta,i}/D_i</annotation></semantics></math>,
enforcing the calibration constraints while fitting the response
model.</p>
<div class="section level3">
<h3 id="the-system-of-estimating-equations-ftheta-0">The System of Estimating Equations
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>θ</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">F(\theta) = 0</annotation></semantics></math><a class="anchor" aria-label="anchor" href="#the-system-of-estimating-equations-ftheta-0"></a>
</h3>
<p><strong><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>β</mi><annotation encoding="application/x-tex">\beta</annotation></semantics></math>-equations</strong>
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>K</mi><annotation encoding="application/x-tex">K</annotation></semantics></math>
equations):
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∑</mo><msub><mi>a</mi><mi>i</mi></msub><msub><mi>Z</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>s</mi><mi>i</mi></msub><mo>−</mo><msub><mi>λ</mi><mi>W</mi></msub><msub><mi>μ</mi><mrow><mi>η</mi><mo>,</mo><mi>i</mi></mrow></msub><mi>/</mi><msub><mi>D</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">]</mo></mrow><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\sum a_i Z_i [s_i - \lambda_W \mu_{\eta,i} / D_i] = 0</annotation></semantics></math></p>
<p><strong>W-equation</strong> (1 equation):
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∑</mo><msub><mi>a</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>w</mi><mi>i</mi></msub><mo>−</mo><mi>W</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>/</mi><msub><mi>D</mi><mi>i</mi></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\sum a_i (w_i - W) / D_i = 0</annotation></semantics></math></p>
<p><strong>Auxiliary constraints</strong>
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>
equations):
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∑</mo><msub><mi>a</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>X</mi><mi>i</mi></msub><mo>−</mo><msub><mi>μ</mi><mi>x</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>/</mi><msub><mi>D</mi><mi>i</mi></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\sum a_i (X_i - \mu_x) / D_i = 0</annotation></semantics></math></p>
<p>These are exactly how <code>build_equation_system</code> constructs
the function in code
(<code>src_dev/engines/el/impl/equations.R</code>).</p>
<p>Intuition: the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>β</mi><annotation encoding="application/x-tex">\beta</annotation></semantics></math>-equations
equate the score of the respondent log-likelihood with the EL penalty
term
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>λ</mi><mi>W</mi></msub><msub><mi>μ</mi><mrow><mi>η</mi><mo>,</mo><mi>i</mi></mrow></msub><mi>/</mi><msub><mi>D</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\lambda_W \mu_{\eta,i}/D_i</annotation></semantics></math>;
the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>W</mi><annotation encoding="application/x-tex">W</annotation></semantics></math>-equation
centers the modeled response probabilities around the unconditional mean
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>W</mi><annotation encoding="application/x-tex">W</annotation></semantics></math>
under the EL weights; the auxiliary equations calibrate the centered
auxiliaries to zero mean under the EL weights.</p>
</div>
<div class="section level3">
<h3 id="remarks">Remarks<a class="anchor" aria-label="anchor" href="#remarks"></a>
</h3>
<ul>
<li>For logit and probit,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>s</mi><mi>i</mi></msub><annotation encoding="application/x-tex">s_i</annotation></semantics></math>
is the log-likelihood score
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>∂</mi><mo>log</mo><msub><mi>w</mi><mi>i</mi></msub><mi>/</mi><mi>∂</mi><msub><mi>η</mi><mi>i</mi></msub><mo>=</mo><msub><mi>μ</mi><mrow><mi>η</mi><mo>,</mo><mi>i</mi></mrow></msub><mi>/</mi><msub><mi>w</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\partial\log w_i/\partial\eta_i = \mu_{\eta,i}/w_i</annotation></semantics></math>
(equals
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>−</mo><msub><mi>w</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">1-w_i</annotation></semantics></math>
for logit;
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϕ</mi><mi>/</mi><mi>Φ</mi></mrow><annotation encoding="application/x-tex">\phi/\Phi</annotation></semantics></math>
for probit). This follows the paper’s MLE derivation; EL constraints
supply the nonparametric part.</li>
</ul>
</div>
</div>
<div class="section level2">
<h2 id="analytical-jacobian-a-matrix">Analytical Jacobian
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
Matrix)<a class="anchor" aria-label="anchor" href="#analytical-jacobian-a-matrix"></a>
</h2>
<p>We differentiate
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>θ</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">F(\theta) = 0</annotation></semantics></math>
with respect to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>β</mi><mo>,</mo><mi>z</mi><mo>,</mo><msub><mi>λ</mi><mi>x</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\theta = (\beta, z, \lambda_x)</annotation></semantics></math>.
Let:</p>
<ul>
<li>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>η</mi><mi>i</mi></msub><mo>=</mo><msub><mi>Z</mi><mi>i</mi></msub><mi>β</mi></mrow><annotation encoding="application/x-tex">\eta_i = Z_i \beta</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mi>i</mi></msub><mo>=</mo><mtext mathvariant="normal">linkinv</mtext><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>η</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">w_i = \text{linkinv}(\eta_i)</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>μ</mi><mrow><mi>η</mi><mo>,</mo><mi>i</mi></mrow></msub><mo>=</mo><mfrac displaystyle="true"><mrow><mi>d</mi><mi>w</mi></mrow><mrow><mi>d</mi><mi>η</mi></mrow></mfrac><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>η</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mu_{\eta,i} = \dfrac{dw}{d\eta}(\eta_i)</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>μ</mi><msub><mi>″</mi><mi>i</mi></msub><mo>=</mo><mfrac displaystyle="true"><mrow><msup><mi>d</mi><mn>2</mn></msup><mi>w</mi></mrow><mrow><mi>d</mi><msup><mi>η</mi><mn>2</mn></msup></mrow></mfrac><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>η</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mu''_i = \dfrac{d^2 w}{d\eta^2}(\eta_i)</annotation></semantics></math>
</li>
<li>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mo>=</mo><mtext mathvariant="normal">plogis</mtext><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">W = \text{plogis}(z)</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>d</mi><mi>W</mi></mrow><mrow><mi>d</mi><mi>z</mi></mrow></mfrac><mo>=</mo><mi>W</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><mi>W</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\frac{dW}{dz} = W(1 - W)</annotation></semantics></math>
</li>
<li>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>λ</mi><mi>W</mi></msub><mo>=</mo><mfrac><mi>C</mi><mrow><mn>1</mn><mo>−</mo><mi>W</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\lambda_W = \frac{C}{1 - W}</annotation></semantics></math>,
so
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>d</mi><msub><mi>λ</mi><mi>W</mi></msub></mrow><mrow><mi>d</mi><mi>W</mi></mrow></mfrac><mo>=</mo><mfrac><mi>C</mi><msup><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><mi>W</mi><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup></mfrac></mrow><annotation encoding="application/x-tex">\frac{d\lambda_W}{dW} = \frac{C}{(1 - W)^2}</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>d</mi><msub><mi>λ</mi><mi>W</mi></msub></mrow><mrow><mi>d</mi><mi>z</mi></mrow></mfrac><mo>=</mo><mfrac><mrow><mi>d</mi><msub><mi>λ</mi><mi>W</mi></msub></mrow><mrow><mi>d</mi><mi>W</mi></mrow></mfrac><mo>⋅</mo><mfrac><mrow><mi>d</mi><mi>W</mi></mrow><mrow><mi>d</mi><mi>z</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{d\lambda_W}{dz} = \frac{d\lambda_W}{dW} \cdot \frac{dW}{dz}</annotation></semantics></math>
</li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mrow><mtext mathvariant="normal">centered</mtext><mo>,</mo><mi>i</mi></mrow></msub><mo>=</mo><msub><mi>X</mi><mi>i</mi></msub><mo>−</mo><msub><mi>μ</mi><mi>x</mi></msub></mrow><annotation encoding="application/x-tex">X_{\text{centered},i} = X_i - \mu_x</annotation></semantics></math></li>
</ul>
<div class="section level3">
<h3 id="intermediate-derivatives">Intermediate Derivatives<a class="anchor" aria-label="anchor" href="#intermediate-derivatives"></a>
</h3>
<ul>
<li>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub><mo>=</mo><msub><mi>μ</mi><mrow><mi>η</mi><mo>,</mo><mi>i</mi></mrow></msub><mi>/</mi><msub><mi>w</mi><mi>i</mi></msub><mo>⇒</mo><mspace width="0.278em"></mspace><mfrac><mrow><mi>d</mi><msub><mi>s</mi><mi>i</mi></msub></mrow><mrow><mi>d</mi><msub><mi>η</mi><mi>i</mi></msub></mrow></mfrac><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>μ</mi><msub><mi>′</mi><mrow><mi>η</mi><mo>,</mo><mi>i</mi></mrow></msub><msub><mi>w</mi><mi>i</mi></msub><mo>−</mo><msubsup><mi>μ</mi><mrow><mi>η</mi><mo>,</mo><mi>i</mi></mrow><mn>2</mn></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mi>/</mi><msubsup><mi>w</mi><mi>i</mi><mn>2</mn></msubsup></mrow><annotation encoding="application/x-tex">s_i = \mu_{\eta,i}/w_i \Rightarrow \;\frac{ds_i}{d\eta_i} = (\mu'_{\eta,i}w_i - \mu_{\eta,i}^2)/w_i^2</annotation></semantics></math>
with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>μ</mi><msub><mi>′</mi><mrow><mi>η</mi><mo>,</mo><mi>i</mi></mrow></msub><mo>=</mo><mfrac displaystyle="true"><mrow><mi>d</mi><msub><mi>μ</mi><mrow><mi>η</mi><mo>,</mo><mi>i</mi></mrow></msub></mrow><mrow><mi>d</mi><msub><mi>η</mi><mi>i</mi></msub></mrow></mfrac><mo>=</mo><mfrac displaystyle="true"><mrow><msup><mi>d</mi><mn>2</mn></msup><mi>w</mi></mrow><mrow><mi>d</mi><msubsup><mi>η</mi><mi>i</mi><mn>2</mn></msubsup></mrow></mfrac><mo>≡</mo><mi>μ</mi><msub><mi>″</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\mu'_{\eta,i} = \dfrac{d\mu_{\eta,i}}{d\eta_i} = \dfrac{d^2 w}{d\eta_i^2} \equiv \mu''_i</annotation></semantics></math>
(this is <code>d2mu.deta2(eta_i)</code> in code)</li>
<li>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>i</mi></msub><mo>=</mo><mn>1</mn><mo>+</mo><msub><mi>λ</mi><mi>W</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>w</mi><mi>i</mi></msub><mo>−</mo><mi>W</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><msubsup><mi>X</mi><mrow><mtext mathvariant="normal">centered</mtext><mo>,</mo><mi>i</mi></mrow><mi>T</mi></msubsup><msub><mi>λ</mi><mi>x</mi></msub></mrow><annotation encoding="application/x-tex">D_i = 1 + \lambda_W (w_i - W) + X_{\text{centered},i}^T \lambda_x</annotation></semantics></math><ul>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>∂</mi><msub><mi>D</mi><mi>i</mi></msub></mrow><mrow><mi>∂</mi><msub><mi>η</mi><mi>i</mi></msub></mrow></mfrac><mo>=</mo><msub><mi>λ</mi><mi>W</mi></msub><msub><mi>μ</mi><mrow><mi>η</mi><mo>,</mo><mi>i</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\frac{\partial D_i}{\partial \eta_i} = \lambda_W \mu_{\eta,i}</annotation></semantics></math></li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>∂</mi><msub><mi>D</mi><mi>i</mi></msub></mrow><mrow><mi>∂</mi><mi>z</mi></mrow></mfrac><mo>=</mo><mfrac><mrow><mi>∂</mi><msub><mi>λ</mi><mi>W</mi></msub></mrow><mrow><mi>∂</mi><mi>z</mi></mrow></mfrac><mo>⋅</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>w</mi><mi>i</mi></msub><mo>−</mo><mi>W</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><msub><mi>λ</mi><mi>W</mi></msub><mo>⋅</mo><mfrac><mrow><mi>d</mi><mi>W</mi></mrow><mrow><mi>d</mi><mi>z</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\partial D_i}{\partial z} = \frac{\partial \lambda_W}{\partial z} \cdot (w_i - W) - \lambda_W \cdot \frac{dW}{dz}</annotation></semantics></math></li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>∂</mi><msub><mi>D</mi><mi>i</mi></msub></mrow><mrow><mi>∂</mi><msub><mi>λ</mi><mi>x</mi></msub></mrow></mfrac><mo>=</mo><msub><mi>X</mi><mrow><mtext mathvariant="normal">centered</mtext><mo>,</mo><mi>i</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\frac{\partial D_i}{\partial \lambda_x} = X_{\text{centered},i}</annotation></semantics></math></li>
</ul>
</li>
</ul>
<p>Define
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext mathvariant="normal">inv</mtext><mi>i</mi></msub><mo>=</mo><mn>1</mn><mi>/</mi><msub><mi>D</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\text{inv}_i = 1 / D_i</annotation></semantics></math>
and the scalar term driving
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>β</mi><annotation encoding="application/x-tex">\beta</annotation></semantics></math>-equations:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>i</mi></msub><mo>=</mo><msub><mi>s</mi><mi>i</mi></msub><mo>−</mo><msub><mi>λ</mi><mi>W</mi></msub><msub><mi>μ</mi><mrow><mi>η</mi><mo>,</mo><mi>i</mi></mrow></msub><msub><mtext mathvariant="normal">inv</mtext><mi>i</mi></msub><mo>,</mo><mspace width="1.0em"></mspace><msub><mi>s</mi><mi>i</mi></msub><mo>=</mo><mfrac><msub><mi>μ</mi><mrow><mi>η</mi><mo>,</mo><mi>i</mi></mrow></msub><msub><mi>w</mi><mi>i</mi></msub></mfrac><mi>.</mi></mrow><annotation encoding="application/x-tex">T_i = s_i - \lambda_W \mu_{\eta,i} \text{inv}_i,\quad s_i = \frac{\mu_{\eta,i}}{w_i}.</annotation></semantics></math></p>
</div>
<div class="section level3">
<h3 id="compute-its-derivatives">Compute Its Derivatives<a class="anchor" aria-label="anchor" href="#compute-its-derivatives"></a>
</h3>
<p>Using
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mspace width="0.167em"></mspace><mi>μ</mi><msub><mi>′</mi><mrow><mi>η</mi><mo>,</mo><mi>i</mi></mrow></msub><mo>=</mo><mi>d</mi><msub><mi>μ</mi><mrow><mi>η</mi><mo>,</mo><mi>i</mi></mrow></msub><mi>/</mi><mi>d</mi><msub><mi>η</mi><mi>i</mi></msub><mo>=</mo><mrow><mi mathvariant="normal">d</mi><mn mathvariant="normal">2</mn><mi mathvariant="normal">m</mi><mi mathvariant="normal">u</mi><mspace width="0.167em"></mspace><mi mathvariant="normal">d</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">a</mi><mn mathvariant="normal">2</mn></mrow><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>η</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\,\mu'_{\eta,i} = d\mu_{\eta,i}/d\eta_i = \mathrm{d2mu\,deta2}(\eta_i)</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mspace width="0.167em"></mspace><mi>d</mi><msub><mi>w</mi><mi>i</mi></msub><mi>/</mi><mi>d</mi><msub><mi>η</mi><mi>i</mi></msub><mo>=</mo><msub><mi>μ</mi><mrow><mi>η</mi><mo>,</mo><mi>i</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\,dw_i/d\eta_i = \mu_{\eta,i}</annotation></semantics></math>,</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>∂</mi><msub><mi>s</mi><mi>i</mi></msub></mrow><mrow><mi>∂</mi><msub><mi>η</mi><mi>i</mi></msub></mrow></mfrac><mo>=</mo><mfrac><mrow><mi>μ</mi><msub><mi>′</mi><mrow><mi>η</mi><mo>,</mo><mi>i</mi></mrow></msub><msub><mi>w</mi><mi>i</mi></msub><mo>−</mo><msubsup><mi>μ</mi><mrow><mi>η</mi><mo>,</mo><mi>i</mi></mrow><mn>2</mn></msubsup></mrow><msubsup><mi>w</mi><mi>i</mi><mn>2</mn></msubsup></mfrac><mi>.</mi></mrow><annotation encoding="application/x-tex">\frac{\partial s_i}{\partial \eta_i} = \frac{\mu'_{\eta,i} w_i - \mu_{\eta,i}^2}{w_i^2}.</annotation></semantics></math></p>
<p>Also
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mspace width="0.167em"></mspace><mfrac><mrow><mi>∂</mi><msub><mtext mathvariant="normal">inv</mtext><mi>i</mi></msub></mrow><mrow><mi>∂</mi><msub><mi>η</mi><mi>i</mi></msub></mrow></mfrac><mo>=</mo><mo>−</mo><msubsup><mtext mathvariant="normal">inv</mtext><mi>i</mi><mn>2</mn></msubsup><mo>⋅</mo><mfrac><mrow><mi>∂</mi><msub><mi>D</mi><mi>i</mi></msub></mrow><mrow><mi>∂</mi><msub><mi>η</mi><mi>i</mi></msub></mrow></mfrac><mo>=</mo><mo>−</mo><msubsup><mtext mathvariant="normal">inv</mtext><mi>i</mi><mn>2</mn></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>λ</mi><mi>W</mi></msub><msub><mi>μ</mi><mrow><mi>η</mi><mo>,</mo><mi>i</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\,\frac{\partial \text{inv}_i}{\partial \eta_i} = -\text{inv}_i^2 \cdot \frac{\partial D_i}{\partial \eta_i} = -\text{inv}_i^2 (\lambda_W \mu_{\eta,i})</annotation></semantics></math>.
Therefore</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>∂</mi><msub><mi>T</mi><mi>i</mi></msub></mrow><mrow><mi>∂</mi><msub><mi>η</mi><mi>i</mi></msub></mrow></mfrac><mo>=</mo><mfrac><mrow><mi>μ</mi><msub><mi>′</mi><mrow><mi>η</mi><mo>,</mo><mi>i</mi></mrow></msub><msub><mi>w</mi><mi>i</mi></msub><mo>−</mo><msubsup><mi>μ</mi><mrow><mi>η</mi><mo>,</mo><mi>i</mi></mrow><mn>2</mn></msubsup></mrow><msubsup><mi>w</mi><mi>i</mi><mn>2</mn></msubsup></mfrac><mo>−</mo><msub><mi>λ</mi><mi>W</mi></msub><mi>μ</mi><msub><mi>′</mi><mrow><mi>η</mi><mo>,</mo><mi>i</mi></mrow></msub><msub><mtext mathvariant="normal">inv</mtext><mi>i</mi></msub><mo>+</mo><msubsup><mi>λ</mi><mi>W</mi><mn>2</mn></msubsup><msup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>μ</mi><mrow><mi>η</mi><mo>,</mo><mi>i</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup><msubsup><mtext mathvariant="normal">inv</mtext><mi>i</mi><mn>2</mn></msubsup><mi>.</mi></mrow><annotation encoding="application/x-tex">\frac{\partial T_i}{\partial \eta_i} = \frac{\mu'_{\eta,i} w_i - \mu_{\eta,i}^2}{w_i^2} - \lambda_W \mu'_{\eta,i} \text{inv}_i + \lambda_W^2 (\mu_{\eta,i})^2 \text{inv}_i^2.</annotation></semantics></math></p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>∂</mi><msub><mi>T</mi><mi>i</mi></msub></mrow><mrow><mi>∂</mi><mi>z</mi></mrow></mfrac><mo>=</mo><mo>−</mo><mfrac><mrow><mi>∂</mi><msub><mi>λ</mi><mi>W</mi></msub></mrow><mrow><mi>∂</mi><mi>z</mi></mrow></mfrac><mo>⋅</mo><msub><mi>μ</mi><mrow><mi>η</mi><mo>,</mo><mi>i</mi></mrow></msub><msub><mtext mathvariant="normal">inv</mtext><mi>i</mi></msub><mo>+</mo><msub><mi>λ</mi><mi>W</mi></msub><msub><mi>μ</mi><mrow><mi>η</mi><mo>,</mo><mi>i</mi></mrow></msub><msubsup><mtext mathvariant="normal">inv</mtext><mi>i</mi><mn>2</mn></msubsup><mo>⋅</mo><mfrac><mrow><mi>∂</mi><msub><mi>D</mi><mi>i</mi></msub></mrow><mrow><mi>∂</mi><mi>z</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\partial T_i}{\partial z} = -\frac{\partial \lambda_W}{\partial z} \cdot \mu_{\eta,i} \text{inv}_i + \lambda_W \mu_{\eta,i} \text{inv}_i^2 \cdot \frac{\partial D_i}{\partial z}</annotation></semantics></math></p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>∂</mi><msub><mi>T</mi><mi>i</mi></msub></mrow><mrow><mi>∂</mi><msub><mi>λ</mi><mi>x</mi></msub></mrow></mfrac><mo>=</mo><msub><mi>λ</mi><mi>W</mi></msub><msub><mi>μ</mi><mrow><mi>η</mi><mo>,</mo><mi>i</mi></mrow></msub><msubsup><mtext mathvariant="normal">inv</mtext><mi>i</mi><mn>2</mn></msubsup><mo>⋅</mo><msub><mi>X</mi><mrow><mtext mathvariant="normal">centered</mtext><mo>,</mo><mi>i</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\frac{\partial T_i}{\partial \lambda_x} = \lambda_W \mu_{\eta,i} \text{inv}_i^2 \cdot X_{\text{centered},i}</annotation></semantics></math></p>
</div>
<div class="section level3">
<h3 id="assemble-jacobian-blocks-with-a_i-weights">Assemble Jacobian Blocks (with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>a</mi><mi>i</mi></msub><annotation encoding="application/x-tex">a_i</annotation></semantics></math>
weights)<a class="anchor" aria-label="anchor" href="#assemble-jacobian-blocks-with-a_i-weights"></a>
</h3>
<p><strong><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>J</mi><mrow><mi>β</mi><mi>β</mi></mrow></msub><annotation encoding="application/x-tex">J_{\beta\beta}</annotation></semantics></math>
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo>×</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">K \times K</annotation></semantics></math>)</strong>:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>J</mi><mn>11</mn></msub><mo>=</mo><mo>∑</mo><msub><mi>a</mi><mi>i</mi></msub><msubsup><mi>Z</mi><mi>i</mi><mi>T</mi></msubsup><mrow><mo stretchy="true" form="prefix">[</mo><mfrac><mrow><mi>∂</mi><msub><mi>T</mi><mi>i</mi></msub></mrow><mrow><mi>∂</mi><msub><mi>η</mi><mi>i</mi></msub></mrow></mfrac><mo stretchy="true" form="postfix">]</mo></mrow><msub><mi>Z</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">J_{11} = \sum a_i Z_i^T \left[ \frac{\partial T_i}{\partial \eta_i} \right] Z_i</annotation></semantics></math></p>
<p><strong><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>J</mi><mrow><mi>β</mi><mi>z</mi></mrow></msub><annotation encoding="application/x-tex">J_{\beta z}</annotation></semantics></math>
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo>×</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">K \times 1</annotation></semantics></math>)</strong>:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>J</mi><mn>12</mn></msub><mo>=</mo><mo>∑</mo><msub><mi>a</mi><mi>i</mi></msub><msubsup><mi>Z</mi><mi>i</mi><mi>T</mi></msubsup><mrow><mo stretchy="true" form="prefix">[</mo><mfrac><mrow><mi>∂</mi><msub><mi>T</mi><mi>i</mi></msub></mrow><mrow><mi>∂</mi><mi>z</mi></mrow></mfrac><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">J_{12} = \sum a_i Z_i^T \left[ \frac{\partial T_i}{\partial z} \right]</annotation></semantics></math></p>
<p><strong><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>J</mi><mrow><mi>β</mi><mi>λ</mi></mrow></msub><annotation encoding="application/x-tex">J_{\beta \lambda}</annotation></semantics></math>
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo>×</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">K \times L</annotation></semantics></math>)</strong>:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>J</mi><mn>13</mn></msub><mo>=</mo><mo>∑</mo><msub><mi>a</mi><mi>i</mi></msub><msubsup><mi>Z</mi><mi>i</mi><mi>T</mi></msubsup><mrow><mo stretchy="true" form="prefix">[</mo><mfrac><mrow><mi>∂</mi><msub><mi>T</mi><mi>i</mi></msub></mrow><mrow><mi>∂</mi><msub><mi>λ</mi><mi>x</mi></msub></mrow></mfrac><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">J_{13} = \sum a_i Z_i^T \left[ \frac{\partial T_i}{\partial \lambda_x} \right]</annotation></semantics></math></p>
<p><strong><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>J</mi><mrow><mi>z</mi><mi>β</mi></mrow></msub><annotation encoding="application/x-tex">J_{z\beta}</annotation></semantics></math>
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>×</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">1 \times K</annotation></semantics></math>)</strong>:
derivative of W-equation w.r.t.
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>β</mi><annotation encoding="application/x-tex">\beta</annotation></semantics></math></p>
<p>Equation:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mi>W</mi></msub><mo>=</mo><mo>∑</mo><msub><mi>a</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>w</mi><mi>i</mi></msub><mo>−</mo><mi>W</mi><mo stretchy="true" form="postfix">)</mo></mrow><msub><mtext mathvariant="normal">inv</mtext><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">G_W = \sum a_i (w_i - W) \text{inv}_i</annotation></semantics></math></p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>∂</mi><msub><mi>G</mi><mi>W</mi></msub></mrow><mrow><mi>∂</mi><msub><mi>η</mi><mi>i</mi></msub></mrow></mfrac><mo>=</mo><msub><mi>a</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>μ</mi><mrow><mi>η</mi><mo>,</mo><mi>i</mi></mrow></msub><msub><mtext mathvariant="normal">inv</mtext><mi>i</mi></msub><mo>−</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>w</mi><mi>i</mi></msub><mo>−</mo><mi>W</mi><mo stretchy="true" form="postfix">)</mo></mrow><msubsup><mtext mathvariant="normal">inv</mtext><mi>i</mi><mn>2</mn></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><mrow><mi>∂</mi><msub><mi>D</mi><mi>i</mi></msub></mrow><mrow><mi>∂</mi><msub><mi>η</mi><mi>i</mi></msub></mrow></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">]</mo></mrow><mo>=</mo><msub><mi>a</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>μ</mi><mrow><mi>η</mi><mo>,</mo><mi>i</mi></mrow></msub><msub><mtext mathvariant="normal">inv</mtext><mi>i</mi></msub><mo>−</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>w</mi><mi>i</mi></msub><mo>−</mo><mi>W</mi><mo stretchy="true" form="postfix">)</mo></mrow><msubsup><mtext mathvariant="normal">inv</mtext><mi>i</mi><mn>2</mn></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>λ</mi><mi>W</mi></msub><msub><mi>μ</mi><mrow><mi>η</mi><mo>,</mo><mi>i</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">\frac{\partial G_W}{\partial \eta_i} = a_i \left[ \mu_{\eta,i} \text{inv}_i - (w_i - W) \text{inv}_i^2 \left(\frac{\partial D_i}{\partial \eta_i}\right) \right] = a_i \left[ \mu_{\eta,i} \text{inv}_i - (w_i - W) \text{inv}_i^2 (\lambda_W \mu_{\eta,i}) \right]</annotation></semantics></math></p>
<p>Then:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>J</mi><mn>21</mn></msub><mo>=</mo><mo>∑</mo><mfrac><mrow><mi>∂</mi><msub><mi>G</mi><mi>W</mi></msub></mrow><mrow><mi>∂</mi><msub><mi>η</mi><mi>i</mi></msub></mrow></mfrac><mo>⋅</mo><msub><mi>Z</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">J_{21} = \sum \frac{\partial G_W}{\partial \eta_i} \cdot Z_i</annotation></semantics></math></p>
<p><strong><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>J</mi><mrow><mi>z</mi><mi>z</mi></mrow></msub><annotation encoding="application/x-tex">J_{zz}</annotation></semantics></math>
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>×</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1 \times 1</annotation></semantics></math>)</strong>:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>∂</mi><msub><mi>G</mi><mi>W</mi></msub></mrow><mrow><mi>∂</mi><mi>z</mi></mrow></mfrac><mo>=</mo><mo>∑</mo><msub><mi>a</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">[</mo><mo>−</mo><mfrac><mrow><mi>d</mi><mi>W</mi></mrow><mrow><mi>d</mi><mi>z</mi></mrow></mfrac><mo>⋅</mo><msub><mtext mathvariant="normal">inv</mtext><mi>i</mi></msub><mo>−</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>w</mi><mi>i</mi></msub><mo>−</mo><mi>W</mi><mo stretchy="true" form="postfix">)</mo></mrow><msubsup><mtext mathvariant="normal">inv</mtext><mi>i</mi><mn>2</mn></msubsup><mo>⋅</mo><mfrac><mrow><mi>∂</mi><msub><mi>D</mi><mi>i</mi></msub></mrow><mrow><mi>∂</mi><mi>z</mi></mrow></mfrac><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">\frac{\partial G_W}{\partial z} = \sum a_i \left[ -\frac{dW}{dz} \cdot \text{inv}_i - (w_i - W) \text{inv}_i^2 \cdot \frac{\partial D_i}{\partial z} \right]</annotation></semantics></math></p>
<p><strong><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>J</mi><mrow><mi>z</mi><mi>λ</mi></mrow></msub><annotation encoding="application/x-tex">J_{z\lambda}</annotation></semantics></math>
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>×</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">1 \times L</annotation></semantics></math>)</strong>:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>∂</mi><msub><mi>G</mi><mi>W</mi></msub></mrow><mrow><mi>∂</mi><msub><mi>λ</mi><mi>x</mi></msub></mrow></mfrac><mo>=</mo><mo>∑</mo><msub><mi>a</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">[</mo><mo>−</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>w</mi><mi>i</mi></msub><mo>−</mo><mi>W</mi><mo stretchy="true" form="postfix">)</mo></mrow><msubsup><mtext mathvariant="normal">inv</mtext><mi>i</mi><mn>2</mn></msubsup><msub><mi>X</mi><mrow><mtext mathvariant="normal">centered</mtext><mo>,</mo><mi>i</mi></mrow></msub><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">\frac{\partial G_W}{\partial \lambda_x} = \sum a_i \left[ -(w_i - W) \text{inv}_i^2 X_{\text{centered},i} \right]</annotation></semantics></math></p>
<p><strong><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>J</mi><mrow><mi>λ</mi><mi>β</mi></mrow></msub><annotation encoding="application/x-tex">J_{\lambda\beta}</annotation></semantics></math>
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>×</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">L \times K</annotation></semantics></math>)</strong>:
constraints
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>λ</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>:</mo><mo>∑</mo><msub><mi>a</mi><mi>i</mi></msub><msub><mtext mathvariant="normal">inv</mtext><mi>i</mi></msub><msub><mi>X</mi><mrow><mtext mathvariant="normal">centered</mtext><mo>,</mo><mi>i</mi></mrow></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">H(\lambda): \sum a_i \text{inv}_i X_{\text{centered},i} = 0</annotation></semantics></math></p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>∂</mi><mi>H</mi></mrow><mrow><mi>∂</mi><msub><mi>η</mi><mi>i</mi></msub></mrow></mfrac><mo>=</mo><mo>−</mo><msub><mi>a</mi><mi>i</mi></msub><msubsup><mtext mathvariant="normal">inv</mtext><mi>i</mi><mn>2</mn></msubsup><mfrac><mrow><mi>∂</mi><msub><mi>D</mi><mi>i</mi></msub></mrow><mrow><mi>∂</mi><msub><mi>η</mi><mi>i</mi></msub></mrow></mfrac><msub><mi>X</mi><mrow><mtext mathvariant="normal">centered</mtext><mo>,</mo><mi>i</mi></mrow></msub><mo>=</mo><mo>−</mo><msub><mi>a</mi><mi>i</mi></msub><msubsup><mtext mathvariant="normal">inv</mtext><mi>i</mi><mn>2</mn></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>λ</mi><mi>W</mi></msub><msub><mi>μ</mi><mrow><mi>η</mi><mo>,</mo><mi>i</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><msub><mi>X</mi><mrow><mtext mathvariant="normal">centered</mtext><mo>,</mo><mi>i</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\frac{\partial H}{\partial \eta_i} = -a_i \text{inv}_i^2 \frac{\partial D_i}{\partial \eta_i} X_{\text{centered},i} = -a_i \text{inv}_i^2 (\lambda_W \mu_{\eta,i}) X_{\text{centered},i}</annotation></semantics></math></p>
<p>Thus, component-wise
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>J</mi><mn>31</mn></msub><mo>=</mo><msub><mo>∑</mo><mi>i</mi></msub><msub><mi>a</mi><mi>i</mi></msub><mspace width="0.167em"></mspace><mrow><mo stretchy="true" form="prefix">(</mo><mo>−</mo><msub><mi>λ</mi><mi>W</mi></msub><msub><mi>μ</mi><mrow><mi>η</mi><mo>,</mo><mi>i</mi></mrow></msub><mspace width="0.167em"></mspace><msubsup><mtext mathvariant="normal">inv</mtext><mi>i</mi><mn>2</mn></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mspace width="0.167em"></mspace><msubsup><mi>X</mi><mrow><mtext mathvariant="normal">centered</mtext><mo>,</mo><mi>i</mi></mrow><mi>T</mi></msubsup><msub><mi>Z</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">J_{31} = \sum_i a_i\,(-\lambda_W \mu_{\eta,i}\,\text{inv}_i^2)\, X_{\text{centered},i}^T Z_i</annotation></semantics></math>.
In compact matrix form:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>J</mi><mn>31</mn></msub><mo>=</mo><msubsup><mi>X</mi><mtext mathvariant="normal">centered</mtext><mi>T</mi></msubsup><mo>diag</mo><mspace width="-0.167em"></mspace><mo minsize="1.2" maxsize="1.2" stretchy="false" form="prefix">(</mo><mo>−</mo><msub><mi>a</mi><mi>i</mi></msub><mspace width="0.167em"></mspace><msub><mi>λ</mi><mi>W</mi></msub><mspace width="0.167em"></mspace><msub><mi>μ</mi><mrow><mi>η</mi><mo>,</mo><mi>i</mi></mrow></msub><mspace width="0.167em"></mspace><msubsup><mtext mathvariant="normal">inv</mtext><mi>i</mi><mn>2</mn></msubsup><mo minsize="1.2" maxsize="1.2" stretchy="false" form="postfix">)</mo><mi>Z</mi><mi>.</mi></mrow><annotation encoding="application/x-tex">J_{31} = X_{\text{centered}}^T \operatorname{diag}\!\big(-a_i\,\lambda_W\,\mu_{\eta,i}\,\text{inv}_i^2\big) Z.</annotation></semantics></math></p>
<p><strong><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>J</mi><mrow><mi>λ</mi><mi>z</mi></mrow></msub><annotation encoding="application/x-tex">J_{\lambda z}</annotation></semantics></math>
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>×</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">L \times 1</annotation></semantics></math>)</strong>:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>∂</mi><mi>H</mi></mrow><mrow><mi>∂</mi><mi>z</mi></mrow></mfrac><mo>=</mo><mo>−</mo><mo>∑</mo><msub><mi>a</mi><mi>i</mi></msub><msubsup><mtext mathvariant="normal">inv</mtext><mi>i</mi><mn>2</mn></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><mrow><mi>∂</mi><msub><mi>D</mi><mi>i</mi></msub></mrow><mrow><mi>∂</mi><mi>z</mi></mrow></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><msub><mi>X</mi><mrow><mtext mathvariant="normal">centered</mtext><mo>,</mo><mi>i</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\frac{\partial H}{\partial z} = -\sum a_i \text{inv}_i^2 \left(\frac{\partial D_i}{\partial z}\right) X_{\text{centered},i}</annotation></semantics></math></p>
<p><strong><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>J</mi><mrow><mi>λ</mi><mi>λ</mi></mrow></msub><annotation encoding="application/x-tex">J_{\lambda\lambda}</annotation></semantics></math>
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>×</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">L \times L</annotation></semantics></math>)</strong>:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>∂</mi><mi>H</mi></mrow><mrow><mi>∂</mi><msub><mi>λ</mi><mi>x</mi></msub></mrow></mfrac><mo>=</mo><mo>−</mo><msubsup><mi>X</mi><mtext mathvariant="normal">centered</mtext><mi>T</mi></msubsup><mo>diag</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>a</mi><mi>i</mi></msub><mspace width="0.167em"></mspace><msubsup><mtext mathvariant="normal">inv</mtext><mi>i</mi><mn>2</mn></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><msub><mi>X</mi><mtext mathvariant="normal">centered</mtext></msub><mi>.</mi></mrow><annotation encoding="application/x-tex">\frac{\partial H}{\partial \lambda_x} = -X_{\text{centered}}^T \operatorname{diag}(a_i\,\text{inv}_i^2) X_{\text{centered}}.</annotation></semantics></math></p>
<p>These are exactly what <code>build_el_jacobian</code> computes
(<code>src_dev/engines/el/impl/jacobian.R</code>).</p>
</div>
<div class="section level3">
<h3 id="why-analytic-a-helps">Why Analytic A Helps<a class="anchor" aria-label="anchor" href="#why-analytic-a-helps"></a>
</h3>
<ul>
<li>Newton-Raphson (as used in our outer solve) linearizes
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>θ</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">F(\theta)</annotation></semantics></math>
near the current iterate:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>θ</mi><mo>+</mo><mi>Δ</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>≈</mo><mi>F</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>θ</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mi>A</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>θ</mi><mo stretchy="true" form="postfix">)</mo></mrow><mspace width="0.167em"></mspace><mi>Δ</mi></mrow><annotation encoding="application/x-tex">F(\theta + \Delta) \approx F(\theta) + A(\theta)\,\Delta</annotation></semantics></math>.
The update
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Δ</mi><annotation encoding="application/x-tex">\Delta</annotation></semantics></math>
solves
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mspace width="0.167em"></mspace><mi>Δ</mi><mo>=</mo><mo>−</mo><mi>F</mi></mrow><annotation encoding="application/x-tex">A\,\Delta = -F</annotation></semantics></math>,
hence a high-quality
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
is critical for fast, stable convergence.</li>
</ul>
</div>
</div>
<div class="section level2">
<h2 id="delta-variance-nabla-g-a-1-b-a-t-nabla-gt">Delta Variance:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>∇</mi><mi>g</mi><mspace width="0.167em"></mspace><msup><mi>A</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mspace width="0.167em"></mspace><mi>B</mi><mspace width="0.167em"></mspace><msup><mi>A</mi><mrow><mo>−</mo><mi>T</mi></mrow></msup><mspace width="0.167em"></mspace><mi>∇</mi><msup><mi>g</mi><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">\nabla g \, A^{-1} \, B \, A^{-T} \, \nabla g^T</annotation></semantics></math><a class="anchor" aria-label="anchor" href="#delta-variance-nabla-g-a-1-b-a-t-nabla-gt"></a>
</h2>
<p>We compute:</p>
<ul>
<li>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>=</mo><mi>∂</mi><mi>F</mi><mi>/</mi><mi>∂</mi><mi>θ</mi></mrow><annotation encoding="application/x-tex">A = \partial F/\partial\theta</annotation></semantics></math>
from the analytic Jacobian when available (logit, probit); numeric
otherwise with the same denominator guard.</li>
<li>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>=</mo><mo>Var</mo><mrow><mo stretchy="true" form="prefix">(</mo><mo>∑</mo><msub><mi>U</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">B = \operatorname{Var}(\sum U_i)</annotation></semantics></math>
built from the stacked per-respondent contributions
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>U</mi><mi>i</mi></msub><annotation encoding="application/x-tex">U_i</annotation></semantics></math>
(matching
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>),
with either i.i.d. covariance or design-based covariance (survey).</li>
<li>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>∇</mi><mi>g</mi></mrow><annotation encoding="application/x-tex">\nabla g</annotation></semantics></math>
evaluated at the solution (analytic when smooth and untrimmed; numeric
fallback otherwise).</li>
</ul>
<p>IID B (data frame path): We compute
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>B</mi><mo accent="true">̂</mo></mover><mo>=</mo><mo>∑</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>U</mi><mi>i</mi></msub><mo>−</mo><mover><mi>U</mi><mo accent="true">‾</mo></mover><mo stretchy="true" form="postfix">)</mo></mrow><msup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>U</mi><mi>i</mi></msub><mo>−</mo><mover><mi>U</mi><mo accent="true">‾</mo></mover><mo stretchy="true" form="postfix">)</mo></mrow><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">\widehat B = \sum (U_i - \bar U)(U_i - \bar U)^T</annotation></semantics></math>
at the solution. Centering is asymptotically neutral and reduces
small-sample noise.</p>
<p>Survey B: We construct score variables on the full design by placing
respondent
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>U</mi><mi>i</mi></msub><annotation encoding="application/x-tex">U_i</annotation></semantics></math>
on observed rows and zeros on nonrespondents, then compute the
covariance of <code>svytotal(~U, design)</code>. This uses standard
survey-inference machinery and respects
stratification/clustering/weights.</p>
<p>Trimming: When <code>trim_cap &lt; Inf</code>, we recommend
<code>variance_method = "bootstrap"</code> or strengthen auxiliary
constraints. With trimming, the estimator is non-smooth, so bootstrap is
recommended for inference.</p>
<p>Implementation: <code>el_compute_delta_variance()</code> in
<code>src_dev/engines/el/impl/variance.R</code> assembles
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>
from <code>U_matrix_resp</code> and the provided
<code>compute_score_variance_func</code> (IID vs survey), computes
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>∇</mi><mi>g</mi></mrow><annotation encoding="application/x-tex">\nabla g</annotation></semantics></math>
(analytic when smooth; stabilized numeric otherwise), and returns
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">V</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">r</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mover><mi>Y</mi><mo accent="true">̂</mo></mover><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathrm{Var}(\hat{Y})</annotation></semantics></math>
and the (scaled) sandwich vcov for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>β</mi><annotation encoding="application/x-tex">\beta</annotation></semantics></math>.</p>
<div class="section level3">
<h3 id="worked-example-analytic-nabla-g-in-a-1-covariate-logit-case">Worked Example: Analytic
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>∇</mi><mi>g</mi></mrow><annotation encoding="application/x-tex">\nabla g</annotation></semantics></math>
in a 1-Covariate Logit Case<a class="anchor" aria-label="anchor" href="#worked-example-analytic-nabla-g-in-a-1-covariate-logit-case"></a>
</h3>
<p>Consider the simple, smooth setting with no trimming (cap
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>=</mo><mi>∞</mi></mrow><annotation encoding="application/x-tex">=\infty</annotation></semantics></math>),
no auxiliary constraints
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">L=0</annotation></semantics></math>),
and a logit response model
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>η</mi><mi>i</mi></msub><mo>=</mo><msub><mi>Z</mi><mi>i</mi></msub><mspace width="0.167em"></mspace><mi>β</mi><mo>=</mo><msub><mi>β</mi><mn>0</mn></msub><mo>+</mo><msub><mi>β</mi><mn>1</mn></msub><msub><mi>x</mi><mi>i</mi></msub><mo>,</mo><mspace width="2.0em"></mspace><msub><mi>w</mi><mi>i</mi></msub><mo>=</mo><msup><mo>logit</mo><mrow><mo>−</mo><mn>1</mn></mrow></msup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>η</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mspace width="2.0em"></mspace><msub><mi>μ</mi><mrow><mi>η</mi><mo>,</mo><mi>i</mi></mrow></msub><mo>=</mo><mfrac><mrow><mi>d</mi><msub><mi>w</mi><mi>i</mi></msub></mrow><mrow><mi>d</mi><msub><mi>η</mi><mi>i</mi></msub></mrow></mfrac><mo>=</mo><msub><mi>w</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><msub><mi>w</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>.</mi></mrow><annotation encoding="application/x-tex">
\eta_i = Z_i\,\beta = \beta_0 + \beta_1 x_i,\qquad w_i = \operatorname{logit}^{-1}(\eta_i),\qquad \mu_{\eta,i} = \frac{dw_i}{d\eta_i} = w_i (1-w_i).
</annotation></semantics></math> Let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mo>=</mo><msub><mi>N</mi><mtext mathvariant="normal">pop</mtext></msub><mi>/</mi><msub><mi>n</mi><mtext mathvariant="normal">resp_weighted</mtext></msub><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">C = N_{\text{pop}}/n_{\text{resp\_weighted}} - 1</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mo>=</mo><msup><mo>logit</mo><mrow><mo>−</mo><mn>1</mn></mrow></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">W = \operatorname{logit}^{-1}(z)</annotation></semantics></math>,
so
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>λ</mi><mi>W</mi></msub><mo>=</mo><mfrac><mi>C</mi><mrow><mn>1</mn><mo>−</mo><mi>W</mi></mrow></mfrac><mo>,</mo><mspace width="2.0em"></mspace><mfrac><mrow><mi>d</mi><mi>W</mi></mrow><mrow><mi>d</mi><mi>z</mi></mrow></mfrac><mo>=</mo><mi>W</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><mi>W</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mspace width="2.0em"></mspace><mfrac><mrow><mi>d</mi><msub><mi>λ</mi><mi>W</mi></msub></mrow><mrow><mi>d</mi><mi>z</mi></mrow></mfrac><mo>=</mo><mfrac><mrow><mi>C</mi><mspace width="0.167em"></mspace><mi>W</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><mi>W</mi><mo stretchy="true" form="postfix">)</mo></mrow></mfrac><mo>=</mo><msub><mi>λ</mi><mi>W</mi></msub><mspace width="0.167em"></mspace><mfrac><mi>W</mi><mrow><mn>1</mn><mo>−</mo><mi>W</mi></mrow></mfrac><mi>.</mi></mrow><annotation encoding="application/x-tex">
\lambda_W = \frac{C}{1-W},\qquad \frac{dW}{dz} = W(1-W),\qquad \frac{d\lambda_W}{dz} = \frac{C\,W}{(1-W)} = \lambda_W\,\frac{W}{1-W}.
</annotation></semantics></math> With no auxiliaries, the EL denominator
and weights for respondents are
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>i</mi></msub><mo>=</mo><mn>1</mn><mo>+</mo><msub><mi>λ</mi><mi>W</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>w</mi><mi>i</mi></msub><mo>−</mo><mi>W</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mspace width="2.0em"></mspace><msub><mi>π</mi><mi>i</mi></msub><mo>=</mo><mfrac><msub><mi>a</mi><mi>i</mi></msub><msub><mi>D</mi><mi>i</mi></msub></mfrac><mo>,</mo><mspace width="2.0em"></mspace><mi>B</mi><mo>=</mo><munder><mo>∑</mo><mi>i</mi></munder><msub><mi>π</mi><mi>i</mi></msub><mo>,</mo><mspace width="2.0em"></mspace><mover><mi>Y</mi><mo accent="true">̂</mo></mover><mo>=</mo><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>θ</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mfrac><mrow><munder><mo>∑</mo><mi>i</mi></munder><msub><mi>π</mi><mi>i</mi></msub><msub><mi>Y</mi><mi>i</mi></msub></mrow><mi>B</mi></mfrac><mo>,</mo></mrow><annotation encoding="application/x-tex">
D_i = 1 + \lambda_W (w_i - W),\qquad \pi_i = \frac{a_i}{D_i},\qquad B = \sum_i \pi_i,\qquad \hat Y = g(\theta) = \frac{\sum_i \pi_i Y_i}{B},
</annotation></semantics></math> where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>a</mi><mi>i</mi></msub><annotation encoding="application/x-tex">a_i</annotation></semantics></math>
are base weights
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo>≡</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">a_i\equiv 1</annotation></semantics></math>
for IID; design weights for survey). The analytic gradient of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>g</mi><annotation encoding="application/x-tex">g</annotation></semantics></math>
follows from the ratio rule and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>∂</mi><msub><mi>π</mi><mi>i</mi></msub><mi>/</mi><mi>∂</mi><mi>θ</mi></mrow><annotation encoding="application/x-tex">\partial\pi_i/\partial\theta</annotation></semantics></math>.</p>
<ol style="list-style-type: decimal">
<li>Gradient w.r.t.
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>β</mi><annotation encoding="application/x-tex">\beta</annotation></semantics></math>.</li>
</ol>
<p>Since
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>∂</mi><msub><mi>D</mi><mi>i</mi></msub><mi>/</mi><mi>∂</mi><mi>β</mi><mo>=</mo><msub><mi>λ</mi><mi>W</mi></msub><mspace width="0.167em"></mspace><msub><mi>μ</mi><mrow><mi>η</mi><mo>,</mo><mi>i</mi></mrow></msub><mspace width="0.167em"></mspace><msub><mi>Z</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\partial D_i/\partial\beta = \lambda_W\,\mu_{\eta,i}\,Z_i</annotation></semantics></math>,
we have
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>∂</mi><msub><mi>π</mi><mi>i</mi></msub><mi>/</mi><mi>∂</mi><mi>β</mi><mo>=</mo><mo>−</mo><mspace width="0.167em"></mspace><msub><mi>a</mi><mi>i</mi></msub><mspace width="0.167em"></mspace><msub><mi>λ</mi><mi>W</mi></msub><mspace width="0.167em"></mspace><msub><mi>μ</mi><mrow><mi>η</mi><mo>,</mo><mi>i</mi></mrow></msub><mspace width="0.167em"></mspace><msub><mi>Z</mi><mi>i</mi></msub><mi>/</mi><msubsup><mi>D</mi><mi>i</mi><mn>2</mn></msubsup></mrow><annotation encoding="application/x-tex">\partial\pi_i/\partial\beta = -\,a_i\,\lambda_W\,\mu_{\eta,i}\,Z_i/ D_i^2</annotation></semantics></math>,
and therefore
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><menclose notation="box"><mrow><mspace width="0.278em"></mspace><mfrac><mrow><mi>∂</mi><mi>g</mi></mrow><mrow><mi>∂</mi><mi>β</mi></mrow></mfrac><mspace width="0.167em"></mspace><mo>=</mo><mspace width="0.167em"></mspace><mfrac><mn>1</mn><mi>B</mi></mfrac><munder><mo>∑</mo><mi>i</mi></munder><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Y</mi><mi>i</mi></msub><mo>−</mo><mover><mi>Y</mi><mo accent="true">̂</mo></mover><mo stretchy="true" form="postfix">)</mo></mrow><mspace width="0.167em"></mspace><mfrac><mrow><mi>∂</mi><msub><mi>π</mi><mi>i</mi></msub></mrow><mrow><mi>∂</mi><mi>β</mi></mrow></mfrac><mspace width="0.278em"></mspace><mo>=</mo><mspace width="0.278em"></mspace><mo>−</mo><mspace width="0.167em"></mspace><mfrac><mn>1</mn><mi>B</mi></mfrac><munder><mo>∑</mo><mi>i</mi></munder><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Y</mi><mi>i</mi></msub><mo>−</mo><mover><mi>Y</mi><mo accent="true">̂</mo></mover><mo stretchy="true" form="postfix">)</mo></mrow><mspace width="0.167em"></mspace><mfrac><mrow><msub><mi>a</mi><mi>i</mi></msub><mspace width="0.167em"></mspace><msub><mi>λ</mi><mi>W</mi></msub><mspace width="0.167em"></mspace><msub><mi>μ</mi><mrow><mi>η</mi><mo>,</mo><mi>i</mi></mrow></msub></mrow><msubsup><mi>D</mi><mi>i</mi><mn>2</mn></msubsup></mfrac><mspace width="0.167em"></mspace><msub><mi>Z</mi><mi>i</mi></msub><mspace width="0.278em"></mspace></mrow></menclose><mi>.</mi></mrow><annotation encoding="application/x-tex">
\boxed{\;\frac{\partial g}{\partial \beta} \,=\, \frac{1}{B}\sum_i (Y_i - \hat Y)\,\frac{\partial \pi_i}{\partial\beta}
\;=\; -\,\frac{1}{B}\sum_i (Y_i - \hat Y)\,\frac{a_i\,\lambda_W\,\mu_{\eta,i}}{D_i^2}\,Z_i\; }.
</annotation></semantics></math></p>
<ol start="2" style="list-style-type: decimal">
<li>Gradient w.r.t. the reparametrized
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi><mo>=</mo><mo>logit</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>W</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">z = \operatorname{logit}(W)</annotation></semantics></math>.</li>
</ol>
<p>Using
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>∂</mi><msub><mi>D</mi><mi>i</mi></msub><mi>/</mi><mi>∂</mi><mi>z</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>d</mi><msub><mi>λ</mi><mi>W</mi></msub><mi>/</mi><mi>d</mi><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mspace width="0.167em"></mspace><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>w</mi><mi>i</mi></msub><mo>−</mo><mi>W</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><msub><mi>λ</mi><mi>W</mi></msub><mspace width="0.167em"></mspace><mfrac><mrow><mi>d</mi><mi>W</mi></mrow><mrow><mi>d</mi><mi>z</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\partial D_i/\partial z = (d\lambda_W/dz)\,(w_i - W) - \lambda_W\,\frac{dW}{dz}</annotation></semantics></math>,
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><menclose notation="box"><mrow><mspace width="0.278em"></mspace><mfrac><mrow><mi>∂</mi><mi>g</mi></mrow><mrow><mi>∂</mi><mi>z</mi></mrow></mfrac><mspace width="0.167em"></mspace><mo>=</mo><mspace width="0.167em"></mspace><mfrac><mn>1</mn><mi>B</mi></mfrac><munder><mo>∑</mo><mi>i</mi></munder><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Y</mi><mi>i</mi></msub><mo>−</mo><mover><mi>Y</mi><mo accent="true">̂</mo></mover><mo stretchy="true" form="postfix">)</mo></mrow><mspace width="0.167em"></mspace><mfrac><mrow><mi>∂</mi><msub><mi>π</mi><mi>i</mi></msub></mrow><mrow><mi>∂</mi><mi>z</mi></mrow></mfrac><mspace width="0.278em"></mspace><mo>=</mo><mspace width="0.278em"></mspace><mo>−</mo><mspace width="0.167em"></mspace><mfrac><mn>1</mn><mi>B</mi></mfrac><munder><mo>∑</mo><mi>i</mi></munder><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Y</mi><mi>i</mi></msub><mo>−</mo><mover><mi>Y</mi><mo accent="true">̂</mo></mover><mo stretchy="true" form="postfix">)</mo></mrow><mspace width="0.167em"></mspace><mfrac><msub><mi>a</mi><mi>i</mi></msub><msubsup><mi>D</mi><mi>i</mi><mn>2</mn></msubsup></mfrac><mspace width="0.167em"></mspace><mo minsize="1.8" maxsize="1.8" stretchy="false" form="prefix">[</mo><mspace width="0.167em"></mspace><mfrac><mrow><mi>d</mi><msub><mi>λ</mi><mi>W</mi></msub></mrow><mrow><mi>d</mi><mi>z</mi></mrow></mfrac><mspace width="0.167em"></mspace><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>w</mi><mi>i</mi></msub><mo>−</mo><mi>W</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><msub><mi>λ</mi><mi>W</mi></msub><mspace width="0.167em"></mspace><mfrac><mrow><mi>d</mi><mi>W</mi></mrow><mrow><mi>d</mi><mi>z</mi></mrow></mfrac><mspace width="0.167em"></mspace><mo minsize="1.8" maxsize="1.8" stretchy="false" form="postfix">]</mo><mspace width="0.278em"></mspace></mrow></menclose><mi>.</mi></mrow><annotation encoding="application/x-tex">
\boxed{\;\frac{\partial g}{\partial z} \,=\, \frac{1}{B}\sum_i (Y_i - \hat Y)\,\frac{\partial \pi_i}{\partial z}
\;=\; -\,\frac{1}{B}\sum_i (Y_i - \hat Y)\,\frac{a_i}{D_i^2}\,\Big[\,\frac{d\lambda_W}{dz}\,(w_i - W) - \lambda_W\,\frac{dW}{dz}\,\Big]\; }.
</annotation></semantics></math></p>
<ol start="3" style="list-style-type: decimal">
<li>(Optional) With auxiliaries
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>X</mi><mi>i</mi></msub><annotation encoding="application/x-tex">X_i</annotation></semantics></math>
and centered
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mrow><mi>c</mi><mo>,</mo><mi>i</mi></mrow></msub><mo>=</mo><msub><mi>X</mi><mi>i</mi></msub><mo>−</mo><msub><mi>μ</mi><mi>x</mi></msub></mrow><annotation encoding="application/x-tex">X_{c,i}=X_i-\mu_x</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>i</mi></msub><mo>=</mo><mn>1</mn><mo>+</mo><msub><mi>λ</mi><mi>W</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>w</mi><mi>i</mi></msub><mo>−</mo><mi>W</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><msubsup><mi>X</mi><mrow><mi>c</mi><mo>,</mo><mi>i</mi></mrow><mi>⊤</mi></msubsup><msub><mi>λ</mi><mi>x</mi></msub></mrow><annotation encoding="application/x-tex">D_i = 1 + \lambda_W(w_i - W) + X_{c,i}^\top\lambda_x</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>∂</mi><msub><mi>D</mi><mi>i</mi></msub><mi>/</mi><mi>∂</mi><msub><mi>λ</mi><mi>x</mi></msub><mo>=</mo><msub><mi>X</mi><mrow><mi>c</mi><mo>,</mo><mi>i</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\partial D_i/\partial\lambda_x = X_{c,i}</annotation></semantics></math>,
hence
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><menclose notation="box"><mrow><mspace width="0.278em"></mspace><mfrac><mrow><mi>∂</mi><mi>g</mi></mrow><mrow><mi>∂</mi><msub><mi>λ</mi><mi>x</mi></msub></mrow></mfrac><mspace width="0.167em"></mspace><mo>=</mo><mspace width="0.167em"></mspace><mo>−</mo><mspace width="0.167em"></mspace><mfrac><mn>1</mn><mi>B</mi></mfrac><munder><mo>∑</mo><mi>i</mi></munder><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Y</mi><mi>i</mi></msub><mo>−</mo><mover><mi>Y</mi><mo accent="true">̂</mo></mover><mo stretchy="true" form="postfix">)</mo></mrow><mspace width="0.167em"></mspace><mfrac><msub><mi>a</mi><mi>i</mi></msub><msubsup><mi>D</mi><mi>i</mi><mn>2</mn></msubsup></mfrac><mspace width="0.167em"></mspace><msub><mi>X</mi><mrow><mi>c</mi><mo>,</mo><mi>i</mi></mrow></msub><mspace width="0.278em"></mspace></mrow></menclose><mi>.</mi></mrow><annotation encoding="application/x-tex">
\boxed{\;\frac{\partial g}{\partial \lambda_x} \,=\, -\,\frac{1}{B}\sum_i (Y_i - \hat Y)\,\frac{a_i}{D_i^2}\,X_{c,i}\; }.
</annotation></semantics></math>
</li>
</ol>
<p>Numerical safeguards. In practice we enforce
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>i</mi></msub><mo>≥</mo><mi>ε</mi></mrow><annotation encoding="application/x-tex">D_i \ge \varepsilon</annotation></semantics></math>
(e.g.,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ε</mi><mo>=</mo><msup><mn>10</mn><mrow><mo>−</mo><mn>8</mn></mrow></msup></mrow><annotation encoding="application/x-tex">\varepsilon=10^{-8}</annotation></semantics></math>)
when forming the gradient and the score contributions used in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>B</mi><mo accent="true">̂</mo></mover><annotation encoding="application/x-tex">\widehat B</annotation></semantics></math>.
The same guard is used in the estimating equations and in the analytic
Jacobian, ensuring consistency between
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>θ</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">F(\theta)</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>=</mo><mi>∂</mi><mi>F</mi><mi>/</mi><mi>∂</mi><mi>θ</mi></mrow><annotation encoding="application/x-tex">A=\partial F/\partial\theta</annotation></semantics></math>,
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>∇</mi><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>θ</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\nabla g(\theta)</annotation></semantics></math>.</p>
<p>Code mapping. The implementation uses these expressions when
<code>trim_cap = Inf</code> (smooth case) inside
<code>el_compute_delta_variance()</code>; otherwise it falls back to a
stabilized numeric gradient. See
<code>src_dev/engines/el/impl/variance.R</code> for the exact code paths
and <code>src_dev/engines/el/impl/jacobian.R</code> for the matching
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>.</p>
</div>
<div class="section level3">
<h3 id="solving-strategy-and-initialization">Solving Strategy and Initialization<a class="anchor" aria-label="anchor" href="#solving-strategy-and-initialization"></a>
</h3>
<ul>
<li>Unknowns are
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>β</mi><mo>,</mo><mi>z</mi><mo>,</mo><msub><mi>λ</mi><mi>x</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\theta = (\beta, z, \lambda_x)</annotation></semantics></math>
with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mo>=</mo><mrow><mi mathvariant="normal">p</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">g</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">s</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">W = \mathrm{plogis}(z)</annotation></semantics></math>.
We solve the full stacked system
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>θ</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">F(\theta) = 0</annotation></semantics></math>
via Newton with the analytic Jacobian
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>=</mo><mi>∂</mi><mi>F</mi><mi>/</mi><mi>∂</mi><mi>θ</mi></mrow><annotation encoding="application/x-tex">A = \partial F/\partial\theta</annotation></semantics></math>
using <code>nleqslv</code>.</li>
<li>Globalization and scaling: we rely on <code>nleqslv</code>’s
globalization (default <code>global = "dbldog"</code>) and enforce
denominator positivity
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>min</mo><mi>i</mi></msub><msub><mi>D</mi><mi>i</mi></msub><mo>≥</mo><mi>ε</mi></mrow><annotation encoding="application/x-tex">\min_i D_i \ge \varepsilon</annotation></semantics></math>)
within equation evaluations. Optional standardization of design matrices
improves conditioning.</li>
<li>Initialization: by default
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>β</mi><annotation encoding="application/x-tex">\beta</annotation></semantics></math>
starts at zeros in the scaled space (unless the user supplies
<code>start$beta</code>), and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>z</mi><annotation encoding="application/x-tex">z</annotation></semantics></math>
is seeded at
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">l</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">g</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">t</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mtext mathvariant="normal">observed response rate</mtext><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathrm{logit}(\text{observed response rate})</annotation></semantics></math>.
An internal last-chance Broyden retry may be used if Newton fails to
converge; this is not a user-facing mode.</li>
</ul>
</div>
<div class="section level3">
<h3 id="variance-assembly-and-numerical-stability">Variance Assembly and Numerical Stability<a class="anchor" aria-label="anchor" href="#variance-assembly-and-numerical-stability"></a>
</h3>
<p>Let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>=</mo><mfrac><mrow><mi>∂</mi><mi>F</mi></mrow><mrow><mi>∂</mi><mi>θ</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">A = \frac{\partial F}{\partial \theta}</annotation></semantics></math>
be the Jacobian of the estimating system. The delta variance uses the
sandwich
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>∇</mi><mi>g</mi><mspace width="0.167em"></mspace><msup><mi>A</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mi>B</mi><msup><mi>A</mi><mrow><mo>−</mo><mi>T</mi></mrow></msup><mspace width="0.167em"></mspace><mi>∇</mi><msup><mi>g</mi><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">\nabla g\,A^{-1} B A^{-T}\,\nabla g^T</annotation></semantics></math>.
Numerically we avoid forming an explicit inverse:</p>
<ul>
<li>Solve
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>X</mi><mo>=</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A X = B</annotation></semantics></math>
(first linear solve) and then
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mi>T</mi></msup><mi>Y</mi><mo>=</mo><msup><mi>X</mi><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">A^T Y = X^T</annotation></semantics></math>
(second linear solve), so that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Σ</mi><mi>θ</mi></msub><mo>=</mo><msup><mi>A</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mi>B</mi><msup><mi>A</mi><mrow><mo>−</mo><mi>T</mi></mrow></msup><mo>=</mo><msup><mi>Y</mi><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">\Sigma_\theta = A^{-1} B A^{-T} = Y^T</annotation></semantics></math>.
We lightly symmetrize
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Σ</mi><mi>θ</mi></msub><annotation encoding="application/x-tex">\Sigma_\theta</annotation></semantics></math>
to reduce round-off.</li>
<li>If the solves fail or yield non-finite/near-zero variance for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>Y</mi><mo accent="true">̂</mo></mover><annotation encoding="application/x-tex">\hat Y</annotation></semantics></math>,
we return NA with a clear warning. This occurs in regimes where the
first-order delta method is not applicable (e.g., trimming, very weak
identification). Bootstrap variance is recommended in those cases.</li>
</ul>
<div class="section level4">
<h4 id="variance-identities-used-in-code">Variance Identities (Used in Code)<a class="anchor" aria-label="anchor" href="#variance-identities-used-in-code"></a>
</h4>
<p>To avoid forming explicit inverses and to preserve non-negativity
when
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>
is PSD, we use the following algebraically equivalent identities:</p>
<ul>
<li>Mean (scalar):</li>
</ul>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">V</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">r</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mover><mi>Y</mi><mo accent="true">̂</mo></mover><mo stretchy="true" form="postfix">)</mo></mrow><mspace width="0.278em"></mspace><mo>=</mo><mspace width="0.278em"></mspace><mi>∇</mi><msup><mi>g</mi><mi>T</mi></msup><mspace width="0.167em"></mspace><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>A</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mi>B</mi><msup><mi>A</mi><mrow><mo>−</mo><mi>T</mi></mrow></msup><mo stretchy="true" form="postfix">)</mo></mrow><mspace width="0.167em"></mspace><mi>∇</mi><mi>g</mi><mspace width="0.278em"></mspace><mo>=</mo><mspace width="0.278em"></mspace><msup><mi>x</mi><mi>T</mi></msup><mi>B</mi><mi>x</mi><mo>,</mo><mspace width="1.0em"></mspace><mrow><mtext mathvariant="normal">where </mtext><mspace width="0.333em"></mspace></mrow><msup><mi>A</mi><mi>T</mi></msup><mi>x</mi><mo>=</mo><mi>∇</mi><mi>g</mi><mi>.</mi></mrow><annotation encoding="application/x-tex">
\mathrm{Var}(\hat Y) \;=\; \nabla g^T \,(A^{-1} B A^{-T})\, \nabla g \;=\; x^T B x,\quad \text{where } A^T x = \nabla g.
</annotation></semantics></math></p>
<ul>
<li>Response-model coefficients (matrix): let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>E</mi><mi>β</mi></msub><annotation encoding="application/x-tex">E_\beta</annotation></semantics></math>
select the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>β</mi><annotation encoding="application/x-tex">\beta</annotation></semantics></math>
coordinates in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>θ</mi><annotation encoding="application/x-tex">\theta</annotation></semantics></math>
(same ordering as the stacked system). Then</li>
</ul>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">V</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">r</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mover><mi>β</mi><mo accent="true">̂</mo></mover><mo stretchy="true" form="postfix">)</mo></mrow><mspace width="0.278em"></mspace><mo>=</mo><mspace width="0.278em"></mspace><mo minsize="1.2" maxsize="1.2" stretchy="false" form="prefix">(</mo><msup><mi>A</mi><mrow><mo>−</mo><mi>T</mi></mrow></msup><msub><mi>E</mi><mi>β</mi></msub><msup><mo minsize="1.2" maxsize="1.2" stretchy="false" form="postfix">)</mo><mi>T</mi></msup><mi>B</mi><mo minsize="1.2" maxsize="1.2" stretchy="false" form="prefix">(</mo><msup><mi>A</mi><mrow><mo>−</mo><mi>T</mi></mrow></msup><msub><mi>E</mi><mi>β</mi></msub><mo minsize="1.2" maxsize="1.2" stretchy="false" form="postfix">)</mo><mspace width="0.278em"></mspace><mo>=</mo><mspace width="0.278em"></mspace><msubsup><mi>X</mi><mi>β</mi><mi>T</mi></msubsup><mi>B</mi><msub><mi>X</mi><mi>β</mi></msub><mo>,</mo><mspace width="1.0em"></mspace><mrow><mtext mathvariant="normal">where </mtext><mspace width="0.333em"></mspace></mrow><msup><mi>A</mi><mi>T</mi></msup><msub><mi>X</mi><mi>β</mi></msub><mo>=</mo><msub><mi>E</mi><mi>β</mi></msub><mi>.</mi></mrow><annotation encoding="application/x-tex">
\mathrm{Var}(\hat\beta) \;=\; \big(A^{-T} E_\beta\big)^T B \big(A^{-T} E_\beta\big) \;=\; X_\beta^T B X_\beta,\quad \text{where } A^T X_\beta = E_\beta.
</annotation></semantics></math></p>
<p>Both identities equal the corresponding blocks of the sandwich
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mi>B</mi><msup><mi>A</mi><mrow><mo>−</mo><mi>T</mi></mrow></msup></mrow><annotation encoding="application/x-tex">A^{-1} B A^{-T}</annotation></semantics></math>
in exact arithmetic, but they are numerically more stable. The
implementation uses these two-solve forms for the mean and for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">V</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">r</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mover><mi>β</mi><mo accent="true">̂</mo></mover><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathrm{Var}(\hat\beta)</annotation></semantics></math>.</p>
<p>Remarks:</p>
<ul>
<li>The “minus sign” seen in some derivations for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><msup><mi>A</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">-A^{-1}</annotation></semantics></math>
cancels inside the sandwich.</li>
<li>With finite weight trimming,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>θ</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">g(\theta)</annotation></semantics></math>
is non-smooth; delta variance is not applicable. Prefer
<code>variance_method = "bootstrap"</code>.</li>
</ul>
</div>
</div>
<div class="section level3">
<h3 id="practical-identifiability-and-diagnostics">Practical Identifiability and Diagnostics<a class="anchor" aria-label="anchor" href="#practical-identifiability-and-diagnostics"></a>
</h3>
<p>The EL system balances the parametric response-model score against
calibration constraints. Identifiability can weaken in the following
situations:</p>
<ul>
<li>Weak or nearly collinear auxiliaries: if
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mi>i</mi></msub><mo>−</mo><msub><mi>μ</mi><mi>x</mi></msub></mrow><annotation encoding="application/x-tex">X_i-\mu_x</annotation></semantics></math>
have little variation or are nearly collinear with the response score
direction, the constraint block in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>=</mo><mi>∂</mi><mi>F</mi><mi>/</mi><mi>∂</mi><mi>θ</mi></mrow><annotation encoding="application/x-tex">A=\partial F/\partial\theta</annotation></semantics></math>
becomes ill-conditioned.</li>
<li>Inconsistent auxiliary means: if supplied
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>μ</mi><mi>x</mi></msub><annotation encoding="application/x-tex">\mu_x</annotation></semantics></math>
are far from what the respondent sample can support (under the response
model), denominators
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>D</mi><mi>i</mi></msub><annotation encoding="application/x-tex">D_i</annotation></semantics></math>
cluster near 0 and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>κ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>A</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\kappa(A)</annotation></semantics></math>
inflates.</li>
<li>Heavy nonresponse or near-boundary
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>W</mi><annotation encoding="application/x-tex">W</annotation></semantics></math>:
when
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>W</mi><annotation encoding="application/x-tex">W</annotation></semantics></math>
approaches 0 or 1,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>λ</mi><mi>W</mi></msub><mo>=</mo><mi>C</mi><mi>/</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><mi>W</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\lambda_W=C/(1-W)</annotation></semantics></math>
can spike and amplify sensitivity.</li>
</ul>
<p>Diagnostics exposed by the implementation help assess these
issues:</p>
<ul>
<li>
<code>jacobian_condition_number</code>
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>κ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>A</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\kappa(A)</annotation></semantics></math>),
<code>max_equation_residual</code>, denominator summaries (min, lower
quantiles, median), weight concentration (max share, top-5 share, ESS),
and the trimming fraction.</li>
</ul>
<p>Mitigations include standardizing predictors, trimming extreme
weights (<code>trim_cap</code>), adding informative response-model
predictors, and preferring bootstrap variance when diagnostics indicate
fragility.</p>
</div>
</div>
<div class="section level2">
<h2 id="survey-design-details">Survey Design Details<a class="anchor" aria-label="anchor" href="#survey-design-details"></a>
</h2>
<p>We extend QLS’s methodology to complex surveys in two complementary
ways:</p>
<ul>
<li><p><strong>Estimating equations with base weights:</strong> All sums
already include the base weight
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>a</mi><mi>i</mi></msub><annotation encoding="application/x-tex">a_i</annotation></semantics></math>;
set
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>a</mi><mi>i</mi></msub><annotation encoding="application/x-tex">a_i</annotation></semantics></math>
to the survey design weight for respondents. Totals
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>N</mi><mtext mathvariant="normal">pop</mtext></msub><annotation encoding="application/x-tex">N_{\text{pop}}</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mtext mathvariant="normal">resp_weighted</mtext></msub><mo>=</mo><mo>∑</mo><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">n_{\text{resp\_weighted}}=\sum a_i</annotation></semantics></math>
are computed from the design weights, which feeds into
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>λ</mi><mi>W</mi></msub><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>N</mi><mtext mathvariant="normal">pop</mtext></msub><mi>/</mi><msub><mi>n</mi><mtext mathvariant="normal">resp_weighted</mtext></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mi>/</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><mi>W</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\lambda_W = ((N_{\text{pop}}/n_{\text{resp\_weighted}}) - 1)/(1-W)</annotation></semantics></math>.</p></li>
<li>
<p><strong>Design-based variance for totals:</strong> Rather than
assuming i.i.d. sampling, we estimate
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>=</mo><mo>Var</mo><mrow><mo stretchy="true" form="prefix">(</mo><mo>∑</mo><msub><mi>U</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">B = \operatorname{Var}(\sum U_i)</annotation></semantics></math>
using the design:</p>
<ul>
<li>Create full-design score variables by placing the respondent
contributions
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>U</mi><mi>i</mi></msub><annotation encoding="application/x-tex">U_i</annotation></semantics></math>
on observed rows and zeros on nonrespondents.</li>
<li>Compute survey totals <code>svytotal(~U, design)</code> and take
their covariance via <code>vcov(...)</code> to obtain
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>B</mi><mo accent="true">̂</mo></mover><annotation encoding="application/x-tex">\widehat B</annotation></semantics></math>.</li>
</ul>
</li>
</ul>
<p>In short form, we compute</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>B</mi><mo accent="true">̂</mo></mover><mspace width="0.278em"></mspace><mo>=</mo><mspace width="0.278em"></mspace><mo>vcov</mo><mspace width="-0.167em"></mspace><mo minsize="1.2" maxsize="1.2" stretchy="false" form="prefix">(</mo><mspace width="0.167em"></mspace><mtext mathvariant="monospace">𝚜𝚟𝚢𝚝𝚘𝚝𝚊𝚕</mtext><mrow><mo stretchy="true" form="prefix">(</mo><mspace width="0.167em"></mspace><mo>∼</mo><mi>U</mi><mo>,</mo><mspace width="0.278em"></mspace><mtext mathvariant="monospace">𝚍𝚎𝚜𝚒𝚐𝚗</mtext><mspace width="0.167em"></mspace><mo stretchy="true" form="postfix">)</mo></mrow><mspace width="0.167em"></mspace><mo minsize="1.2" maxsize="1.2" stretchy="false" form="postfix">)</mo><mo>,</mo></mrow><annotation encoding="application/x-tex">
\widehat B \;=\; \operatorname{vcov}\!\big(\,\texttt{svytotal}(\,\sim U,\; \texttt{design}\,)\,\big),
</annotation></semantics></math></p>
<p>where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>U</mi><annotation encoding="application/x-tex">U</annotation></semantics></math>
stacks the respondent score contributions and zeros elsewhere.</p>
<p>This matches the paper’s guidance to adapt the likelihood/estimating
framework to stratification or unequal-probability sampling. Our
approach keeps the EL structure and uses standard survey inference tools
for the second-order properties.</p>
<p>Degrees-of-freedom: For confidence intervals, we use survey
degrees-of-freedom (t-quantiles) when a <code>survey.design</code> is
supplied; otherwise, we use normal quantiles.</p>
</div>
<div class="section level2">
<h2 id="scaling-and-unscaling">Scaling and Unscaling<a class="anchor" aria-label="anchor" href="#scaling-and-unscaling"></a>
</h2>
<div class="section level3">
<h3 id="scaling-optional-standardizetrue">Scaling (optional; <code>standardize=TRUE</code>)<a class="anchor" aria-label="anchor" href="#scaling-optional-standardizetrue"></a>
</h3>
<ul>
<li>
<strong>Compute a <code>nmar_scaling_recipe</code></strong>: for
each column
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>j</mi><annotation encoding="application/x-tex">j</annotation></semantics></math>
in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Z</mi><annotation encoding="application/x-tex">Z</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math>
(excluding intercept):
<ul>
<li>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mtext mathvariant="normal">mean</mtext><mi>j</mi></msub><annotation encoding="application/x-tex">\text{mean}_j</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mtext mathvariant="normal">sd</mtext><mi>j</mi></msub><annotation encoding="application/x-tex">\text{sd}_j</annotation></semantics></math>;
if
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext mathvariant="normal">sd</mtext><mi>j</mi></msub><mo>≈</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\text{sd}_j \approx 0</annotation></semantics></math>,
set
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext mathvariant="normal">sd</mtext><mi>j</mi></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\text{sd}_j = 1</annotation></semantics></math>
to avoid blow-ups.</li>
</ul>
</li>
<li>
<strong>Transform</strong>:
<ul>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Z</mi><mtext mathvariant="normal">scaled</mtext></msub><mrow><mo stretchy="true" form="prefix">[</mo><mo>,</mo><mi>j</mi><mo stretchy="true" form="postfix">]</mo></mrow><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Z</mi><mtext mathvariant="normal">un</mtext></msub><mrow><mo stretchy="true" form="prefix">[</mo><mo>,</mo><mi>j</mi><mo stretchy="true" form="postfix">]</mo></mrow><mo>−</mo><msub><mtext mathvariant="normal">mean</mtext><mi>j</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>/</mi><msub><mtext mathvariant="normal">sd</mtext><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">Z_{\text{scaled}}[,j] = (Z_{\text{un}}[,j] - \text{mean}_j) / \text{sd}_j</annotation></semantics></math></li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mtext mathvariant="normal">scaled</mtext></msub><mrow><mo stretchy="true" form="prefix">[</mo><mo>,</mo><mi>j</mi><mo stretchy="true" form="postfix">]</mo></mrow><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>X</mi><mtext mathvariant="normal">un</mtext></msub><mrow><mo stretchy="true" form="prefix">[</mo><mo>,</mo><mi>j</mi><mo stretchy="true" form="postfix">]</mo></mrow><mo>−</mo><msub><mtext mathvariant="normal">mean</mtext><mi>j</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>/</mi><msub><mtext mathvariant="normal">sd</mtext><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">X_{\text{scaled}}[,j] = (X_{\text{un}}[,j] - \text{mean}_j) / \text{sd}_j</annotation></semantics></math></li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>μ</mi><mrow><mi>x</mi><mo>,</mo><mtext mathvariant="normal">scaled</mtext></mrow></msub><mrow><mo stretchy="true" form="prefix">[</mo><mi>j</mi><mo stretchy="true" form="postfix">]</mo></mrow><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>μ</mi><mrow><mi>x</mi><mo>,</mo><mtext mathvariant="normal">un</mtext></mrow></msub><mrow><mo stretchy="true" form="prefix">[</mo><mi>j</mi><mo stretchy="true" form="postfix">]</mo></mrow><mo>−</mo><msub><mtext mathvariant="normal">mean</mtext><mi>j</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>/</mi><msub><mtext mathvariant="normal">sd</mtext><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">\mu_{x,\text{scaled}}[j] = (\mu_{x,\text{un}}[j] - \text{mean}_j) / \text{sd}_j</annotation></semantics></math></li>
</ul>
</li>
</ul>
</div>
<div class="section level3">
<h3 id="unscaling-beta-and-vcov">Unscaling
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>β</mi><annotation encoding="application/x-tex">\beta</annotation></semantics></math>
and vcov<a class="anchor" aria-label="anchor" href="#unscaling-beta-and-vcov"></a>
</h3>
<ul>
<li>
<strong>Construct linear map</strong>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>D</mi><annotation encoding="application/x-tex">D</annotation></semantics></math>
of size
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo>×</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">K \times K</annotation></semantics></math>:
<ul>
<li>For columns
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>≠</mo></mrow><annotation encoding="application/x-tex">j \neq</annotation></semantics></math>
intercept:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mrow><mo stretchy="true" form="prefix">[</mo><mi>j</mi><mo>,</mo><mi>j</mi><mo stretchy="true" form="postfix">]</mo></mrow><mo>=</mo><mn>1</mn><mi>/</mi><msub><mtext mathvariant="normal">sd</mtext><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">D[j,j] = 1/\text{sd}_j</annotation></semantics></math>
</li>
<li>For intercept: adjust to absorb centering:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mrow><mo stretchy="true" form="prefix">[</mo><mtext mathvariant="normal">intercept</mtext><mo>,</mo><mi>j</mi><mo stretchy="true" form="postfix">]</mo></mrow><mo>=</mo><mo>−</mo><msub><mtext mathvariant="normal">mean</mtext><mi>j</mi></msub><mi>/</mi><msub><mtext mathvariant="normal">sd</mtext><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">D[\text{intercept},j] = -\text{mean}_j/\text{sd}_j</annotation></semantics></math>
</li>
</ul>
</li>
<li>
<strong>Transform</strong>:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>β</mi><mtext mathvariant="normal">unscaled</mtext></msub><mo>=</mo><mi>D</mi><msub><mi>β</mi><mtext mathvariant="normal">scaled</mtext></msub></mrow><annotation encoding="application/x-tex">\beta_{\text{unscaled}} = D \beta_{\text{scaled}}</annotation></semantics></math>;
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext mathvariant="normal">vcov</mtext><mtext mathvariant="normal">unscaled</mtext></msub><mo>=</mo><mi>D</mi><mspace width="0.167em"></mspace><msub><mtext mathvariant="normal">vcov</mtext><mtext mathvariant="normal">scaled</mtext></msub><mspace width="0.167em"></mspace><msup><mi>D</mi><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">\text{vcov}_{\text{unscaled}} = D \, \text{vcov}_{\text{scaled}} \, D^T</annotation></semantics></math>
</li>
</ul>
<p>Code: centralized in <code>src_dev/shared/scaling.R</code>; engines
call <code><a href="../reference/validate_and_apply_nmar_scaling.html">validate_and_apply_nmar_scaling()</a></code> and
<code><a href="../reference/unscale_coefficients.html">unscale_coefficients()</a></code>.</p>
</div>
</div>
<div class="section level2">
<h2 id="bootstrap-variance">Bootstrap Variance<a class="anchor" aria-label="anchor" href="#bootstrap-variance"></a>
</h2>
<ul>
<li>
<strong>IID</strong>:
<ul>
<li>Resample rows with replacement
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>),
re-run estimator, compute
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtext mathvariant="normal">var</mtext><annotation encoding="application/x-tex">\text{var}</annotation></semantics></math>
of bootstrap
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>Y</mi><mo accent="true">̂</mo></mover><annotation encoding="application/x-tex">\hat{Y}</annotation></semantics></math>s;
warn if many failures; return
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msqrt><mtext mathvariant="normal">var</mtext></msqrt><annotation encoding="application/x-tex">\sqrt{\text{var}}</annotation></semantics></math>.</li>
</ul>
</li>
<li>
<strong>Survey</strong>:
<ul>
<li>Convert to bootstrap replicate-weight design via
<code><a href="https://bschneidr.github.io/svrep/reference/as_bootstrap_design.html" class="external-link">svrep::as_bootstrap_design</a></code>.</li>
<li>For each replicate, re-construct a temporary design and run
estimator; use <code><a href="https://rdrr.io/pkg/survey/man/svrVar.html" class="external-link">survey::svrVar</a></code> to compute variance of
replicate estimates (with scale/rscales).</li>
</ul>
</li>
</ul>
<p>Code mapping:</p>
<ul>
<li>Engine:
<code>el_engine(..., family, standardize, trim_cap, variance_method, ...)</code>
in <code>src_dev/engines/el/engine.R</code>
</li>
<li>Dispatch: <code>run_engine.nmar_engine_el(...)</code> in
<code>src_dev/engines/el/run_engine.R</code> adapts the formula and
forwards arguments to internal <code><a href="../reference/el.html">el()</a></code> methods.
<ul>
<li>
<code><a href="../reference/el_dataframe.html">el.data.frame()</a></code> / <code><a href="../reference/el_survey.html">el.survey.design()</a></code> in
<code>src_dev/engines/el/impl/dataframe.R</code> and
<code>src_dev/engines/el/impl/survey.R</code> prepare inputs, call
<code><a href="../reference/el_estimator_core.html">el_estimator_core()</a></code>, and wrap results.</li>
</ul>
</li>
<li>EL Core: <code>el_estimator_core(...)</code> in
<code>src_dev/engines/el/impl/core.R</code> runs:
<ul>
<li>Construct
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>θ</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">F(\theta)</annotation></semantics></math>
via <code><a href="../reference/el_build_equation_system.html">el_build_equation_system()</a></code>
(<code>src_dev/engines/el/impl/equations.R</code>).</li>
<li>Solve
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>θ</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">F(\theta)=0</annotation></semantics></math>
via <code>nleqslv</code> (Newton with analytic Jacobian when available,
Broyden fallback).</li>
<li>Build EL weights, mean, and diagnostics.</li>
</ul>
</li>
<li>Jacobian: <code>build_el_jacobian(...)</code> in
<code>src_dev/engines/el/impl/jacobian.R</code> returns analytic A
whenever family supplies <code>d2mu.deta2</code> (logit, probit).</li>
<li>Variance: <code>src_dev/engines/el/impl/variance.R</code> assembles
B and computes delta variance; bootstrap variance in
<code>src_dev/shared/bootstrap.R</code>.</li>
<li>S3 result: <code>src_dev/engines/el/s3.R</code> provides
print/tidy/glance and accessors.</li>
</ul>
<div class="section level3">
<h3 id="practical-notes">Practical Notes<a class="anchor" aria-label="anchor" href="#practical-notes"></a>
</h3>
<ul>
<li>Denominator guard:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>i</mi></msub><mo>≥</mo><mi>ε</mi></mrow><annotation encoding="application/x-tex">D_i \ge \varepsilon</annotation></semantics></math>
(default
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>10</mn><mrow><mo>−</mo><mn>8</mn></mrow></msup><annotation encoding="application/x-tex">10^{-8}</annotation></semantics></math>)
across all steps; diagnostics report extreme fractions.</li>
<li>Eta cap option: you can adjust the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>η</mi><annotation encoding="application/x-tex">\eta</annotation></semantics></math>
cap via <code>options(nmar.eta_cap = 60)</code> (default is 50) to suit
your data scale and link</li>
</ul>
</div>
<div class="section level3">
<h3 id="algorithm">Algorithm<a class="anchor" aria-label="anchor" href="#algorithm"></a>
</h3>
<p>We solve the full stacked system
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>θ</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">F(\theta)=0</annotation></semantics></math>
with Newton using the analytic Jacobian
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>=</mo><mi>∂</mi><mi>F</mi><mi>/</mi><mi>∂</mi><mi>θ</mi></mrow><annotation encoding="application/x-tex">A = \partial F/\partial \theta</annotation></semantics></math>
and globalization via <code>nleqslv</code>. Denominator positivity
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>min</mo><mi>i</mi></msub><msub><mi>D</mi><mi>i</mi></msub><mo>≥</mo><mi>ε</mi></mrow><annotation encoding="application/x-tex">\min_i D_i \ge \varepsilon</annotation></semantics></math>),
predictor standardization, and capped
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>η</mi><annotation encoding="application/x-tex">\eta</annotation></semantics></math>
ensure numerical stability. The estimating equations remain those of
Qin, Leung and Shao (2002).</p>
<pre class="text"><code>Input: Z (response design), X (auxiliary design), mu_x (population means),
       a (base weights), family (logit/probit), trim_cap, tolerances.
Initialize: beta = 0 in scaled space (or user-supplied start),
            z = logit(observed response rate), lambda_x = 0.
Repeat until convergence of F(theta) = 0:
  1) Compute eta = Z beta, w = linkinv(eta), W = plogis(z),
     lambda_W = ((N_pop/n_resp_weighted) - 1)/(1 - W).
  2) Evaluate full stacked equations using guarded denominators
     D_i = 1 + lambda_W (w_i - W) + (X_i - mu_x)^T lambda_x.
  3) Compute analytic Jacobian A = dF/dtheta.
  4) Newton step: solve A * step = -F with globalization; enforce min D_i &gt;= eps.
  5) Update theta &lt;- theta + step.
Return: p_i \propto a_i / D_i and \hat{Y} = Sum p_i Y_i / Sum p_i.</code></pre>
</div>
</div>
<div class="section level2">
<h2 id="references">References<a class="anchor" aria-label="anchor" href="#references"></a>
</h2>
<ul>
<li>Qin, J., Leung, D., and Shao, J. (2002). Estimation with survey data
under nonignorable nonresponse or informative sampling. Journal of the
American Statistical Association, 97(457), 193-200. <a href="doi:10.1198/016214502753479338" class="uri">doi:10.1198/016214502753479338</a>
</li>
</ul>
</div>
<div class="section level2">
<h2 id="appendix-el-engine-api-reference-user-facing">Appendix: EL Engine API Reference (User-Facing)<a class="anchor" aria-label="anchor" href="#appendix-el-engine-api-reference-user-facing"></a>
</h2>
<p>This appendix summarizes the key options of the EL engine
(constructor: <code><a href="../reference/el_engine.html">el_engine()</a></code>), their defaults, and recommended
usage.</p>
<ul>
<li>
<strong>family</strong> (default: “logit”)
<ul>
<li>Values: “logit”, “probit”, or a family object (list with
<code>name</code>, <code>linkinv</code>, <code>mu.eta</code>,
<code>d2mu.deta2</code>, <code>score_eta</code>).</li>
<li>Notes: We implement <code><a href="../reference/logit_family.html">logit_family()</a></code> and
<code><a href="../reference/probit_family.html">probit_family()</a></code>. Both use the log-likelihood score
<code>score_eta(eta, delta) = mu.eta(eta)/linkinv(eta)</code> (for
respondents), i.e.,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>∂</mi><mo>log</mo><mi>p</mi><mi>/</mi><mi>∂</mi><mi>η</mi></mrow><annotation encoding="application/x-tex">\partial\log p/\partial\eta</annotation></semantics></math>.
This matches the paper’s semiparametric MLE equations and keeps the
analytic Jacobian family-agnostic.</li>
</ul>
</li>
<li>
<strong>standardize</strong> (default: TRUE)
<ul>
<li>Standardize
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Z</mi><annotation encoding="application/x-tex">Z</annotation></semantics></math>/<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math>
(and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>μ</mi><mi>x</mi></msub><annotation encoding="application/x-tex">\mu_x</annotation></semantics></math>)
using a <code>nmar_scaling_recipe</code> for numerical stability.
Coefficients and vcov are unscaled after solving.</li>
</ul>
</li>
<li>
<strong>trim_cap</strong> (default: Inf)
<ul>
<li>Caps EL weights and redistributes mass. Improves robustness when
extreme weights arise. Prefer <code>variance_method = "bootstrap"</code>
when trimming is finite.</li>
</ul>
</li>
<li>
<strong>variance_method</strong> (default: “delta”)
<ul>
<li>“delta”: analytic delta method variance via two linear solves for
the sandwich. Returns NA with a clear warning when trimmed or when
solves are numerically fragile.</li>
<li>“bootstrap”: IID resampling or survey replicate weights via
<code>svrep</code>; preferred with trimming or near-boundary cases.</li>
</ul>
</li>
<li>bootstrap_reps (default: 500)
<ul>
<li>Number of bootstrap replicates for
<code>variance_method = "bootstrap"</code>. Increase for stability,
decrease for speed.</li>
</ul>
</li>
<li>
<strong>control</strong> (default: list())
<ul>
<li>Passed to <code>nleqslv</code> (e.g., <code>ftol</code>,
<code>xtol</code>, <code>maxit</code>).</li>
</ul>
</li>
</ul>
<div class="section level3">
<h3 id="diagnostics-glanceprint">Diagnostics (glance/print)<a class="anchor" aria-label="anchor" href="#diagnostics-glanceprint"></a>
</h3>
<ul>
<li>
<code>jacobian_condition_number</code>
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>κ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>A</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\kappa(A)</annotation></semantics></math>),
<code>max_equation_residual</code>, denominator summaries (min,
1%/5%/median), weight concentration (max share/top-5/ESS), and trimming
fraction. These help assess identification and numerical stability.</li>
</ul>
</div>
<div class="section level3">
<h3 id="recommended-settings">Recommended settings<a class="anchor" aria-label="anchor" href="#recommended-settings"></a>
</h3>
<ul>
<li>Default: <code>variance_method = "delta"</code>,
<code>standardize = TRUE</code>.</li>
<li>With trimming or suspected weak identification: prefer
<code>variance_method = "bootstrap"</code>.</li>
<li>If A appears ill-conditioned or delta returns NA: prefer
<code>variance_method = "bootstrap"</code> and report diagnostics (e.g.,
<code>jacobian_condition_number</code>). The package does not apply
ridge or pseudoinverse at runtime.</li>
</ul>
</div>
</div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by Maciej Beręsewicz, Igor Kołodziej, Mateusz Iwaniuk.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.3.</p>
</div>

    </footer>
</div>





  </body>
</html>
