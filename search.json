[{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2025 nmar authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (‚ÄúSoftware‚Äù), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED ‚Äú‚Äù, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/articles/developing_new_nmar_estimator.html","id":"developing-a-new-nmar-estimator-in-the-nmar-package","dir":"Articles","previous_headings":"","what":"Developing a New NMAR Estimator in the nmar Package","title":"Developing a New NMAR Estimator","text":"guide explains add integrate new ‚ÄëMissing‚Äë‚ÄëRandom (NMAR) statistical estimator nmar, following architecture used Empirical Likelihood (EL) engine, emphasizing clean separation concerns: Shared, reusable utilities live src_dev/shared/ (scaling, families, bootstrap, numerics, diagnostics). Estimator‚Äëspecific math code live src_dev/engines/<method>/. Repository conventions - Always edit source src_dev/; flat files R/ generated running Rscript build_r_folder.R. - changing src_dev/, regenerate roxygen outputs R -q -e \"devtools::document()\" confirm git status clean; keeps S3 registrations Rd files sync. - Use testthat v3 tests/testthat/ tests run R -q -e \"devtools::test()\" opening PR. - Use roxygen2 documentation; edit NAMESPACE directly.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/articles/developing_new_nmar_estimator.html","id":"general-guidelines","dir":"Articles","previous_headings":"Developing a New NMAR Estimator in the nmar Package","what":"0) General guidelines","title":"Developing a New NMAR Estimator","text":"Adhere functional programming style design patterns (writing pure functions, function factories, functionals, function operators) appropriate (eg. building systems equations) use unpredictable functions like sapply, use vapply purrr equivalents instead Avoid code duplication, reuse shared infrastructure much possible Develop loosely coupled, modular architecture, identify shareable, method-agnostic functionalities Use S3 OOP system Use constructor validator functions S3 objects Follow best software engineering practices, including SOLID, DRY, KISS, YAGNI, Separation Concerns, Principle Least Astonishment, Law Demeter?","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/articles/developing_new_nmar_estimator.html","id":"overview-of-the-package-flow","dir":"Articles","previous_headings":"Developing a New NMAR Estimator in the nmar Package","what":"1) Overview of the package flow","title":"Developing a New NMAR Estimator","text":"User workflow: User creates engine configuration (e.g., el_engine(...)). User calls nmar(formula = ..., data = ..., engine = <engine>). nmar() creates nmar_inputs via parse_nmar_spec(), validates validate_nmar_args() (using engine-specific traits), dispatches run_engine(engine, task) S3. *.data.frame(...) IID data *.survey.design(...) complex surveys method computes estimator returns result object class c(\"nmar_result_<method>\", \"nmar_result\") containing primary estimand supporting data S3 methods.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/articles/developing_new_nmar_estimator.html","id":"what-to-implement-for-a-new-estimator","dir":"Articles","previous_headings":"Developing a New NMAR Estimator in the nmar Package","what":"2) What to implement for a new estimator","title":"Developing a New NMAR Estimator","text":"Assume engine named <method> (e.g., exptilt2, abc, etc.). Create following files src_dev/engines/<method>/:","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/articles/developing_new_nmar_estimator.html","id":"engine-r-engine-constructor","dir":"Articles","previous_headings":"Developing a New NMAR Estimator in the nmar Package > 2) What to implement for a new estimator","what":"1) engine.R ‚Äî engine constructor","title":"Developing a New NMAR Estimator","text":"Important: add @keywords engine roxygen ### 2) run_engine.R ‚Äî run_engine method engine rely shared validation/traits infrastructure:","code":"method_engine <- function(...) { # Validate controls using validate_arguments.R as in exptilt.   validator_assert_choice(family, choices = c(\"logit\", \"probit\"), name = \"family\")    engine <- list(...)   class(engine) <- c(\"nmar_engine_method\", \"nmar_engine\")   engine } run_engine.nmar_engine_method <- function(engine, task) {   design <- prepare_nmar_design(     task,     standardize = engine$standardize,     auxiliary_means = engine$auxiliary_means,     include_response = TRUE,     include_auxiliary = TRUE   )    args <- c(     list(       data = design$survey_design %||% design$data,       formula = task$formula,       auxiliary_means = design$auxiliary_means,       standardize = design$standardize     ),     as.list(engine)   )    method_fn <- get(\"method\", mode = \"function\")   fit <- do.call(method_fn, args)   if (!inherits(fit, \"nmar_result_method\")) stop(\"Expected nmar_result_method.\")   fit } engine_traits.nmar_engine_method <- function(engine) {   utils::modifyList(     engine_traits.default(engine),     list(       allow_outcome_in_missingness = TRUE,      # customise as needed       allow_covariate_overlap = FALSE,       requires_single_outcome = TRUE     )   ) }"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/articles/developing_new_nmar_estimator.html","id":"implmethod-r-define-the-generic","dir":"Articles","previous_headings":"Developing a New NMAR Estimator in the nmar Package > 2) What to implement for a new estimator","what":"3) impl/<method>.R ‚Äî define the generic","title":"Developing a New NMAR Estimator","text":"","code":"#' @param data A data.frame or survey.design. #' @export method <- function(data, ...) UseMethod(\"method\")"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/articles/developing_new_nmar_estimator.html","id":"implmethod_dataframe-r-method-for-iid-data","dir":"Articles","previous_headings":"Developing a New NMAR Estimator in the nmar Package > 2) What to implement for a new estimator","what":"4) impl/<method>_dataframe.R ‚Äî method for IID data","title":"Developing a New NMAR Estimator","text":"","code":"#' @export method.data.frame <- function(data, formula, controls = list(), ...) { # Prepare inputs. You may adapt from EL‚Äôs el_prepare_inputs() pattern.   parsed <- build_method_inputs(data, formula, controls)   estimation_data <- parsed$data   obs_idx <- which(parsed$respondent_mask)  # Build design matrices supplied by the shared parser   Z_un <- parsed$missingness_design   X_un <- parsed$auxiliary_matrix   mu_x <- controls$auxiliary_means  # Shared scaling   sc <- validate_and_apply_nmar_scaling(     standardize = TRUE, has_aux = !is.null(X_un),     response_model_matrix_unscaled = Z_un,     aux_matrix_unscaled = if (is.null(X_un)) matrix(nrow = nrow(Z_un), ncol = 0) else X_un,     mu_x_unscaled = mu_x   )  # Solve on the scaled space (method-specific code)   fit <- method_solve_core(     full_data = estimation_data,     respondent_data = estimation_data[obs_idx, ],     response_model_matrix_scaled = sc$response_model_matrix_scaled,     auxiliary_matrix_scaled = sc$auxiliary_matrix_scaled,     mu_x_scaled = sc$mu_x_scaled,     controls = controls,     ...   )  # Wrap into a standard result object (see Section 5)   new_nmar_result_method(     estimate = fit$estimate,     std_error = fit$std_error,     coefficients = fit$model$coefficients,     vcov = fit$model$vcov,     diagnostics = fit$diagnostics   ) }"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/articles/developing_new_nmar_estimator.html","id":"implmethod_survey-r-method-for-survey-design","dir":"Articles","previous_headings":"Developing a New NMAR Estimator in the nmar Package > 2) What to implement for a new estimator","what":"5) impl/<method>_survey.R ‚Äî method for survey.design","title":"Developing a New NMAR Estimator","text":"Follow EL‚Äôs el.survey.design pattern: Subset respondents via observed_mask. Get respondent base weights via weights(resp_design) set N_pop <- sum(weights(design)). survey designs require design-based variance, may compute covariance score totals via svytotal(~ scores, design) followed vcov(). EL, analytical delta variance disabled; use bootstrap variance instead.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/articles/developing_new_nmar_estimator.html","id":"implmethod_equations-r-implmethod_jacobian-r-optional","dir":"Articles","previous_headings":"Developing a New NMAR Estimator in the nmar Package > 2) What to implement for a new estimator","what":"6) impl/<method>_equations.R / impl/<method>_jacobian.R (optional)","title":"Developing a New NMAR Estimator","text":"estimator uses system estimating equations analytic Jacobian (like EL), define document . Otherwise, keep method‚Äëspecific math (e.g., likelihood, gradients, constraints).","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/articles/developing_new_nmar_estimator.html","id":"implmethod_variance-r","dir":"Articles","previous_headings":"Developing a New NMAR Estimator in the nmar Package > 2) What to implement for a new estimator","what":"7) impl/<method>_variance.R","title":"Developing a New NMAR Estimator","text":"applicable method, assemble $= \\\\partial F/\\\\partial \\\\theta$, $B = Var(\\\\sum scores)$ gradient functional $g(\\\\theta)$ analytical delta variance. EL, analytical delta variance currently disabled engine returns NA requested. Add option use shared bootstrap variance helpers (bootstrap_variance()) IID survey designs.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/articles/developing_new_nmar_estimator.html","id":"implmethod_constructors-r","dir":"Articles","previous_headings":"Developing a New NMAR Estimator in the nmar Package > 2) What to implement for a new estimator","what":"8) impl/<method>_constructors.R","title":"Developing a New NMAR Estimator","text":"Call new_nmar_result() inside constructor object carries class c(\"nmar_result_<method>\", \"nmar_result\") shares standard layout: Scalar fields: estimate, estimate_name, se, converged. Lists: model (coefficients/vcov), weights_info, sample, inference, diagnostics, meta, extra. Populate components directly; add extra top-level aliases y_hat data_info. new_nmar_result() helper attach engine-specific class, add parent \"nmar_result\" class, route object validate_nmar_result() missing pieces filled safe defaults. rarely need call validate_nmar_result() directly unless constructing object hand. Minimal constructor example (inside src_dev/engines/<method>/impl/constructors.R):","code":"#' @keywords internal new_nmar_result_method <- function(estimate, se,                                    coefficients = NULL, vcov = NULL,                                    weights = NULL, sample = list(),                                    inference = list(variance_method = NA_character_,                                                     df = NA_real_,                                                     message = NA_character_),                                    diagnostics = list(),                                    meta = list(engine_name = \"method\", call = NULL, formula = NULL),                                    extra = list()) {   sample_defaults <- list(n_total = NA_integer_, n_respondents = NA_integer_,                           is_survey = FALSE, design = NULL, outcome_var = NA_character_)   sample <- utils::modifyList(sample_defaults, sample)   result <- new_nmar_result(     estimate = estimate,     estimate_name = sample$outcome_var,     se = se,     converged = TRUE,     model = list(coefficients = coefficients, vcov = vcov),     weights_info = list(values = weights, trimmed_fraction = NA_real_),     sample = list(n_total = sample$n_total,                   n_respondents = sample$n_respondents,                   is_survey = sample$is_survey,                   design = sample$design),     inference = inference,     diagnostics = diagnostics,     meta = meta,     extra = extra,     class = \"nmar_result_method\"   )   result }"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/articles/developing_new_nmar_estimator.html","id":"s3-r-s3-methods-for-your-result-class","dir":"Articles","previous_headings":"Developing a New NMAR Estimator in the nmar Package > 2) What to implement for a new estimator","what":"9) s3.R ‚Äî S3 methods for your result class","title":"Developing a New NMAR Estimator","text":"Implement (rely parent defaults): print.nmar_result_<method>(), summary.nmar_result_<method>() (optional). overriding, call NextMethod() first reuse parent output append estimator-specific details. estimate(), vcov(), confint(), tidy(), glance(): work box long populate shared schema. Optional accessors: weights(), fitted(), coef(), etc., engine exposes .","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/articles/developing_new_nmar_estimator.html","id":"reusing-shared-infrastructure","dir":"Articles","previous_headings":"Developing a New NMAR Estimator in the nmar Package","what":"3) Reusing shared infrastructure","title":"Developing a New NMAR Estimator","text":"Use shared modules src_dev/shared/:","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/articles/developing_new_nmar_estimator.html","id":"scaling","dir":"Articles","previous_headings":"Developing a New NMAR Estimator in the nmar Package > 3) Reusing shared infrastructure","what":"Scaling","title":"Developing a New NMAR Estimator","text":"validate_and_apply_nmar_scaling() standardize Z/X auxiliary means solving, returning nmar_scaling_recipe unscaling. unscale_coefficients() map scaled coefficients vcov back original scale reporting. Intercept never scaled; constant columns get sd=1. Engines may create recipe respondents‚Äëmatrices (EL) full/design matrices.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/articles/developing_new_nmar_estimator.html","id":"families-response-model","dir":"Articles","previous_headings":"Developing a New NMAR Estimator in the nmar Package > 3) Reusing shared infrastructure","what":"Families (response model)","title":"Developing a New NMAR Estimator","text":"logit_family() / probit_family() expose linkinv, mu.eta, d2mu.deta2, score_eta link‚Äëagnostic estimating equations Jacobians. Probit uses tail‚Äëstable log‚Äëratio phi/Phi.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/articles/developing_new_nmar_estimator.html","id":"bootstrap-variance","dir":"Articles","previous_headings":"Developing a New NMAR Estimator in the nmar Package > 3) Reusing shared infrastructure","what":"Bootstrap variance","title":"Developing a New NMAR Estimator","text":"bootstrap_variance() S3 generic methods data.frame survey.design. IID: resample rows rerun estimator. Survey: convert bootstrap replicate weights (svrep::as_bootstrap_design), feed replicate estimates design‚Äôs scale/rscales/mse directly survey::svrVar(). Engines may pass resample_guard(indices, data) IID case reject structurally invalid resamples (e.g., zero respondents). Guards rare simple; condition bootstrap ‚Äúacceptable‚Äù samples preferable letting estimator crash. \"strict\" (default): non‚Äëfinite replicate estimate error. \"omit\": failed replicates dropped corresponding rscales entries removed calling svrVar(). yields variance conditional ‚Äúsuccessful‚Äù replicates used cautiously.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/articles/developing_new_nmar_estimator.html","id":"engine-boundaries-and-naming","dir":"Articles","previous_headings":"Developing a New NMAR Estimator in the nmar Package > 3) Reusing shared infrastructure","what":"4) Engine boundaries and naming","title":"Developing a New NMAR Estimator","text":"call helpers engines‚Äô impl/ folders. Engines must depend src_dev/shared/ src_dev/engines/<method>/impl/. Prefix engine‚Äëspecific helpers <method>_ (e.g., el_... empirical likelihood) signal ownership avoid accidental reuse. parent S3 class nmar_result provides default methods (estimate, vcov, confint, tidy, glance, coef, fitted, weights, formula). Implement child print/summary need extra presentation.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/articles/developing_new_nmar_estimator.html","id":"developer-notes-nmar_result-schema-and-conventions","dir":"Articles","previous_headings":"Developing a New NMAR Estimator in the nmar Package > 3) Reusing shared infrastructure","what":"Developer notes: nmar_result schema and conventions","title":"Developing a New NMAR Estimator","text":"NMAR engines construct result objects via new_nmar_result() (thin engine wrapper new_nmar_result_el()). shared parent class following schema: y_hat: numeric scalar primary estimand (e.g., adjusted mean). estimate_name: label estimand (usually outcome variable name). se: numeric scalar standard error (may NA_real_ unavailable). converged: logical flag indicating solver success. coefficients: missingness-model coefficients (NULL), vcov: covariance matrix coefficients (NULL), engine-specific extras nuisance. values: unnormalised analysis weights masses engine‚Äôs scale, trimmed_fraction: fraction mass trimmed (numeric, NA_real_ used). n_total: population size analysis scale, n_respondents: number respondents, is_survey: logical; TRUE survey designs, design: underlying survey.design object applicable. variance_method: label \"none\" \"bootstrap\", df: degrees freedom t-based inference (numeric, may NA_real_), message: variance-related notes (character, may NA_character_). diagnostics: list engine-specific diagnostics (Jacobian condition numbers, equation residuals, denominator summaries, ). engine_name: short engine label (printing), call: outer nmar() call, formula: estimation formula. extra: list additional engine-specific objects (example nmar_scaling_recipe, fitted probabilities, cached raw structures). validate_nmar_result() single authority schema; normalises type-checks objects parent S3 methods can rely presence shape fields. Engine constructors supply whatever information let validator back-fill missing components safe defaults. Two conventions important engines want reuse parent methods: Weights: want weights() return analysis weights, store unnormalised masses weights_info$values population size sample$n_total. shared weights.nmar_result() method returns probability weights (scale = \"probability\") population weights (scale = \"population\") satisfy documented sum relationships (numerical precision), even trimming. Engines use different weighting concept can either map convention provide engine-specific weights.nmar_result_<method>(). Inference: parent methods (confint(), tidy(), glance(), coef(summary()), confint(summary())) use inference$df together sample$is_survey decide t- normal-based quantiles. Engines provide design-based degrees freedom populate df; can leave NA_real_, case normal-based inference used. long new engine adheres conventions calls new_nmar_result(), automatically inherits consistent interface vcov(), confint(), tidy(), glance(), coef(), fitted(), weights(), formula(), se(), summary(), print().","code":""},{"path":[]},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/articles/el_empirical_likelihood_theory.html","id":"units","dir":"Articles","previous_headings":"Notation","what":"Units","title":"Empirical Likelihood Theory","text":"=1,‚Ä¶,ni = 1, \\ldots, n index respondents (observed YY) Ri‚àà{0,1}R_i \\\\{0, 1\\} response indicator; work observed subset Ri=1R_i = 1","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/articles/el_empirical_likelihood_theory.html","id":"data","dir":"Articles","previous_headings":"Notation","what":"Data","title":"Empirical Likelihood Theory","text":"Outcome: YiY_i (observed Ri=1R_i = 1; missing otherwise) Response covariates: row vector Zi‚àà‚ÑùKZ_i \\\\mathbb{R}^K, model.matrix response RHS Auxiliary covariates: row vector Xi‚àà‚ÑùLX_i \\\\mathbb{R}^L (possibly L=0L = 0), auxiliary RHS (intercept) Population auxiliary means: Œºx‚àà‚ÑùL\\mu_x \\\\mathbb{R}^L, known; names match columns XX Mapping code: - response_model_matrix corresponds ZZ (includes intercept column) - auxiliary_matrix corresponds XX (intercept); center code X‚àíŒºxX - \\mu_x","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/articles/el_empirical_likelihood_theory.html","id":"response-model-family-functions","dir":"Articles","previous_headings":"Notation","what":"Response Model (Family functions)","title":"Empirical Likelihood Theory","text":"Linear predictor: Œ∑i=ZiŒ≤\\eta_i = Z_i \\, \\beta Response probability: wi‚â°g(Œ∑i)=linkinv(Œ∑i)w_i \\equiv g(\\eta_i) = \\mathrm{linkinv}(\\eta_i) First derivative: dwdŒ∑(Œ∑i)=ŒºŒ∑,=mu.eta(Œ∑i)\\dfrac{dw}{d\\eta}(\\eta_i) = \\mu_{\\eta,} = \\mathrm{mu.eta}(\\eta_i) Second derivative: d2wdŒ∑2(Œ∑i)=d2mu.deta2(Œ∑i)\\dfrac{d^2 w}{d\\eta^2}(\\eta_i) = \\mathrm{d2mu.deta2}(\\eta_i) linkinv, mu.eta, d2mu.deta2 refer chosen response family (logit probit). follow paper‚Äôs wiw_i notation response probability reserve piELp_i^{\\text{EL}} empirical-likelihood weights.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/articles/el_empirical_likelihood_theory.html","id":"weight-re-parameterization","dir":"Articles","previous_headings":"Notation","what":"Weight Re-parameterization","title":"Empirical Likelihood Theory","text":"W‚àà(0,1)W \\(0,1) nuisance scalar; parameterize via z=logit(W)z = \\text{logit}(W) stability set W=plogis(z)W = \\text{plogis}(z) ŒªW‚àà‚Ñù\\lambda_W \\\\mathbb{R} Œªx‚àà‚ÑùL\\lambda_x \\\\mathbb{R}^L EL Lagrange multipliers constraints; collected together Œ∏\\theta","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/articles/el_empirical_likelihood_theory.html","id":"el-weights","dir":"Articles","previous_headings":"Notation","what":"EL Weights","title":"Empirical Likelihood Theory","text":"Denominator: Di=1+ŒªW(wi‚àíW)+(Xi‚àíŒºx)TŒªxD_i = 1 + \\lambda_W (w_i - W) + (X_i - \\mu_x)^T \\lambda_x Base sampling weights: ai=1a_i = 1 (IID) ai=a_i = survey base weight respondent ii EL weights respondents: piEL‚àùai/Dip_i^{\\text{EL}} \\propto a_i / D_i (proportionality normalized totals )","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/articles/el_empirical_likelihood_theory.html","id":"estimator","dir":"Articles","previous_headings":"Notation","what":"Estimator","title":"Empirical Likelihood Theory","text":"YÃÇ=‚àëpiELYi/‚àëpiEL\\hat{Y} = \\sum p_i^{\\text{EL}} Y_i / \\sum p_i^{\\text{EL}}","code":""},{"path":[]},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/articles/el_empirical_likelihood_theory.html","id":"engines","dir":"Articles","previous_headings":"Notation","what":"Engines","title":"Empirical Likelihood Theory","text":"Family: ‚Äúlogit‚Äù (default) ‚Äúprobit‚Äù; use log-likelihood score w.r.t. Œ∑\\eta: si=‚àÇlogwi/‚àÇŒ∑i=ŒºŒ∑,/wis_i = \\partial\\log w_i/\\partial\\eta_i = \\mu_{\\eta,}/w_i (respondents, Œ¥i=1\\delta_i=1) Scaling: optional standardization design matrices Œºx\\mu_x via nmar_scaling_recipe","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/articles/el_empirical_likelihood_theory.html","id":"from-paper-to-implementation-core-ideas","dir":"Articles","previous_headings":"","what":"From Paper to Implementation: Core Ideas","title":"Empirical Likelihood Theory","text":"paper (Qin-Leung-Shao, JASA 2002) sets EL nonignorable response using: Zero-sum residual: ‚àëpiEL(wi‚àíW)=0\\sum p_i^{\\text{EL}} (w_i - W) = 0 Auxiliary moments: ‚àëpiEL(Xi‚àíŒºx)=0\\sum p_i^{\\text{EL}} (X_i - \\mu_x) = 0 response model probability wi=g(Œ∑i)w_i = g(\\eta_i), Œ∑i=ZiŒ≤\\eta_i = Z_i \\, \\beta code, adopt EL structure estimating equations. extend arbitrary ZZ XX, survey designs. uncertainty, provide bootstrap variance (IID resampling survey replicate-weight bootstrap). YÃÇ\\hat Y ratio--weights estimator, common normalization piEL‚àùai/Dip_i^{\\text{EL}} \\propto a_i/D_i cancels YÃÇ\\hat Y; relative weights matter (KKT multipliers Œª\\lambda enforce constraints; normalization affects common scale vanishes ratio).","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/articles/el_empirical_likelihood_theory.html","id":"closed-form-lambda_w-qls-eq--10-iid-path","dir":"Articles","previous_headings":"From Paper to Implementation: Core Ideas","what":"Closed-form ŒªW\\lambda_W (QLS Eq. 10, IID path)","title":"Empirical Likelihood Theory","text":"QLS derive ŒªW=(N/n‚àí1)/(1‚àíW)\\lambda_W = (N/n - 1)/(1-W) ai‚â°1a_i \\equiv 1 nn counts respondents. IID (data-frame) path reuse relation, generalized allow arbitrary base weights aia_i: Let nresp_weighted=‚àë:Ri=1ain_{\\text{resp\\_weighted}} = \\sum_{:R_i=1} a_i respondent-weighted total. Let NpopN_{\\text{pop}} analysis-scale population total (either nn user-supplied n_total). set ŒªW=Npop/nresp_weighted‚àí11‚àíW, \\lambda_W = \\frac{N_{\\text{pop}}/n_{\\text{resp\\_weighted}} - 1}{1 - W}, reduces original QLS formula ai‚â°1a_i \\equiv 1. closed form used IID path profile ŒªW\\lambda_W; complex survey designs instead treat ŒªW\\lambda_W free parameter solve jointly (Œ≤,W,Œªx)(\\beta, W, \\lambda_x) via design-weighted system described survey extension section.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/articles/el_empirical_likelihood_theory.html","id":"guarding-and-numerical-stability","dir":"Articles","previous_headings":"From Paper to Implementation: Core Ideas","what":"Guarding and Numerical Stability","title":"Empirical Likelihood Theory","text":"solve stacked system consistent guarding policy across equations, Jacobian, post-solution: Cap Œ∑\\eta: Œ∑‚Üêmax{min(Œ∑,Œ∑max),‚àíŒ∑max}\\eta \\leftarrow \\max\\{\\min(\\eta,\\,\\eta_{\\max}),\\,-\\eta_{\\max}\\} Compute w=linkinv(Œ∑)w = \\mathrm{linkinv}(\\eta); clip ww [10‚àí12,1‚àí10‚àí12][10^{-12}, 1-10^{-12}] used ratios Guard denominators: Di‚Üêmax{Di,Œ¥}D_i \\leftarrow \\max\\{D_i,\\,\\delta\\} small Œ¥>0\\delta>0 Jacobian, multiply terms involving ‚àÇ(1/Di)/‚àÇ‚ãÖ\\partial(1/D_i)/\\partial\\cdot ùüô{Diraw>Œ¥}\\mathbb{1}\\{D_i^{\\text{raw}} > \\delta\\} analytic Jacobian matches piecewise-smooth equations solved probit link, si(Œ∑)=‚àÇlogw/‚àÇŒ∑=œï(Œ∑)/Œ¶(Œ∑)s_i(\\eta) = \\partial\\log w/\\partial\\eta = \\phi(\\eta)/\\Phi(\\eta) (Mills ratio) computed log domain stability; derivative dsidŒ∑=‚àíŒ∑si‚àísi2\\frac{d s_i}{d\\eta} = -\\eta\\,s_i - s_i^2.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/articles/el_empirical_likelihood_theory.html","id":"equation-crosswalk-qls-2002---this-vignettecode","dir":"Articles","previous_headings":"From Paper to Implementation: Core Ideas","what":"Equation Crosswalk (QLS 2002 -> This Vignette/Code)","title":"Empirical Likelihood Theory","text":"QLS (5): Discrete mass form pip_i two multipliers -> Di=1+ŒªW(wi‚àíW)+(Xi‚àíŒºx)TŒªxD_i = 1 + \\lambda_W (w_i - W) + (X_i - \\mu_x)^T \\lambda_x piEL‚àùai/Dip_i^{\\text{EL}} \\propto a_i/D_i. QLS (7): ‚àëxi‚àíx‚Äæ1+‚ãØ=0\\sum \\dfrac{x_i - \\bar x}{1 + \\cdots} = 0 -> auxiliary constraints ‚àëai(Xi‚àíŒºx)/Di=0\\sum a_i (X_i - \\mu_x)/D_i = 0. QLS (8): ‚àëwi‚àíW1+‚ãØ=0\\sum \\dfrac{w_i - W}{1 + \\cdots} = 0 -> WW-equation ‚àëai(wi‚àíW)/Di=0\\sum a_i (w_i - W)/D_i = 0. QLS (10): ŒªÃÇ2=(N/n‚àí1)/(1‚àíW)\\hat{\\lambda}_2 = (N/n - 1)/(1 - W) -> IID path set ŒªW=((Npop/nresp_weighted)‚àí1)/(1‚àíW)\\lambda_W = ((N_{\\text{pop}}/n_{\\text{resp\\_weighted}}) - 1)/(1 - W); survey path ŒªW\\lambda_W solved additional linkage equation gW(1)g_W^{(1)}. Estimator YÃÇ\\hat Y QLS -> ratio YÃÇ=‚àëpiELYi/‚àëpiEL\\hat Y = \\sum p_i^{\\mathrm{EL}} Y_i/\\sum p_i^{\\mathrm{EL}} using piEL‚àùai/Dip_i^{\\mathrm{EL}} \\propto a_i/D_i.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/articles/el_empirical_likelihood_theory.html","id":"likelihood-and-profiling-sketch","dir":"Articles","previous_headings":"From Paper to Implementation: Core Ideas","what":"Likelihood and Profiling (sketch)","title":"Empirical Likelihood Theory","text":"paper‚Äôs semiparametric likelihood (Eq. (2)) combines response mechanism wi=g(Œ∑i)w_i = g(\\eta_i) nonparametric distribution FF (Y,X)(Y,X): ‚Ñí(Œ≤,W,F)‚àù‚àè=1nw(Yi,Xi;Œ≤)dF(Yi,Xi)√ó(1‚àíW)N‚àín, \\mathcal{L}(\\beta, W, F)  \\;\\propto\\; \\prod_{=1}^{n} w(Y_i, X_i; \\beta) \\, dF(Y_i, X_i)  \\;\\times\\; (1 - W)^{N - n}, subject () ‚à´dF=1\\int dF = 1, (ii) ‚à´XdF=Œºx\\int X \\, dF = \\mu_x, (iii) ‚à´w(Y,X;Œ≤)dF=W\\int w(Y,X;\\beta) \\, dF = W. Discretizing FF observed respondents assigning unknown masses pip_i introducing multipliers Œª\\lambda, KKT conditions yield familiar EL weight form denominator Di=1+ŒªW(wi‚àíW)+(Xi‚àíŒºx)‚ä§Œªx, D_i \\;=\\; 1 + \\lambda_W (w_i - W) + (X_i - \\mu_x)^\\top \\lambda_x, , base weights aia_i, working weights piEL‚àùai/Dip_i^{\\text{EL}} \\propto a_i / D_i. Remark conditioning: QLS‚Äôs Eq. (2) writes first product ‚àè[w(yi,xi;Œ≤)dF(yi,xi)/W]\\prod_i [\\, w(y_i,x_i;\\beta)\\,dF(y_i,x_i)/W\\,] explicitly represents likelihood (Yi,Xi)(Y_i,X_i) conditional Ri=1R_i=1. Multiplying binomial term Wn(1‚àíW)N‚àínW^n(1-W)^{N-n} yields overall likelihood W‚àínW^{-n} first factor cancels WnW^n second. factorizations lead estimating equations profiled log-likelihood form used subsequently QLS introducing multipliers.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/articles/el_empirical_likelihood_theory.html","id":"kkt-and-denominator-details","dir":"Articles","previous_headings":"From Paper to Implementation: Core Ideas","what":"KKT and Denominator (details)","title":"Empirical Likelihood Theory","text":"Introducing Lagrange multipliers (Œª0,Œªx,ŒªW)(\\lambda_0,\\lambda_x,\\lambda_W) constraints profiling pip_i‚Äôs gives KKT stationarity conditions (survey-weighted setting, base weights aia_i acting multiplicities empirical likelihood) ‚àÇ‚àÇpi[‚àëjajlogpj‚àíŒª0(‚àëjpj‚àí1)‚àíŒªxT‚àëjpj(Xj‚àíŒºx)‚àíŒªW‚àëjpj(wj‚àíW)]=0, \\frac{\\partial}{\\partial p_i} \\Big[ \\sum_j a_j\\, \\log p_j - \\lambda_0 (\\sum_j p_j - 1) - \\lambda_x^T \\sum_j p_j (X_j - \\mu_x) - \\lambda_W \\sum_j p_j (w_j - W) \\Big] = 0, solve pi‚àù11+ŒªxT(Xi‚àíŒºx)+ŒªW(wi‚àíW)‚â°1Di. p_i \\;\\propto\\; \\frac{1}{\\,1 + \\lambda_x^T (X_i-\\mu_x) + \\lambda_W (w_i - W)\\,} \\;\\equiv\\; \\frac{1}{D_i}. Normalizing enforce ‚àëpi=1\\sum p_i = 1 yields pi=Di‚àí1‚àëjDj‚àí1p_i = \\frac{D_i^{-1}}{\\sum_j D_j^{-1}}. presence base sampling weights aia_i (survey designs), derivation gives natural generalization piEL‚àùaiDiwithDi=1+ŒªW(wi‚àíW)+(Xi‚àíŒºx)TŒªx. p_i^{\\text{EL}} \\;\\propto\\; \\frac{a_i}{D_i} \\quad \\text{} \\quad D_i = 1 + \\lambda_W (w_i - W) + (X_i - \\mu_x)^T\\lambda_x. exactly working form used estimator. survey base weights, working masses proportional ai/Dia_i/D_i, piEL‚àùai/Dip_i^{\\text{EL}} \\propto a_i/D_i. EL weights piELp_i^{\\text{EL}} used build mean estimator YÃÇ=‚àëipiELYi‚àëipiEL. \\hat Y \\;=\\; \\frac{\\sum_i p_i^{\\text{EL}} Y_i}{\\sum_i p_i^{\\text{EL}}}. remaining unknowns (Œ≤,W,Œªx)(\\beta, W, \\lambda_x) determined estimating equations .","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/articles/el_empirical_likelihood_theory.html","id":"clarification-relationship-between-w-and-lambda_w","dir":"Articles","previous_headings":"From Paper to Implementation: Core Ideas","what":"Clarification: Relationship Between WW and ŒªW\\lambda_W","title":"Empirical Likelihood Theory","text":"IID (data-frame) path, EL multiplier probability constraint expressed ŒªW=C1‚àíW,C=Npopnresp_weighted‚àí1 W=plogis(z). \\lambda_W = \\frac{C}{1 - W}, \\quad \\text{} C = \\frac{N_{\\text{pop}}}{n_{\\text{resp\\_weighted}}} - 1 \\text{ } W = \\text{plogis}(z). Intuition: EL KKT system, constraint ‚àëpiEL(wi‚àíW)=0\\sum p_i^{\\text{EL}} (w_i - W) = 0 sits alongside normalization (optionally) auxiliary constraints. Incorporating base weights aia_i ratio population respondent totals induces scaling multiplier linked mass constraint. Writing ŒªW\\lambda_W scaled form keeps parameter numerically stable scale lets derivative structure (respect zz via WW) handled cleanly. consistent EL structure baseline mass nresp_weightedn_{\\text{resp\\_weighted}} ‚Äúfull population‚Äù target NpopN_{\\text{pop}}, exactly IID code path uses match normalization implied base weights. Derivation sketch (KKT, IID case): discretized semiparametric likelihood (QLS, 2002) maximizes, unknown masses {pi}\\{p_i\\} observed points (Œ≤,W)(\\beta, W), ‚Ñì(Œ≤,W,Œªx,ŒªW)=‚àë=1nlogwi(Œ≤)+(Npop‚àínresp_weighted)log(1‚àíW)‚àí‚àë=1nlog(1+(Xi‚àíŒºx)‚ä§Œªx+ŒªW(wi‚àíW)), \\ell(\\beta, W, \\lambda_x, \\lambda_W)  \\;=\\; \\sum_{=1}^{n} \\log w_i(\\beta) \\; +\\; (N_{\\text{pop}} - n_{\\text{resp\\_weighted}}) \\log(1 - W) \\; -\\; \\sum_{=1}^{n} \\log\\!\\Big(1 + (X_i - \\mu_x)^\\top \\lambda_x + \\lambda_W (w_i - W)\\Big), subject normalization moment constraints generate EL denominator. weighted-EL variant work unnormalized respondent weights proportional ai/Dia_i/D_i; choosing conventional normalization ‚àë=1naiDi=nresp_weighted‚â°‚àë=1nai \\sum_{=1}^{n} \\frac{a_i}{D_i} \\,=\\, n_{\\text{resp\\_weighted}} \\equiv \\sum_{=1}^{n} a_i recovers estimating system (common normalization cancels ratio estimator YÃÇ=‚àëpiYi/‚àëpi\\hat Y = \\sum p_i Y_i/\\sum p_i). Taking derivatives (KKT conditions) using ‚àÇ/‚àÇW\\partial/\\partial W second third terms produces opposing contributions, one obtains system equivalent QLS (7)-(10). particular, first-order condition respect multiplier associated WW-constraint yields, together derivative respect WW, closed form ŒªW=Npopnresp_weighted‚àí11‚àíW=C1‚àíW, \\lambda_W  \\;=\\; \\frac{\\tfrac{N_{\\text{pop}}}{n_{\\text{resp\\_weighted}}} - 1}{1 - W} \\;=\\; \\frac{C}{1 - W}, coincides QLS (10) ai‚â°1a_i \\equiv 1. closed-form relationship used IID EL implementation profile ŒªW\\lambda_W. survey-design path, contrast, ŒªW\\lambda_W treated explicit unknown linkage WW ŒªW\\lambda_W enforced additional equation gW(1)(Œ≤,W,ŒªW,Œªx)=T01‚àíW‚àíŒªW‚àë‚ààRdiDi=0, g_W^{(1)}(\\beta, W, \\lambda_W, \\lambda_x) \\;=\\; \\frac{T_0}{1 - W} - \\lambda_W \\sum_{\\R} \\frac{d_i}{D_i} = 0, T0=Npop‚àí‚àë‚ààRdiT_0 = N_{\\mathrm{pop}} - \\sum_{\\R} d_i did_i design weights. QLS simple-random-sampling limit (equal weights, auxiliaries) system reduces closed-form relation.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/articles/el_empirical_likelihood_theory.html","id":"estimating-equations","dir":"Articles","previous_headings":"","what":"Estimating Equations","title":"Empirical Likelihood Theory","text":"Unknown parameters: Œ≤‚àà‚ÑùK\\beta \\\\mathbb{R}^K, z‚àà‚Ñùz \\\\mathbb{R} (W=plogis(z)W = \\text{plogis}(z)), Œªx‚àà‚ÑùL\\lambda_x \\\\mathbb{R}^L; define Œ∏=(Œ≤,z,Œªx)\\theta = (\\beta, z, \\lambda_x). Define wi=linkinv(Œ∑i)w_i = \\mathrm{linkinv}(\\eta_i) ŒºŒ∑,=dwdŒ∑(Œ∑i)\\mu_{\\eta,} = \\frac{dw}{d\\eta}(\\eta_i) (denoted mu.eta(eta_i) code). IID (data-frame) path base weights ai‚â°1a_i \\equiv 1, can use closed-form Qin-Leung-Shao (QLS) relation WW EL multiplier response constraint. Writing C=Npopnresp_weighted‚àí1,nresp_weighted=‚àëiai,Npop=n, C = \\frac{N_{\\text{pop}}}{n_{\\text{resp\\_weighted}}} - 1,\\qquad n_{\\text{resp\\_weighted}} = \\sum_i a_i,\\qquad N_{\\text{pop}} = n,  QLS show ŒªW=C1‚àíW=Npop/nresp_weighted‚àí11‚àíW. \\lambda_W = \\frac{C}{1 - W} = \\frac{N_{\\text{pop}}/n_{\\text{resp\\_weighted}} - 1}{1 - W}.  IID implementation follows profiles ŒªW\\lambda_W: unknowns Newton solver (Œ≤,z,Œªx)(\\beta, z, \\lambda_x). survey path, base weights general design weights ai=dia_i = d_i corresponding QLS-style relation longer simple closed form. case treat ŒªW\\lambda_W additional free parameter include separate equation linking ŒªW\\lambda_W WW (see ‚ÄúSurvey extension‚Äù section ). Denominator: Di=1+ŒªW(wi‚àíW)+(Xi‚àíŒºx)TŒªxD_i = 1 + \\lambda_W (w_i - W) + (X_i - \\mu_x)^T \\lambda_x, Di‚â•œµD_i \\geq \\epsilon enforced numerically. Define score term si=ŒºŒ∑,/wis_i = \\mu_{\\eta,}/w_i (unit-level contribution log-likelihood score respect Œ∑\\eta). logit, si=1‚àíwis_i = 1 - w_i; probit, sis_i behaves like œï(Œ∑i)/Œ¶(Œ∑i)\\phi(\\eta_i)/\\Phi(\\eta_i) wiw_i bounded away 0 via clipping (implemented). Intuition (score appears): respondent observe Ri=1R_i=1, Bernoulli log-likelihood contribution response model logwi(Œ∑i)\\log w_i(\\eta_i). Differentiating w.r.t. linear predictor gives ‚àÇ‚àÇŒ∑ilogwi(Œ∑i)=1widwidŒ∑i=ŒºŒ∑,iwi‚â°si. \\frac{\\partial}{\\partial\\eta_i} \\log w_i(\\eta_i) \\,=\\, \\frac{1}{w_i}\\, \\frac{dw_i}{d\\eta_i} \\,=\\, \\frac{\\mu_{\\eta,}}{w_i} \\;\\equiv\\; s_i. Thus sis_i measures local sensitivity observed-response likelihood Œ∑i\\eta_i. logit family, ŒºŒ∑,=wi(1‚àíwi)\\mu_{\\eta,}=w_i(1-w_i) si=1‚àíwis_i=1-w_i-familiar residual-like term; probit family, si=œï(Œ∑i)/Œ¶(Œ∑i)s_i=\\phi(\\eta_i)/\\Phi(\\eta_i), (inverse) Mills ratio. EL Œ≤\\beta-equations balance likelihood score EL penalty term ŒªWŒºŒ∑,/Di\\lambda_W\\,\\mu_{\\eta,}/D_i, enforcing calibration constraints fitting response model.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/articles/el_empirical_likelihood_theory.html","id":"the-system-of-estimating-equations-ftheta-0","dir":"Articles","previous_headings":"Estimating Equations","what":"The System of Estimating Equations F(Œ∏)=0F(\\theta) = 0","title":"Empirical Likelihood Theory","text":"Œ≤\\beta-equations (KK equations): ‚àëaiZi[si‚àíŒªWŒºŒ∑,/Di]=0\\sum a_i Z_i [s_i - \\lambda_W \\mu_{\\eta,} / D_i] = 0 W-equation (1 equation): ‚àëai(wi‚àíW)/Di=0\\sum a_i (w_i - W) / D_i = 0 Auxiliary constraints (LL equations): ‚àëai(Xi‚àíŒºx)/Di=0\\sum a_i (X_i - \\mu_x) / D_i = 0 exactly el_build_equation_system constructs function code (src_dev/engines/el/impl/equations.R). Intuition: Œ≤\\beta-equations equate score respondent log-likelihood EL penalty term ŒªWŒºŒ∑,/Di\\lambda_W \\mu_{\\eta,}/D_i; WW-equation centers modeled response probabilities around unconditional mean WW EL weights; auxiliary equations calibrate centered auxiliaries zero mean EL weights.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/articles/el_empirical_likelihood_theory.html","id":"remarks","dir":"Articles","previous_headings":"Estimating Equations","what":"Remarks","title":"Empirical Likelihood Theory","text":"logit probit, sis_i log-likelihood score ‚àÇlogwi/‚àÇŒ∑i=ŒºŒ∑,/wi\\partial\\log w_i/\\partial\\eta_i = \\mu_{\\eta,}/w_i (equals 1‚àíwi1-w_i logit; behaves like œï/Œ¶\\phi/\\Phi probit wiw_i clipped away 0). follows paper‚Äôs MLE derivation; EL constraints supply nonparametric part.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/articles/el_empirical_likelihood_theory.html","id":"survey-extension-design-weighted-qls-system","dir":"Articles","previous_headings":"","what":"Survey extension: design-weighted QLS system","title":"Empirical Likelihood Theory","text":"original QLS paper derives equations simple random sampling, respondent equal weight. practice often work complex survey designs design weights di‚âà1/œÄid_i \\approx 1/\\pi_i, œÄi\\pi_i inclusion probability unit ii. implementation extend QLS system using design-weighted empirical likelihood: respondents ‚ààRi \\R use base weights ai=dia_i = d_i. approximate unknown distribution (Y,X)(Y,X) discrete measure FEL()=‚àë‚ààRdipiùüè{(yi,xi)‚àà}, F_{\\text{EL}}() = \\sum_{\\R} d_i p_i\\,\\mathbf{1}\\{(y_i,x_i)\\\\},  pi‚â•0p_i \\ge 0 ‚àëidipi=1\\sum_i d_i p_i = 1. Expectations FF represented design-weighted sums ‚àëidipi(‚ãÖ)\\sum_i d_i p_i(\\cdot). impose following constraints, design-weighted analogues QLS (3): Normalization: ‚àë‚ààRdipi=1. \\sum_{\\R} d_i p_i = 1. Response-rate constraint: ‚àë‚ààRdipi(wi(Œ∏)‚àíW)=0. \\sum_{\\R} d_i p_i \\bigl(w_i(\\theta) - W\\bigr) = 0. Auxiliary constraints (vector case): ‚àë‚ààRdipi(Xi‚àíŒºx)=0. \\sum_{\\R} d_i p_i (X_i - \\mu_x) = 0. Maximizing design-weighted pseudo-likelihood constraints yields EL weights tilted form QLS: pi(Œ∏,W,Œªx,ŒªW)‚àù1Di,Di=1+ŒªW(wi(Œ∏)‚àíW)+(Xi‚àíŒºx)‚ä§Œªx, p_i(\\theta, W, \\lambda_x, \\lambda_W) \\;\\propto\\; \\frac{1}{D_i},\\qquad D_i = 1 + \\lambda_W\\bigl(w_i(\\theta) - W\\bigr) + (X_i - \\mu_x)^\\top \\lambda_x,  proportionality constant chosen ‚àëidipi=1\\sum_i d_i p_i = 1. implementation unnormalized EL masses mi=diDi, m_i = \\frac{d_i}{D_i},  probability-scale weights piEL=mi/‚àëjmjp_i^{\\mathrm{EL}} = m_i / \\sum_j m_j. corresponding design-weighted QLS estimating system (Œ≤,W,ŒªW,Œªx)(\\beta, W, \\lambda_W, \\lambda_x) can written : Auxiliary block: gx(Œ≤,W,ŒªW,Œªx)=‚àë‚ààRdiXi‚àíŒºxDi=0. g_x(\\beta, W, \\lambda_W, \\lambda_x) = \\sum_{\\R} d_i \\frac{X_i - \\mu_x}{D_i} = 0. Response-rate constraint: gW(2)(Œ≤,W,ŒªW,Œªx)=‚àë‚ààRdiwi(Œ≤)‚àíWDi=0. g_W^{(2)}(\\beta, W, \\lambda_W, \\lambda_x) = \\sum_{\\R} d_i \\frac{w_i(\\beta) - W}{D_i} = 0. Score equations Œ≤\\beta: gŒ≤(Œ≤,W,ŒªW,Œªx)=‚àë‚ààRdi[‚àÇlogwi(Œ≤)‚àÇŒ≤‚àíŒªW1Di‚àÇwi(Œ≤)‚àÇŒ≤]=0. g_\\beta(\\beta, W, \\lambda_W, \\lambda_x) = \\sum_{\\R} d_i \\left[     \\frac{\\partial \\log w_i(\\beta)}{\\partial \\beta}     - \\lambda_W \\frac{1}{D_i}       \\frac{\\partial w_i(\\beta)}{\\partial \\beta}   \\right] = 0. Linkage ŒªW\\lambda_W nonrespondent total: gW(1)(Œ≤,W,ŒªW,Œªx)=T01‚àíW‚àíŒªW‚àë‚ààRdiDi=0, g_W^{(1)}(\\beta, W, \\lambda_W, \\lambda_x) = \\frac{T_0}{1 - W} - \\lambda_W \\sum_{\\R} \\frac{d_i}{D_i} = 0,  T0=Npop‚àí‚àë‚ààRdiT_0 = N_{\\mathrm{pop}} - \\sum_{\\R} d_i analysis scale. code system implemented el_build_equation_system_survey() src_dev/engines/el/impl/equations.R. parameter vector Œ∏survey=(Œ≤,z,ŒªW,Œªx),z=logit(W), \\theta_{\\text{survey}} = (\\beta, z, \\lambda_W, \\lambda_x),\\qquad z = \\operatorname{logit}(W),  solver treats ŒªW\\lambda_W explicit unknown. design weights equal NpopN_{\\text{pop}} respondent count match simple random sampling setup, system reduces exactly original QLS equations (6)-(10). survey designs build analytic Jacobian design-weighted system whenever response family supplies second derivative d2mu.deta2 (logit probit). Jacobian structure mirrors IID case expanded parameter vector (Œ≤,z,ŒªW,Œªx)(\\beta, z, \\lambda_W, \\lambda_x) additional blocks gW(1)g_W^{(1)} gW(2)g_W^{(2)}. analytic derivatives available, nleqslv falls back numeric/Broyden Jacobians.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/articles/el_empirical_likelihood_theory.html","id":"wu-style-strata-augmentation-survey-designs","dir":"Articles","previous_headings":"Survey extension: design-weighted QLS system","what":"Wu-style strata augmentation (survey designs)","title":"Empirical Likelihood Theory","text":"stratified designs, especially NMAR mechanism varies strongly across strata, important EL weights preserve stratum composition implied survey design. Following ideas Wu-style calibration, augment auxiliary vector stratum indicators survey.design object provided: Recover strata factor design (using strata= call). Build dummy variables strata (dropping one reference level). Compute stratum totals NhN_h analysis scale design weights convert stratum shares Wh=Nh/NpopW_h = N_h / N_{\\mathrm{pop}}. Append stratum dummies auxiliary matrix XX targets WhW_h auxiliary means. EL constraints include additional terms form ‚àë‚ààRdipi(ùüè{Hi=h}‚àíWh)=0 \\sum_{\\R} d_i p_i \\bigl(\\mathbf{1}\\{H_i = h\\} - W_h\\bigr) = 0  nonreference stratum hh. forces EL weights reproduce design-implied stratum shares still adjusting within strata NMAR. implementation augmentation performed survey entry point (src_dev/engines/el/impl/survey.R) auxiliary means resolved, resulting augmented auxiliaries flow el_build_equation_system() el_build_equation_system_survey() depending data type. behavior controlled logical strata_augmentation argument el_engine() (default TRUE); effect data survey.design defined strata. survey EL implementation viewed design-weighted analogue QLS, informed pseudo empirical likelihood literature (Chen Sitter 1999; Wu 2005), rather verbatim implementation single paper.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/articles/el_empirical_likelihood_theory.html","id":"analytic-jacobian-a-matrix-iid-path","dir":"Articles","previous_headings":"","what":"Analytic Jacobian (AA Matrix, IID path)","title":"Empirical Likelihood Theory","text":"IID (data-frame) path differentiate F(Œ∏)=0F(\\theta) = 0 respect Œ∏=(Œ≤,z,Œªx)\\theta = (\\beta, z, \\lambda_x). Let: Œ∑i=ZiŒ≤\\eta_i = Z_i \\beta, wi=linkinv(Œ∑i)w_i = \\text{linkinv}(\\eta_i), ŒºŒ∑,=dwdŒ∑(Œ∑i)\\mu_{\\eta,} = \\dfrac{dw}{d\\eta}(\\eta_i), Œº‚Ä≥=d2wdŒ∑2(Œ∑i)\\mu''_i = \\dfrac{d^2 w}{d\\eta^2}(\\eta_i) W=plogis(z)W = \\text{plogis}(z), dWdz=W(1‚àíW)\\frac{dW}{dz} = W(1 - W) ŒªW=C1‚àíW\\lambda_W = \\frac{C}{1 - W}, dŒªWdW=C(1‚àíW)2\\frac{d\\lambda_W}{dW} = \\frac{C}{(1 - W)^2} dŒªWdz=dŒªWdW‚ãÖdWdz\\frac{d\\lambda_W}{dz} = \\frac{d\\lambda_W}{dW} \\cdot \\frac{dW}{dz} Xcentered,=Xi‚àíŒºxX_{\\text{centered},} = X_i - \\mu_x","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/articles/el_empirical_likelihood_theory.html","id":"intermediate-derivatives","dir":"Articles","previous_headings":"Analytic Jacobian (AA Matrix, IID path)","what":"Intermediate Derivatives","title":"Empirical Likelihood Theory","text":"si=ŒºŒ∑,/wi‚áídsidŒ∑i=(Œº‚Ä≤Œ∑,iwi‚àíŒºŒ∑,i2)/wi2s_i = \\mu_{\\eta,}/w_i \\Rightarrow \\;\\frac{ds_i}{d\\eta_i} = (\\mu'_{\\eta,}w_i - \\mu_{\\eta,}^2)/w_i^2 Œº‚Ä≤Œ∑,=dŒºŒ∑,idŒ∑i=d2wdŒ∑i2‚â°Œº‚Ä≥\\mu'_{\\eta,} = \\dfrac{d\\mu_{\\eta,}}{d\\eta_i} = \\dfrac{d^2 w}{d\\eta_i^2} \\equiv \\mu''_i (d2mu.deta2(eta_i) code) ‚àÇDi‚àÇŒ∑i=ŒªWŒºŒ∑,\\frac{\\partial D_i}{\\partial \\eta_i} = \\lambda_W \\mu_{\\eta,} ‚àÇDi‚àÇz=‚àÇŒªW‚àÇz‚ãÖ(wi‚àíW)‚àíŒªW‚ãÖdWdz\\frac{\\partial D_i}{\\partial z} = \\frac{\\partial \\lambda_W}{\\partial z} \\cdot (w_i - W) - \\lambda_W \\cdot \\frac{dW}{dz} ‚àÇDi‚àÇŒªx=Xcentered,\\frac{\\partial D_i}{\\partial \\lambda_x} = X_{\\text{centered},} Define invi=1/Di\\text{inv}_i = 1 / D_i scalar term driving Œ≤\\beta-equations: Ti=si‚àíŒªWŒºŒ∑,iinvi,si=ŒºŒ∑,iwi.T_i = s_i - \\lambda_W \\mu_{\\eta,} \\text{inv}_i,\\quad s_i = \\frac{\\mu_{\\eta,}}{w_i}.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/articles/el_empirical_likelihood_theory.html","id":"compute-its-derivatives","dir":"Articles","previous_headings":"Analytic Jacobian (AA Matrix, IID path)","what":"Compute Its Derivatives","title":"Empirical Likelihood Theory","text":"Using Œº‚Ä≤Œ∑,=dŒºŒ∑,/dŒ∑i=d2mudeta2(Œ∑i)\\,\\mu'_{\\eta,} = d\\mu_{\\eta,}/d\\eta_i = \\mathrm{d2mu\\,deta2}(\\eta_i) dwi/dŒ∑i=ŒºŒ∑,\\,dw_i/d\\eta_i = \\mu_{\\eta,}, ‚àÇsi‚àÇŒ∑i=Œº‚Ä≤Œ∑,iwi‚àíŒºŒ∑,i2wi2.\\frac{\\partial s_i}{\\partial \\eta_i} = \\frac{\\mu'_{\\eta,} w_i - \\mu_{\\eta,}^2}{w_i^2}. Also ‚àÇinvi‚àÇŒ∑i=‚àíinvi2‚ãÖ‚àÇDi‚àÇŒ∑i=‚àíinvi2(ŒªWŒºŒ∑,)\\,\\frac{\\partial \\text{inv}_i}{\\partial \\eta_i} = -\\text{inv}_i^2 \\cdot \\frac{\\partial D_i}{\\partial \\eta_i} = -\\text{inv}_i^2 (\\lambda_W \\mu_{\\eta,}). Therefore ‚àÇTi‚àÇŒ∑i=Œº‚Ä≤Œ∑,iwi‚àíŒºŒ∑,i2wi2‚àíŒªWŒº‚Ä≤Œ∑,iinvi+ŒªW2(ŒºŒ∑,)2invi2.\\frac{\\partial T_i}{\\partial \\eta_i} = \\frac{\\mu'_{\\eta,} w_i - \\mu_{\\eta,}^2}{w_i^2} - \\lambda_W \\mu'_{\\eta,} \\text{inv}_i + \\lambda_W^2 (\\mu_{\\eta,})^2 \\text{inv}_i^2. ‚àÇTi‚àÇz=‚àí‚àÇŒªW‚àÇz‚ãÖŒºŒ∑,iinvi+ŒªWŒºŒ∑,iinvi2‚ãÖ‚àÇDi‚àÇz\\frac{\\partial T_i}{\\partial z} = -\\frac{\\partial \\lambda_W}{\\partial z} \\cdot \\mu_{\\eta,} \\text{inv}_i + \\lambda_W \\mu_{\\eta,} \\text{inv}_i^2 \\cdot \\frac{\\partial D_i}{\\partial z} ‚àÇTi‚àÇŒªx=ŒªWŒºŒ∑,iinvi2‚ãÖXcentered,\\frac{\\partial T_i}{\\partial \\lambda_x} = \\lambda_W \\mu_{\\eta,} \\text{inv}_i^2 \\cdot X_{\\text{centered},}","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/articles/el_empirical_likelihood_theory.html","id":"assemble-jacobian-blocks-with-a_i-weights","dir":"Articles","previous_headings":"Analytic Jacobian (AA Matrix, IID path)","what":"Assemble Jacobian Blocks (with aia_i weights)","title":"Empirical Likelihood Theory","text":"JŒ≤Œ≤J_{\\beta\\beta} (K√óKK \\times K): J11=‚àëaiZiT[‚àÇTi‚àÇŒ∑i]ZiJ_{11} = \\sum a_i Z_i^T \\left[ \\frac{\\partial T_i}{\\partial \\eta_i} \\right] Z_i JŒ≤zJ_{\\beta z} (K√ó1K \\times 1): J12=‚àëaiZiT[‚àÇTi‚àÇz]J_{12} = \\sum a_i Z_i^T \\left[ \\frac{\\partial T_i}{\\partial z} \\right] JŒ≤ŒªJ_{\\beta \\lambda} (K√óLK \\times L): J13=‚àëaiZiT[‚àÇTi‚àÇŒªx]J_{13} = \\sum a_i Z_i^T \\left[ \\frac{\\partial T_i}{\\partial \\lambda_x} \\right] JzŒ≤J_{z\\beta} (1√óK1 \\times K): derivative W-equation w.r.t. Œ≤\\beta Equation: GW=‚àëai(wi‚àíW)inviG_W = \\sum a_i (w_i - W) \\text{inv}_i ‚àÇGW‚àÇŒ∑i=ai[ŒºŒ∑,iinvi‚àí(wi‚àíW)invi2(‚àÇDi‚àÇŒ∑i)]=ai[ŒºŒ∑,iinvi‚àí(wi‚àíW)invi2(ŒªWŒºŒ∑,)]\\frac{\\partial G_W}{\\partial \\eta_i} = a_i \\left[ \\mu_{\\eta,} \\text{inv}_i - (w_i - W) \\text{inv}_i^2 \\left(\\frac{\\partial D_i}{\\partial \\eta_i}\\right) \\right] = a_i \\left[ \\mu_{\\eta,} \\text{inv}_i - (w_i - W) \\text{inv}_i^2 (\\lambda_W \\mu_{\\eta,}) \\right] : J21=‚àë‚àÇGW‚àÇŒ∑i‚ãÖZiJ_{21} = \\sum \\frac{\\partial G_W}{\\partial \\eta_i} \\cdot Z_i JzzJ_{zz} (1√ó11 \\times 1): ‚àÇGW‚àÇz=‚àëai[‚àídWdz‚ãÖinvi‚àí(wi‚àíW)invi2‚ãÖ‚àÇDi‚àÇz]\\frac{\\partial G_W}{\\partial z} = \\sum a_i \\left[ -\\frac{dW}{dz} \\cdot \\text{inv}_i - (w_i - W) \\text{inv}_i^2 \\cdot \\frac{\\partial D_i}{\\partial z} \\right] JzŒªJ_{z\\lambda} (1√óL1 \\times L): ‚àÇGW‚àÇŒªx=‚àëai[‚àí(wi‚àíW)invi2Xcentered,]\\frac{\\partial G_W}{\\partial \\lambda_x} = \\sum a_i \\left[ -(w_i - W) \\text{inv}_i^2 X_{\\text{centered},} \\right] JŒªŒ≤J_{\\lambda\\beta} (L√óKL \\times K): constraints H(Œª):‚àëaiinviXcentered,=0H(\\lambda): \\sum a_i \\text{inv}_i X_{\\text{centered},} = 0 ‚àÇH‚àÇŒ∑i=‚àíaiinvi2‚àÇDi‚àÇŒ∑iXcentered,=‚àíaiinvi2(ŒªWŒºŒ∑,)Xcentered,\\frac{\\partial H}{\\partial \\eta_i} = -a_i \\text{inv}_i^2 \\frac{\\partial D_i}{\\partial \\eta_i} X_{\\text{centered},} = -a_i \\text{inv}_i^2 (\\lambda_W \\mu_{\\eta,}) X_{\\text{centered},} Thus, component-wise J31=‚àëiai(‚àíŒªWŒºŒ∑,iinvi2)Xcentered,iTZiJ_{31} = \\sum_i a_i\\,(-\\lambda_W \\mu_{\\eta,}\\,\\text{inv}_i^2)\\, X_{\\text{centered},}^T Z_i. compact matrix form: J31=XcenteredTdiag(‚àíaiŒªWŒºŒ∑,iinvi2)Z.J_{31} = X_{\\text{centered}}^T \\operatorname{diag}\\!\\big(-a_i\\,\\lambda_W\\,\\mu_{\\eta,}\\,\\text{inv}_i^2\\big) Z. JŒªzJ_{\\lambda z} (L√ó1L \\times 1): ‚àÇH‚àÇz=‚àí‚àëaiinvi2(‚àÇDi‚àÇz)Xcentered,\\frac{\\partial H}{\\partial z} = -\\sum a_i \\text{inv}_i^2 \\left(\\frac{\\partial D_i}{\\partial z}\\right) X_{\\text{centered},} JŒªŒªJ_{\\lambda\\lambda} (L√óLL \\times L): ‚àÇH‚àÇŒªx=‚àíXcenteredTdiag(aiinvi2)Xcentered.\\frac{\\partial H}{\\partial \\lambda_x} = -X_{\\text{centered}}^T \\operatorname{diag}(a_i\\,\\text{inv}_i^2) X_{\\text{centered}}. expressions match unguarded analytic derivatives; code (src_dev/engines/el/impl/jacobian.R), terms involving derivatives 1/Di1/D_i additionally multiplied active mask ùüô{Diraw>Œ¥}\\mathbb{1}\\{D_i^{\\text{raw}} > \\delta\\} respect denominator floor used numerical stability.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/articles/el_empirical_likelihood_theory.html","id":"why-analytic-a-helps","dir":"Articles","previous_headings":"Analytic Jacobian (AA Matrix, IID path)","what":"Why Analytic A Helps","title":"Empirical Likelihood Theory","text":"Newton-Raphson (used outer solve) linearizes F(Œ∏)F(\\theta) near current iterate: F(Œ∏+Œî)‚âàF(Œ∏)+(Œ∏)ŒîF(\\theta + \\Delta) \\approx F(\\theta) + (\\theta)\\,\\Delta. update Œî\\Delta solves AŒî=‚àíFA\\,\\Delta = -F, hence high-quality AA critical fast, stable convergence.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/articles/el_empirical_likelihood_theory.html","id":"variance-estimation","dir":"Articles","previous_headings":"","what":"Variance Estimation","title":"Empirical Likelihood Theory","text":"Analytic delta variance EL estimator yet implemented package. requested via variance_method = \"delta\", implementation returns NA guidance message. recommend variance_method = \"bootstrap\" standard errors IID survey settings.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/articles/el_empirical_likelihood_theory.html","id":"solving-strategy-and-initialization","dir":"Articles","previous_headings":"Variance Estimation","what":"Solving Strategy and Initialization","title":"Empirical Likelihood Theory","text":"Unknowns Œ∏=(Œ≤,z,Œªx)\\theta = (\\beta, z, \\lambda_x) W=plogis(z)W = \\mathrm{plogis}(z). solve full stacked system F(Œ∏)=0F(\\theta) = 0 via Newton analytic Jacobian =‚àÇF/‚àÇŒ∏A = \\partial F/\\partial\\theta using nleqslv. Globalization scaling: rely nleqslv‚Äôs globalization (default global = \"qline\", xscalm = \"auto\") enforce denominator positivity (miniDi‚â•Œµ\\min_i D_i \\ge \\varepsilon) within equation evaluations. Optional standardization design matrices improves conditioning. Initialization: default Œ≤\\beta starts zeros scaled space (unless user supplies start$beta), zz seeded logit(observed response rate)\\mathrm{logit}(\\text{observed response rate}). internal last-chance Broyden retry may used Newton fails converge; user-facing mode.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/articles/el_empirical_likelihood_theory.html","id":"practical-identifiability-and-diagnostics","dir":"Articles","previous_headings":"Variance Estimation","what":"Practical Identifiability and Diagnostics","title":"Empirical Likelihood Theory","text":"EL system balances parametric response-model score calibration constraints. Identifiability can weaken following situations: Weak nearly collinear auxiliaries: Xi‚àíŒºxX_i-\\mu_x little variation nearly collinear response score direction, constraint block =‚àÇF/‚àÇŒ∏A=\\partial F/\\partial\\theta becomes ill-conditioned. Inconsistent auxiliary means: supplied Œºx\\mu_x far respondent sample can support (response model), denominators DiD_i cluster near 0 Œ∫()\\kappa() inflates. Heavy nonresponse near-boundary WW: WW approaches 0 1, ŒªW=C/(1‚àíW)\\lambda_W=C/(1-W) can spike amplify sensitivity. Diagnostics exposed implementation help assess issues: jacobian_condition_number (Œ∫()\\kappa()), max_equation_residual, denominator summaries (min, lower quantiles, median), weight concentration (max share, top-5 share, ESS), trimming fraction. Mitigations include standardizing predictors, trimming extreme weights (trim_cap), adding informative response-model predictors, preferring bootstrap variance diagnostics indicate fragility.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/articles/el_empirical_likelihood_theory.html","id":"survey-design-details","dir":"Articles","previous_headings":"","what":"Survey Design Details","title":"Empirical Likelihood Theory","text":"extend QLS‚Äôs methodology complex surveys two complementary ways: Estimating equations base weights: sums include base weight aia_i; set aia_i survey design weight respondents. Totals NpopN_{\\text{pop}} nresp_weighted=‚àëain_{\\text{resp\\_weighted}}=\\sum a_i computed design weights used throughout design-weighted system. Nonrespondent total T0T_0 linkage equation: survey-specific system form T0=Npop‚àínresp_weightedT_0 = N_{\\text{pop}} - n_{\\text{resp\\_weighted}} enforce linkage WW ŒªW\\lambda_W equation T0/(1‚àíW)‚àíŒªW‚àëdi/Di=0T_0/(1-W) - \\lambda_W \\sum d_i/D_i = 0 rather using closed-form ŒªW=((Npop/nresp_weighted)‚àí1)/(1‚àíW)\\lambda_W = ((N_{\\text{pop}}/n_{\\text{resp\\_weighted}}) - 1)/(1-W). Bootstrap variance via replicate weights: standard errors, use bootstrap replicate-weight designs created svrep::as_bootstrap_design. replicate, estimator re-fit reconstructed design using replicate‚Äôs weights, survey::svrVar used compute variance replicate estimates appropriate scaling. matches paper‚Äôs guidance adapt likelihood/estimating framework stratification unequal-probability sampling relying standard survey resampling uncertainty. Analytic variance implemented yet. Degrees--freedom: confidence intervals, use survey degrees--freedom (t-quantiles) survey.design supplied; otherwise, use normal quantiles.","code":""},{"path":[]},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/articles/el_empirical_likelihood_theory.html","id":"scaling-optional-standardizetrue","dir":"Articles","previous_headings":"Scaling and Unscaling","what":"Scaling (optional; standardize=TRUE)","title":"Empirical Likelihood Theory","text":"meanj\\text{mean}_j, sdj\\text{sd}_j; sdj‚âà0\\text{sd}_j \\approx 0, set sdj=1\\text{sd}_j = 1 avoid blow-ups. Zscaled[,j]=(Zun[,j]‚àímeanj)/sdjZ_{\\text{scaled}}[,j] = (Z_{\\text{un}}[,j] - \\text{mean}_j) / \\text{sd}_j Xscaled[,j]=(Xun[,j]‚àímeanj)/sdjX_{\\text{scaled}}[,j] = (X_{\\text{un}}[,j] - \\text{mean}_j) / \\text{sd}_j Œºx,scaled[j]=(Œºx,un[j]‚àímeanj)/sdj\\mu_{x,\\text{scaled}}[j] = (\\mu_{x,\\text{un}}[j] - \\text{mean}_j) / \\text{sd}_j","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/articles/el_empirical_likelihood_theory.html","id":"unscaling-beta-and-vcov","dir":"Articles","previous_headings":"Scaling and Unscaling","what":"Unscaling Œ≤\\beta and vcov","title":"Empirical Likelihood Theory","text":"columns j‚â†j \\neq intercept: D[j,j]=1/sdjD[j,j] = 1/\\text{sd}_j intercept: adjust absorb centering: D[intercept,j]=‚àímeanj/sdjD[\\text{intercept},j] = -\\text{mean}_j/\\text{sd}_j Transform: Œ≤unscaled=DŒ≤scaled\\beta_{\\text{unscaled}} = D \\beta_{\\text{scaled}}; vcovunscaled=DvcovscaledDT\\text{vcov}_{\\text{unscaled}} = D \\, \\text{vcov}_{\\text{scaled}} \\, D^T Code: centralized src_dev/shared/scaling.R; engines call validate_and_apply_nmar_scaling() unscale_coefficients().","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/articles/el_empirical_likelihood_theory.html","id":"bootstrap-variance","dir":"Articles","previous_headings":"","what":"Bootstrap Variance","title":"Empirical Likelihood Theory","text":"Resample rows replacement (nn nn), re-run estimator, compute var\\text{var} bootstrap YÃÇ\\hat{Y}s; warn many failures; return var\\sqrt{\\text{var}}. Convert bootstrap replicate-weight design via svrep::as_bootstrap_design. replicate, re-construct temporary design run estimator; use survey::svrVar compute variance replicate estimates (scale/rscales). Code mapping: Engine: el_engine(..., family, standardize, trim_cap, variance_method, ...) src_dev/engines/el/engine.R el.data.frame() / el.survey.design() src_dev/engines/el/impl/dataframe.R src_dev/engines/el/impl/survey.R prepare inputs, call el_estimator_core(), wrap results. Construct F(Œ∏)F(\\theta) via el_build_equation_system() (src_dev/engines/el/impl/equations.R). Solve F(Œ∏)=0F(\\theta)=0 via nleqslv (Newton analytic Jacobian available, Broyden fallback). Build EL weights, mean, diagnostics. Jacobian: el_build_jacobian(...) src_dev/engines/el/impl/jacobian.R returns analytic whenever family supplies d2mu.deta2 (logit, probit). Variance: Bootstrap variance implemented src_dev/shared/bootstrap.R. S3 result: src_dev/engines/el/s3.R provides print/tidy/glance accessors.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/articles/el_empirical_likelihood_theory.html","id":"practical-notes","dir":"Articles","previous_headings":"Bootstrap Variance","what":"Practical Notes","title":"Empirical Likelihood Theory","text":"Denominator guard: Di‚â•ŒµD_i \\ge \\varepsilon (default 10‚àí810^{-8}) across steps; diagnostics report extreme fractions. Eta cap option: can adjust Œ∑\\eta cap via options(nmar.eta_cap = 60) (default 50) suit data scale link","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/articles/el_empirical_likelihood_theory.html","id":"algorithm","dir":"Articles","previous_headings":"Bootstrap Variance","what":"Algorithm","title":"Empirical Likelihood Theory","text":"solve full stacked system F(Œ∏)=0F(\\theta)=0 Newton using analytic Jacobian =‚àÇF/‚àÇŒ∏A = \\partial F/\\partial \\theta globalization via nleqslv. Denominator positivity (miniDi‚â•Œµ\\min_i D_i \\ge \\varepsilon), predictor standardization, capped Œ∑\\eta ensure numerical stability. estimating equations remain Qin, Leung Shao (2002) IID path, design-weighted analogue survey path.","code":"Input: Z (response design), X (auxiliary design), mu_x (population means),        a (base weights), family (logit/probit), trim_cap, tolerances. Initialize: beta = 0 in scaled space (or user-supplied start),             z = logit(observed response rate), lambda_x = 0             (and lambda_W = 0 for survey designs). Repeat until convergence of F(theta) = 0:   1) Compute eta = Z beta, w = linkinv(eta), W = plogis(z).      - IID (data.frame): set lambda_W = ((N_pop/n_resp_weighted) - 1)/(1 - W).      - survey.design: use the current lambda_W component of theta.   2) Evaluate full stacked equations using guarded denominators      D_i = 1 + lambda_W (w_i - W) + (X_i - mu_x)^T lambda_x.   3) Compute analytic Jacobian A = dF/dtheta (if available; else numeric/Broyden).   4) Newton step: solve A * step = -F with globalization; enforce min D_i >= eps.   5) Update theta <- theta + step. Return: p_i \\propto a_i / D_i and \\hat{Y} = Sum p_i Y_i / Sum p_i."},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/articles/el_empirical_likelihood_theory.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Empirical Likelihood Theory","text":"Qin, J., Leung, D., Shao, J. (2002). Estimation survey data nonignorable nonresponse informative sampling. Journal American Statistical Association, 97(457), 193-200. Chen, J., Sitter, R. R. (1999). pseudo empirical likelihood approach complex survey data. Biometrika, 86(2), 373-385. Wu, C. (2005). Algorithms R codes pseudo empirical likelihood method survey sampling. Canadian Journal Statistics, 33(3), 497-509.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/articles/el_empirical_likelihood_theory.html","id":"appendix-el-engine-api-reference-user-facing","dir":"Articles","previous_headings":"","what":"Appendix: EL Engine API Reference (User-Facing)","title":"Empirical Likelihood Theory","text":"appendix summarizes key options EL engine (constructor: el_engine()), defaults, recommended usage. Values: ‚Äúlogit‚Äù, ‚Äúprobit‚Äù, family object (list name, linkinv, mu.eta, d2mu.deta2, score_eta). Notes: implement logit_family() probit_family(). use log-likelihood score score_eta(eta, delta) = mu.eta(eta)/linkinv(eta) (respondents), .e., ‚àÇlogp/‚àÇŒ∑\\partial\\log p/\\partial\\eta. matches paper‚Äôs semiparametric MLE equations keeps analytic Jacobian family-agnostic. Standardize ZZ/XX (Œºx\\mu_x) using nmar_scaling_recipe numerical stability. Coefficients vcov unscaled solving. Caps EL weights redistributes mass. Improves robustness extreme weights arise. Prefer variance_method = \"bootstrap\" trimming finite. ‚Äúbootstrap‚Äù: IID resampling survey replicate weights via svrep; preferred SEs. ‚Äúnone‚Äù: skip variance calculation. Number bootstrap replicates variance_method = \"bootstrap\". Increase stability, decrease speed. Passed nleqslv (e.g., ftol, xtol, maxit).","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/articles/el_empirical_likelihood_theory.html","id":"diagnostics-glanceprint","dir":"Articles","previous_headings":"Appendix: EL Engine API Reference (User-Facing)","what":"Diagnostics (glance/print)","title":"Empirical Likelihood Theory","text":"jacobian_condition_number (Œ∫()\\kappa()), max_equation_residual, denominator summaries (min, 1%/5%/median), weight concentration (max share/top-5/ESS), trimming fraction. help assess identification numerical stability.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/articles/exptilt_nonparam_theory.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Nonparametric Exponential Tilting Theory","text":"vignette explains matrix-vectorized implementation fully nonparametric exponential tilting (EXPTILT) estimator, described Appendix 2 Riddles et al.¬†(2016). method designed fully categorical data, outcomes (YY), response-model covariates (X1X_1), instrumental-variable covariates (X2X_2) discrete. Unlike parametric method, estimates parameters œï\\phi response probability function œÄ(x,y;œï)\\pi(x, y; \\phi), nonparametric approach directly estimates nonresponse odds stratum. achieved using Expectation-Maximization (EM) algorithm find maximum likelihood estimates odds. implementation (exptilt_nonparam.data.frame) assumes input data aggregated data frame, row represents unique stratum x*=(x1,x2)x^* = (x_1, x_2) contains counts respondents outcome y*y^* total count nonrespondents.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/articles/exptilt_nonparam_theory.html","id":"notation-and-main-objects","dir":"Articles","previous_headings":"","what":"Notation and Main Objects","title":"Nonparametric Exponential Tilting Theory","text":"implementation maps directly notation Appendix 2. Let x1x_1 covariates response model x2x_2 nonresponse instrumental variable. full stratum x*=(x1,x2)x^* = (x_1, x_2), response-model-stratum x1x_1. algorithm built set fixed matrices (computed ) one matrix iteratively updated.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/articles/exptilt_nonparam_theory.html","id":"fixed-objects-pre-computed","dir":"Articles","previous_headings":"Notation and Main Objects","what":"Fixed Objects (Pre-computed)","title":"Nonparametric Exponential Tilting Theory","text":"Source: data[, outcome_cols] Dimensions: (Nstrata√óKoutcomes)(N_{\\text{strata}} \\times K_{\\text{outcomes}}), NstrataN_{\\text{strata}} number (x1,x2)(x_1, x_2) rows KoutcomesK_{\\text{outcomes}} number YY categories. Definition: observed (weighted) count respondents stratum x*x^* outcome y*y^*. Ny*x*=‚àë‚ààAdiŒ¥iI(yi=y*,xi=x*)N_{y^*x^*} = \\sum_{\\} d_i \\delta_i (y_i = y^*, x_i = x^*) (Note: implementation assumes di=1d_i=1 unless input data pre-weighted). Source: data[, refusal_col] Dimensions: (Nstrata√ó1)(N_{\\text{strata}} \\times 1) Definition: observed (weighted) total count nonrespondents stratum x*x^*. Mx*=mx*M_{x^*} = m_{x^*} Source: n_y_x_matrix / rowSums(n_y_x_matrix) Dimensions: (Nstrata√óKoutcomes)(N_{\\text{strata}} \\times K_{\\text{outcomes}}) Definition: conditional probability (proportion) observing outcome y*y^* given stratum x*x^*, among respondents. fixed, observed quantity used E-Step. pÃÇy*|x*=Ny*x*‚àëyNyx*=pr(y=y*|x1=x1*,x2=x2*,Œ¥=1)\\hat{p}_{y^*|x^*} = \\frac{N_{y^*x^*}}{\\sum_{y} N_{yx^*}} = pr(y=y^* | x_1=x_1^*, x_2=x_2^*, \\delta=1) Source: aggregate(n_y_x_matrix ~ data$x1_key, ...) Dimensions: (Nx1√óKoutcomes)(N_{x_1} \\times K_{\\text{outcomes}}), Nx1N_{x_1} number unique x1x_1 strata. Definition: observed (weighted) count respondents outcome y*y^* stratum x1x_1, summed instrument x2x_2. denominator M-Step. Ny*x1*=‚àëx2Ny*(x1*,x2)=ny*x1*N_{y^*x_1^*} = \\sum_{x_2} N_{y^*(x_1^*, x_2)} = n_{y^*x_1^*}","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/articles/exptilt_nonparam_theory.html","id":"iterative-objects-the-em-algorithm","dir":"Articles","previous_headings":"Notation and Main Objects","what":"Iterative Objects (The EM Algorithm)","title":"Nonparametric Exponential Tilting Theory","text":"Dimensions: (Nx1√óKoutcomes)(N_{x_1} \\times K_{\\text{outcomes}}) Definition: parameter estimated. represents odds nonresponse given x1x_1 stratum outcome yy. updated M-Step. Initialization (Step 0): O(0)(x1,y)=1O^{(0)}(x_1, y) = 1 (x1,y)(x_1, y). Dimensions: (Nstrata√óKoutcomes)(N_{\\text{strata}} \\times K_{\\text{outcomes}}) Definition: expected count nonrespondents stratum x*x^* outcome y*y^*, given current odds O(t)O^{(t)}. computed E-Step. Dimensions: (Nx1√óKoutcomes)(N_{x_1} \\times K_{\\text{outcomes}}) Definition: expected count nonrespondents outcome y*y^* stratum x1x_1, summed instrument x2x_2. numerator M-Step.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/articles/exptilt_nonparam_theory.html","id":"the-expectation-maximization-em-algorithm","dir":"Articles","previous_headings":"","what":"The Expectation-Maximization (EM) Algorithm","title":"Nonparametric Exponential Tilting Theory","text":"function exptilt_nonparam.data.frame direct implementation EM algorithm Appendix 2. goal find argmaxO(x1,y)\\text{argmax} O(x_1, y) maximizes observed data likelihood, solved iterating two steps.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/articles/exptilt_nonparam_theory.html","id":"step-1-1-e-step-compute-expected-nonrespondent-counts","dir":"Articles","previous_headings":"The Expectation-Maximization (EM) Algorithm","what":"Step 1.1 (E-Step): Compute Expected Nonrespondent Counts","title":"Nonparametric Exponential Tilting Theory","text":"E-Step computes expected breakdown nonrespondents outcome categories. answers: ‚ÄúGiven current odds_matrix O(t)O^{(t)}, expected count *x*(t)M_{y^*x^*}^{(t)} full stratum x*x^*?‚Äù Formula: *x*(t)=Mx*pÃÇy*|x*O(t)(x1*,y*)‚àëypÃÇy|x*O(t)(x1*,y)M_{y^*x^*}^{(t)} = M_{x^*} \\frac{\\hat{p}_{y^*|x^*} O^{(t)}(x_1^*, y^*)}{\\sum_{y} \\hat{p}_{y|x^*} O^{(t)}(x_1^*, y)} Implementation (E-STEP code): vectorized. denominator computed via rowSums(p_hat_matrix * odds_joined_matrix). full calculation : m_y_x_matrix <- m_x_vec * (p_hat_matrix * odds_joined_matrix) / denominator","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/articles/exptilt_nonparam_theory.html","id":"step-1-2-m-step-update-odds-matrix","dir":"Articles","previous_headings":"The Expectation-Maximization (EM) Algorithm","what":"Step 1.2 (M-Step): Update Odds Matrix","title":"Nonparametric Exponential Tilting Theory","text":"M-Step updates nonresponse odds O(x1,y)O(x_1, y) using expected counts E-Step. Formula: *x1*(t)=‚àëx2My*(x1*,x2)(t)M_{y^*x_1^*}^{(t)} = \\sum_{x_2} M_{y^*(x_1^*, x_2)}^{(t)} Implementation: m_y_x1_matrix <- aggregate(m_y_x_matrix ~ data$x1_key, ...) Formula: O(t+1)(x1*,y*)=*x1*(t)Ny*x1*O^{(t+1)}(x_1^*, y^*) = \\frac{M_{y^*x_1^*}^{(t)}}{N_{y^*x_1^*}} Implementation: odds_matrix <- m_y_x1_matrix / n_safe","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/articles/exptilt_nonparam_theory.html","id":"step-2-convergence","dir":"Articles","previous_headings":"The Expectation-Maximization (EM) Algorithm","what":"Step 2: Convergence","title":"Nonparametric Exponential Tilting Theory","text":"Steps 1.1 1.2 repeated change odds_matrix (measured sum absolute differences) falls tolerance tol.","code":""},{"path":[]},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/articles/exptilt_nonparam_theory.html","id":"survey-weights","dir":"Articles","previous_headings":"Final Estimates and Survey Weights","what":"Survey Weights","title":"Nonparametric Exponential Tilting Theory","text":"exptilt_nonparam.data.frame function assumes input data already aggregated. survey.design object provided exptilt_nonparam.survey.design, adapter (shown ) must first used create aggregated table microdata. case, Ny*x*N_{y^*x^*} Mx*M_{x^*} represent weighted sums counts (‚àëdi‚Ä¶\\sum d_i \\dots), simple counts. EM algorithm derived matrices (p_hat_matrix, odds_matrix) correctly computed based weighted inputs, following logic paper.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/articles/exptilt_nonparam_theory.html","id":"final-adjusted-counts","dir":"Articles","previous_headings":"Final Estimates and Survey Weights","what":"Final Adjusted Counts","title":"Nonparametric Exponential Tilting Theory","text":"final output data_to_return object primary interest analysis. constructed : 1. Calculating final expected nonrespondent counts *x*(final)M_{y^*x^*}^{(\\text{final})} using converged odds_matrix. 2. Adding expected counts original observed respondent counts Ny*x*N_{y^*x^*}. Definition: data_to_return[y^*, x^*] = N_{y^*x^*} + M_{y^*x^*}^{(\\text{final})} Implementation: data_to_return[, outcome_cols] <- n_y_x_matrix_ordered + m_y_x_matrix_ordered final adjusted table represents completed dataset, ‚ÄúRefusal‚Äù counts redistributed across outcome columns according NMAR model.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/articles/exptilt_nonparam_theory.html","id":"final-proportion-hattheta_j","dir":"Articles","previous_headings":"Final Estimates and Survey Weights","what":"Final Proportion Œ∏ÃÇj\\hat{\\theta}_j","title":"Nonparametric Exponential Tilting Theory","text":"final population proportion outcome jj, Œ∏ÃÇj\\hat{\\theta}_j, total (weighted) adjusted count outcome jj divided total (weighted) population. calculated data_to_return object. Formula (Unweighted): Œ∏ÃÇj=‚àëx*(Njx*+Mjx*(final))‚àëy‚àëx*(Nyx*+Myx*(final))\\hat{\\theta}_j = \\frac{\\sum_{x^*} (N_{jx^*} + M_{jx^*}^{(\\text{final})})}{\\sum_y \\sum_{x^*} (N_{yx^*} + M_{yx^*}^{(\\text{final})})} Implementation: precisely ‚ÄúAdjusted Proportions‚Äù calculation notebook‚Äôs Chunk 5 performs data_to_return object. differs paper‚Äôs Step 3 formula, IPW (Inverse Probability Weighting) estimator. However, methods asymptotically equivalent, ‚Äúadd--sum‚Äù method (data_to_return) direct intuitive application EM algorithm‚Äôs goal.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/articles/exptilt_theory.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Exponential Tilting Theory","text":"vignette explains matrix-vectorized implementation exponential tilting (EXPTILT) estimator used package. exposition focuses concepts linear-algebraic operations used implementation (functions generate_conditional_density_matrix, generate_C_matrix, generate_Odds, vectorized s_function), mirrors statistical equations underlie algorithm (see Riddles et al.¬†(2016) theoretical background). method operates dataset split respondents non-respondents. Let n=n0+n1n = n_0 + n_1 n1n_1 number respondents (observed YY) n0n_0 number non-respondents (missing YY). algorithm always treats two groups separately: conditional-density model fit respondents used impute support non-respondents; missingness model fit using covariates include candidate yy values. emphasize two distinct disjoint sets covariates throughout, require empty intersection: ùí≥outcome‚à©ùí≥missingness=‚åÄ.\\mathcal{X}_{\\text{outcome}} \\cap \\mathcal{X}_{\\text{missingness}} = \\varnothing. covariates_for_outcome (denote XoutX_{\\text{}}): variables used model conditional density f1(y‚à£Xout)f_1(y\\mid X_{\\text{}}) respondents; covariates_for_missingness (denote XmissX_{\\text{miss}}): variables used response probability œÄ(Xmiss,y;œï)\\pi(X_{\\text{miss}},y;\\phi) (includes candidate yy values evaluating missing-data expectation). Distinguishing sets clearly notation code crucial: conditional density model fit using covariates_for_outcome respondents , missingness model uses covariates_for_missingness (importantly) takes yy additional predictor forming œÄ(‚ãÖ;œï)\\pi(\\cdot;\\phi).","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/articles/exptilt_theory.html","id":"notation-and-main-objects","dir":"Articles","previous_headings":"","what":"Notation and main objects","title":"Exponential Tilting Theory","text":"Let: nn total number units; split respondents (observed YY) non-respondents (missing YY). Denote indices ii non-respondents kk (jj) respondent outcomes used support. {yj}j=1n1\\{y_j\\}_{j=1}^{n_1} vector observed outcome values (respondents). XoutX^{\\text{}} denote matrix covariates_for_outcome respondents. XunX^{\\text{un}} denote matrix covariates_for_outcome non-respondents. Xmiss,obsX^{\\text{miss,obs}} Xmiss,unX^{\\text{miss,un}} denote covariates_for_missingness respondents non-respondents, respectively (shorten XmissobsX_{\\text{miss}}^{\\text{obs}} XmissunX_{\\text{miss}}^{\\text{un}} needed). œÄ(xmiss,y;œï)\\pi(x_{\\text{miss}},y;\\phi) response probability (explicit link notation ): given covariate row used missingness model candidate yy, œÄ(‚ãÖ;œï)\\pi(\\cdot;\\phi) denotes probability response parameter œï\\phi. build three central matrices: Conditional-density matrix FF (denoted code f_matrix_nieobs): Size: n0√ón1n_0 \\times n_1 n0n_0 number non-respondents n1n_1 number distinct respondent yy values used support. Entries: Fij=f1(yj‚à£xiun;Œ≥ÃÇ)F_{ij} = f_1(y_j \\mid x^{\\text{un}}_i; \\hat\\gamma) Œ≥ÃÇ\\hat\\gamma (estimated) parameter vector conditional-density model fit respondents. corresponds empirical approximation equation (12): fÃÇ1(yj)‚àù‚àëk:Œ¥k=1f1(yj‚à£xk;Œ≥ÃÇ).\\hat f_1(y_j) \\propto \\sum_{k:\\,\\delta_k=1} f_1(y_j \\mid x_k; \\hat\\gamma). Column-normalizer vector CC (denoted code C_matrix_nieobs): Size: n1√ó1n_1 \\times 1 (column vector). Entries: column-sums conditional densities evaluated respondent covariates: Cj=C(yj;Œ≥ÃÇ)=‚àëk:Œ¥k=1f1(yj‚à£xkobs;Œ≥ÃÇ).C_j = C(y_j;\\hat\\gamma) = \\sum_{k:\\,\\delta_k=1} f_1(y_j \\mid x^{\\text{obs}}_k;\\hat\\gamma). Conceptually denominator appears fractional weights formed (see ). Odds matrix O(œï)O(\\phi) (constructed generate_Odds): Size: n0√ón1n_0 \\times n_1. Entries (non-respondent ii candidate yjy_j): Oij(œï)=1‚àíœÄ(ximiss,un,yj;œï)œÄ(ximiss,un,yj;œï)O_{ij}(\\phi) = \\frac{1-\\pi(x^{\\text{miss,un}}_i, y_j;\\phi)}{\\pi(x^{\\text{miss,un}}_i, y_j;\\phi)} implementation exploits separability linear predictor parameters: Œ∑ij=Œ≤0+Ximiss,unŒ≤miss+Œ≤yyj,\\eta_{ij} = \\beta_0 + X^{\\text{miss,un}}_i\\beta_{\\text{miss}} + \\beta_y y_j, uses outer() form n0√ón1n_0\\times n_1 matrix efficiently. Using objects form non-normalized weight matrix Uij(œï)=Oij(œï)‚ãÖFijU_{ij}(\\phi) = O_{ij}(\\phi) \\cdot F_{ij} normalized fractional-weight matrix Wij(œï)=Uij(œï)Cj=Oij(œï)f1(yj‚à£xiun;Œ≥ÃÇ)‚àëk:Œ¥k=1f1(yj‚à£xkobs;Œ≥ÃÇ).W_{ij}(\\phi) = \\frac{U_{ij}(\\phi)}{C_j} = \\frac{O_{ij}(\\phi)\\,f_1(y_j\\mid x^{\\text{un}}_i;\\hat\\gamma)}{\\sum_{k:\\,\\delta_k=1} f_1(y_j\\mid x^{\\text{obs}}_k;\\hat\\gamma)}. WijW_{ij} match weights appearing theoretical mean score approximation (equation (15) notes): fractional contribution imputed (,j)(,j) pair conditional expectation unit ii.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/articles/exptilt_theory.html","id":"the-vectorized-score-s_2-and-matrix-algebra","dir":"Articles","previous_headings":"","what":"The vectorized score S_2 and matrix algebra","title":"Exponential Tilting Theory","text":"Recall mean-score approximation leads estimating equation used solve œï\\phi (cf.¬†equation (13) notes): S2(œï;œïÃÇ(t),Œ≥ÃÇ)=‚àër=1n[Œ¥rs(œï;Œ¥r,xrmiss,xrout,yr)+(1‚àíŒ¥r)EÃÉ0{s(œï;Œ¥,xrmiss,xrout,Y)‚à£xrout;œïÃÇ(t),Œ≥ÃÇ}]=0. S_2(\\phi; \\hat\\phi^{(t)}, \\hat\\gamma) = \\sum_{r=1}^n \\Big[ \\delta_r s(\\phi;\\delta_r, x^{\\text{miss}}_r, x^{\\text{}}_r, y_r) + (1-\\delta_r)\\widetilde{E}_0\\{ s(\\phi;\\delta, x^{\\text{miss}}_r, x^{\\text{}}_r, Y) \\mid x^{\\text{}}_r;\\hat\\phi^{(t)},\\hat\\gamma\\} \\Big] = 0. convenient decompose sum observed unobserved contributions: S2(œï)=Sobs(œï)+Sun(œï), S_2(\\phi) = S_{\\text{obs}}(\\phi) + S_{\\text{un}}(\\phi),  Sobs(œï)=‚àër:Œ¥r=1s(œï;Œ¥=1,xrmiss,xrout,yr) S_{\\text{obs}}(\\phi) = \\sum_{r:\\,\\delta_r=1} s(\\phi;\\delta=1, x^{\\text{miss}}_r, x^{\\text{}}_r, y_r)  score contribution respondents, missing-unit contribution approximated discrete-support expectation Sun(œï)‚âà‚àë:Œ¥i=0‚àëj=1n1Wij(œï)s(œï;Œ¥=0,ximiss,xiout,yj). S_{\\text{un}}(\\phi) \\approx \\sum_{:\\,\\delta_i=0} \\sum_{j=1}^{n_1} W_{ij}(\\phi)\\, s(\\phi;\\delta=0, x^{\\text{miss}}_i, x^{\\text{}}_i, y_j).  remainder section explains double sum Sun(œï)S_{\\text{un}}(\\phi) computed via matrix operations. crucial observation vectorization inner conditional expectation non-respondent ii approximated weighted finite-sum respondent support {yj}\\{y_j\\}: EÃÉ0{s(œï;Œ¥,ximiss,xiout,Y)‚à£xiout}‚âà‚àëj=1n1Wij(œï)s(œï;Œ¥=0,ximiss,xiout,yj). \\widetilde{E}_0\\{ s(\\phi;\\delta, x^{\\text{miss}}_i, x^{\\text{}}_i, Y) \\mid x^{\\text{}}_i\\} \\approx \\sum_{j=1}^{n_1} W_{ij}(\\phi)\\, s(\\phi;\\delta=0, x^{\\text{miss}}_i, x^{\\text{}}_i, y_j). Stacking non-respondent expectations across non-respondents gives single matrix operation. Let pair (,j)(,j) evaluate vector-valued score s (Œ¥=0,ximiss,xiout,yj)(\\delta=0, x^{\\text{miss}}_i, x^{\\text{}}_i, y_j). Collect quickly exploiting algebraic factorization score (see s_function implementation): many parameter-specific components separable ii jj allows creation low-memory representations. Denote Sij(0)S^{(0)}_{ij} p-dimensional score vector (,j)(,j). Organize parameter index mm n0√ón1n_0\\times n_1 matrix values [S‚Ä¢‚Ä¢(0)]m[S^{(0)}_{\\bullet\\bullet}]_{m} (parameter-wise maps). non-respondent contribution overall score vector ‚àë=1n0‚àëj=1n1Wij(œï)Sij(0)=[vec(W‚àò[S(0)]1),‚Ä¶,vec(W‚àò[S(0)]p)]‚ä§ \\sum_{=1}^{n_0} \\sum_{j=1}^{n_1} W_{ij}(\\phi)\\, S^{(0)}_{ij} = \\left[ \\,\\text{vec} \\big( W \\circ [S^{(0)}]_{1} \\big)\\, ,\\, \\ldots\\, ,\\, \\text{vec}\\big( W \\circ [S^{(0)}]_{p} \\big)\\,\\right]^\\top  ‚àò\\circ denotes elementwise multiplication vec followed appropriate collapse (row-sum column-sum) implements inner summation depending parameter‚Äôs factorization. concrete computational terms: parameter components multiply per-row (.e.¬†depend xix_i times factor function yjy_j) compute elementwise products WW factor matrix row-sum across jj get n0√ó1n_0\\times 1 contribution per non-respondent, sum across ii. intercept-like column-wise components, column-sum followed weighted multiplication suffices. implementation reduces sequence dense matrix operations row/column sums rather explicit loops expanded index set length n0√ón1n_0\\times n_1. yields large speed memory benefits real datasets. Concise vectorized S_2 recipe (conceptual): Build FF (size n0√ón1n_0\\times n_1) via generate_conditional_density_matrix(model). Build CC (size n1n_1) via generate_C_matrix(model) summing conditional densities respondents. candidate œï\\phi compute O(œï)O(\\phi) (size n0√ón1n_0\\times n_1) via generate_Odds(model,\\phi). Form W(œï)=O(œï)‚àòFùüèn0C‚ä§W(\\phi)=\\dfrac{O(\\phi)\\circ F}{\\mathbf{1}_{n_0} C^\\top} (.e.¬†divide column O‚àòFO\\circ F corresponding scalar CjC_j). Compute observed-score sum: Sobs(œï)=‚àër:Œ¥r=1s(œï;Œ¥=1,xrmiss,xrout,yr)S_{\\text{obs}}(\\phi)=\\sum_{r:\\,\\delta_r=1} s(\\phi;\\delta=1,x^{\\text{miss}}_r,x^{\\text{}}_r,y_r) (small: one score vector per respondent). Compute non-respondent expected-score: use W(œï)W(\\phi) parameter-wise factor matrices derived s(‚ãÖ)s(\\cdot) compute Sun(œï)=‚àë=1n0‚àëj=1n1Wij(œï)s(œï;Œ¥=0,ximiss,xiout,yj)S_{\\text{un}}(\\phi)=\\sum_{=1}^{n_0}\\sum_{j=1}^{n_1} W_{ij}(\\phi)\\, s(\\phi;\\delta=0,x^{\\text{miss}}_i,x^{\\text{}}_i,y_j) implemented via matrix multiplications row/column sums. Return total score S2(œï)=Sobs(œï)+Sun(œï)S_2(\\phi)=S_{\\text{obs}}(\\phi) + S_{\\text{un}}(\\phi). root-finder searches œï\\phi S2(œï)=0S_2(\\phi)=0. package implemented repeatedly forming O(œï)O(\\phi) current candidate œï\\phi, computing W(œï)W(\\phi) S2(œï)S_2(\\phi), letting nleqslv perform iteration.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/articles/exptilt_theory.html","id":"mean-estimation-and-survey-weights","dir":"Articles","previous_headings":"","what":"Mean estimation and survey weights","title":"Exponential Tilting Theory","text":"response-model parameters œïÃÇ\\hat\\phi obtained package reports mean estimate target outcome using inverse-probability reweighting form. Let respondents indexed j=1,‚Ä¶,n1j=1,\\dots,n_1; denote œÄj=œÄ(xjmiss,yj;œïÃÇ)\\pi_j = \\pi(x^{\\text{miss}}_j,y_j;\\hat\\phi) fitted response probabilities evaluated respondent (write xjmissx^{\\text{miss}}_j covariates used missingness model evaluated respondent jj). design weights wjw_j (default wj‚â°1w_j\\equiv 1 non-survey data) point estimator computed implementation ŒºÃÇ=‚àëj=1n1wjyj/œÄj‚àëj=1n1wj/œÄj. \\hat\\mu = \\frac{\\sum_{j=1}^{n_1} w_j\\, y_j / \\pi_j}{\\sum_{j=1}^{n_1} w_j / \\pi_j}.\\tag{mean-est} Notes survey weights f1f_1 fitting: conditional-density fit used build FF can incorporate respondent sampling weights provided (implementation passes respondent weights density-fitting routine). Thus f1(‚ãÖ‚à£x;Œ≥)f_1(\\cdot\\mid x;\\gamma) may weighted fit design_weights survey design supplied. mean-estimate (mean-est) also uses design weights wjw_j numerator denominator shown . code provided via model$design_weights default 1 non-survey use. short: survey weights enter two places ‚Äî () conditional-density estimation (requested) (ii) final mean calculation weighted IPW-type ratio (mean-est).","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/articles/exptilt_theory.html","id":"arguments-passed-to-exptilt-summary","dir":"Articles","previous_headings":"","what":"Arguments passed to exptilt (summary)","title":"Exponential Tilting Theory","text":"exptilt / exptilt.data.frame user-facing function accepts number arguments control model specification computation; important : data: data.frame outcome covariates. formula: partitioned formula form y ~ aux1 + aux2 | miss1 + miss2 left part (|) lists covariates_for_outcome right part lists covariates_for_missingness (package helper splits automatically). auxiliary_means: (optional) population target means auxiliary variables used scaling. standardize: logical, whether standardize features fitting. prob_model_type: character, either \"logit\" \"probit\" select response probability family. y_dens: choice conditional-density family; \"auto\", \"normal\", \"lognormal\", \"exponential\". variance_method: \"delta\" \"bootstrap\" variance estimation. bootstrap_reps: number bootstrap replications bootstrap used. control: list control parameters forwarded nonlinear solver (nleqslv). stopping_threshold: numeric; sup-norm threshold early stopping score (see ). on_failure: behavior failure (\"return\" \"error\"). supress_warnings: logical silence certain warnings. design_weights: optional vector respondent design weights (full-sample weights subset internally). survey_design: optional survey.design object; provided internal logic uses survey path. trace_level: integer controlling verbosity. sample_size: integer stratified subsampling used data large. outcome_label, user_formula: utility arguments used presentation bookkeeping. arguments appear exptilt.data.frame function signature control matrices FF, CC, OO built solver run.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/articles/exptilt_theory.html","id":"connection-to-the-em-viewpoint","dir":"Articles","previous_headings":"","what":"Connection to the EM viewpoint","title":"Exponential Tilting Theory","text":"EM-like update displayed theoretical notes (equation (14)) œïÃÇ(t+1)‚Üêsolve S2(œï‚à£œïÃÇ(t),Œ≥ÃÇ)=0\\hat\\phi^{(t+1)} \\leftarrow \\text{solve } S_2(\\phi \\mid \\hat\\phi^{(t)},\\hat\\gamma)=0 exactly implementation achieves: fixed conditional-density estimate Œ≥ÃÇ\\hat\\gamma current œïÃÇ(t)\\hat\\phi^{(t)}, expectations missing units approximated discrete support observed yjy_j resulting equation œï\\phi solved (via root-finding). heavy-lift performed matrix calculus described earlier ‚Äî constructing FF, CC, OO computing WW multiplying parameter-wise score factors.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/articles/exptilt_theory.html","id":"stopping-criterion-maximum-norm","dir":"Articles","previous_headings":"","what":"Stopping criterion (maximum-norm)","title":"Exponential Tilting Theory","text":"Practical optimization requires convergence criterion. implementation uses maximum absolute component vector-valued score stopping rule. Concretely, solver produces score vector S2(œï)S_2(\\phi) maxm=1,‚Ä¶,p|S2,m(œï)|<Œµ\\max_{m=1,\\dots,p} |S_{2,m}(\\phi)| < \\varepsilon user-specified stopping_threshold = \\varepsilon, algorithm treats converged. code used early-exit inside target-function passed nonlinear solver: score‚Äôs sup-norm threshold, zero vector returned signal convergence avoid unnecessary computations. choice matches intuition root-finder stop estimating equations (componentwise) negligibly small.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/articles/exptilt_theory.html","id":"practical-tutorial-from-raw-data-to-matrix-operations-conceptual-steps","dir":"Articles","previous_headings":"","what":"Practical tutorial: from raw data to matrix operations (conceptual steps)","title":"Exponential Tilting Theory","text":"Fit conditional density f1(y‚à£x;Œ≥)f_1(y\\mid x;\\gamma) using respondents covariates_for_outcome. gives function evaluates f1(y,x)f_1(y, x) yy covariate row xx (used respondents non-respondents). Evaluate conditional density Cartesian product non-respondent covariates observed respondent yy values form FF (done generate_conditional_density_matrix). empirical imputation support. Think rows target non-respondents columns candidate respondent outcomes. Evaluate conditional density respondent covariates form column-normalizer CC (done generate_C_matrix) ‚Äî simply column-sum densities respondents. trial value œï\\phi response-model parameters, compute odds matrix O(œï)O(\\phi) using separable linear predictor link function (implemented efficiently via outer() code). Combine OO FF normalize columns CC obtain W(œï)W(\\phi). Use vectorized s_function obtain parameter-specific factor matrices non-respondent-imputed scores; multiply (elementwise) W(œï)W(\\phi) reduce (row/column sums) compute non-respondent contribution S2(œï)S_2(\\phi). Add observed-respondent score use root-finder (e.g.¬†nleqslv) find œï\\phi S2(œï)=0S_2(\\phi)=0. solver may use maximum-norm stopping threshold described exit early.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/articles/exptilt_theory.html","id":"why-the-vectorization-matters-practical-remarks","dir":"Articles","previous_headings":"","what":"Why the vectorization matters (practical remarks)","title":"Exponential Tilting Theory","text":"Memory: naive expansion explicit dataset size n0√ón1n_0\\times n_1 store duplicated covariate rows blow memory. implemention exploits separability (intercept + XimissŒ≤missX^{\\text{miss}}_i\\beta_{\\text{miss}} + Œ≤yyj\\beta_y y_j) vectorized R primitives (outer, matrix multiplications, column/row sums) avoid large temporary allocations. Speed: elementwise operations dense matrices plus BLAS-accelerated matrix multiplication much faster interpreted loops R typical dataset sizes. Clarity: organizing logic three matrices FF, CC, OO, followed elementwise combination reductions, makes relationship statistical approximation implementation transparent easier reason .","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/articles/exptilt_theory.html","id":"closing-notes-and-references","dir":"Articles","previous_headings":"","what":"Closing notes and references","title":"Exponential Tilting Theory","text":"vignette mapped implementation functions math theoretical notes showed EM-like mean-score step reduces small set matrix operations. implementation follows ideas described Riddles et al.¬†(2016) exponential tilting NMAR: fit conditional density respondents, approximate missing-data expectation finite sum observed yy values, solve resulting estimating equations missingness-model parameters. like, can produce minimal worked numeric example (R code) builds matrices demonstrates matrix multiplications used ‚Äî implemented small, readable functions teaching purposes ‚Äî place vignette optional appendix.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/articles/tutorial_empirical_likelihood.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Empirical Likelihood","text":"vignette demonstrates empirical likelihood (EL) estimator Missing Random (NMAR) data NMAR package. method implements estimator Qin, Leung, Shao (2002), using empirical likelihood weights satisfy estimating equations response mechanism (optionally) auxiliary moment constraints. full derivations, analytic Jacobian, variance discussion (bootstrap), see companion article ‚ÄúEmpirical Likelihood Theory NMAR‚Äù. Key features: Supports data.frame (IID) survey.design objects via nmar() API. Variance via bootstrap (IID resampling survey replicate weights). Optional standardization predictors; weight trimming robustness. Rich S3 surface: summary(), confint(), tidy(), glance(),","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/articles/tutorial_empirical_likelihood.html","id":"quick-start","dir":"Articles","previous_headings":"Overview","what":"Quick start","title":"Empirical Likelihood","text":"Variables outcome RHS (e.g., X1 + X2) auxiliaries; supply known population means via auxiliary_means = c(X1 = ..., X2 = ...). Predictors right | enter response model (auxiliary constraint) need population means. Choose engine: el_engine(...), e.g., el_engine(auxiliary_means = c(X1 = 0), variance_method = \"bootstrap\", standardize = TRUE). Fit: nmar(formula = Y_miss ~ X1 + X2 | Z1 + Z2, data = df_or_design, engine = el_engine(...)). Inspect: summary(), confint(), weights(), fitted(), fit$diagnostics. # # Data-frame example (IID) simulate NMAR mechanism response probability depends unobserved outcome. Probit family (optional): Tidy/glance summaries: Outputs diagnostics glance (probability-scale weights sum 1; population-scale weights sum analysis total NpopN_\\text{pop}): Bootstrap variance (keep reps small speed). example requires optional future.apply package; chunk runs available:","code":"knitr::opts_chunk$set(collapse = TRUE, comment = \"#>\") set.seed(123) library(NMAR)  N <- 500 X <- rnorm(N) Z <- rnorm(N) Y <- 2 + 0.5 * X + Z  # NMAR response: depends on Y p <- plogis(-1.0 + 0.4 * scale(Y)[, 1]) R <- runif(N) < p  dat <- data.frame(Y_miss = Y, X = X) dat$Y_miss[!R] <- NA_real_ engine <- el_engine(auxiliary_means = c(X = 0), variance_method = \"none\", standardize = TRUE   ) # Fit EL estimator (no variance for speed in vignette) fit <- nmar(   formula = Y_miss ~ X,   data = dat,   engine = engine )  summary(fit) #> NMAR Model Summary #> ================= #> Y_miss mean: 1.878660 #> Converged: TRUE  #> Variance method: none  #> Variance notes: Variance skipped (variance_method='none')  #> Total units: 500  #> Respondents: 150  #> Call: nmar(Y_miss ~ X, data = <data.frame: N=500>, engine = empirical_likelihood) #>  #> Missingness-model coefficients: #>              Estimate #> (Intercept) -1.570694 #> Y_miss       0.366754 # For confidence intervals, use bootstrap variance (see example below). engine <- el_engine(auxiliary_means = c(X = 0), family = \"probit\", variance_method = \"none\", standardize = TRUE)  fit_probit <- nmar(   formula = Y_miss ~ X,   engine = engine,   data = dat  ) summary(fit_probit) #> NMAR Model Summary #> ================= #> Y_miss mean: 1.880128 #> Converged: TRUE  #> Variance method: none  #> Variance notes: Variance skipped (variance_method='none')  #> Total units: 500  #> Respondents: 150  #> Call: nmar(Y_miss ~ X, data = <data.frame: N=500>, engine = empirical_likelihood) #>  #> Missingness-model coefficients: #>              Estimate #> (Intercept) -0.949678 #> Y_miss       0.217504 if (requireNamespace(\"broom\", quietly = TRUE)) {   broom::tidy(fit)   broom::glance(fit) } #>     y_hat std.error conf.low conf.high converged trimmed_fraction #> 1 1.87866        NA       NA        NA      TRUE                0 #>   variance_method jacobian_condition_number max_equation_residual #> 1            none                  36.83019           5.17808e-13 #>   min_denominator fraction_small_denominators nobs nobs_resp is_survey #> 1       0.4613402                           0  500       150     FALSE weights(fit)[1:10] #>  [1] 0.008384402 0.008937803 0.004381958 0.014450653 0.006959120 0.007160884 #>  [7] 0.005995129 0.006358571 0.007390444 0.007842733 weights(fit, scale = \"population\")[1:10] #>  [1] 4.192201 4.468901 2.190979 7.225327 3.479560 3.580442 2.997564 3.179285 #>  [9] 3.695222 3.921366 fitted(fit)[1:10] #>  [1] 0.2385382 0.2237686 0.4564170 0.1384020 0.2873926 0.2792951 0.3336042 #>  [8] 0.3145361 0.2706197 0.2550132 str(fit$diagnostics) #> List of 34 #>  $ convergence_code                  : int 1 #>  $ message                           : chr \"Function criterion near zero\" #>  $ vcov_message                      : chr \"Variance skipped (variance_method='none')\" #>  $ trimmed_fraction                  : num 0 #>  $ solver_method                     : chr \"Newton\" #>  $ nleqslv_global                    : chr NA #>  $ nleqslv_xscalm                    : chr NA #>  $ solver_iterations                 : int 7 #>  $ solver_time                       : num 0.005 #>  $ variance_time                     : num 0 #>  $ reparam_W                         : chr \"logit\" #>  $ max_equation_residual             : num 5.18e-13 #>  $ jacobian_condition_number         : num 36.8 #>  $ auxiliary_inconsistency_max_z     : num 0.114 #>  $ auxiliary_inconsistency_cols      : chr \"X\" #>  $ min_denominator                   : num 0.461 #>  $ fraction_small_denominators       : num 0 #>  $ denom_q01                         : num 0.496 #>  $ denom_q05                         : num 0.664 #>  $ denom_median                      : num 1.05 #>  $ denom_count_lt_1e4                : int 0 #>  $ denom_floor                       : num 1e-08 #>  $ denom_floor_hits                  : num 0 #>  $ weight_max_share                  : num 0.0145 #>  $ weight_top5_share                 : num 0.0665 #>  $ weight_ess                        : num 137 #>  $ constraint_sum_W                  : num -3.33e-13 #>  $ constraint_sum_aux                : Named num -5.18e-13 #>   ..- attr(*, \"names\")= chr \"X\" #>  $ sum_respondent_weights            : num 150 #>  $ sum_unnormalized_weights_untrimmed: num 150 #>  $ normalization_ratio               : num 1 #>  $ max_constraint_residual           : num 5.18e-13 #>  $ auxiliary_means                   : Named num 0 #>   ..- attr(*, \"names\")= chr \"X\" #>  $ auxiliary_matrix                  : num [1:150, 1] -0.56 -0.23 1.559 -1.265 -0.687 ... #>   ..- attr(*, \"dimnames\")=List of 2 #>   .. ..$ : chr [1:150] \"1\" \"2\" \"3\" \"8\" ... #>   .. ..$ : chr \"X\" if (requireNamespace(\"future.apply\", quietly = TRUE)) {   engine <- el_engine(auxiliary_means = c(X = 0), variance_method = \"bootstrap\", bootstrap_reps = 15, standardize = TRUE)   fit_boot <- nmar(     formula = Y_miss ~ X,     engine = engine,     data = dat   )   fit_boot$se } else {   message(\"Skipping bootstrap example: future.apply not installed\") } #> [1] 0.1879633"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/articles/tutorial_empirical_likelihood.html","id":"respondents-only-data-n_total","dir":"Articles","previous_headings":"","what":"Respondents-only data (n_total)","title":"Empirical Likelihood","text":"pass respondents-data (outcome contains NA), provide total sample size via n_total engine estimator can recover population response rate:","code":"N <- 300 X <- rnorm(N); Z <- rnorm(N); Y <- 1.5 + 0.4 * X + Z p <- plogis(-0.5 + 0.4 * scale(Y)[, 1]) R <- runif(N) < p df_resp <- subset(data.frame(Y_miss = Y, X = X), R == 1) eng_resp <- el_engine(auxiliary_means = c(X = 0), variance_method = \"none\", n_total = N) fit_resp <- nmar(Y_miss ~ X, data = df_resp, engine = eng_resp) summary(fit_resp) #> NMAR Model Summary #> ================= #> Y_miss mean: 1.105712 #> Converged: TRUE  #> Variance method: none  #> Variance notes: Variance skipped (variance_method='none')  #> Total units: 300  #> Respondents: 118  #> Call: nmar(Y_miss ~ X, data = <data.frame: N=300>, engine = empirical_likelihood) #>  #> Missingness-model coefficients: #>              Estimate #> (Intercept) -1.449030 #> Y_miss       0.826353"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/articles/tutorial_empirical_likelihood.html","id":"response-only-predictors","dir":"Articles","previous_headings":"","what":"Response-only predictors","title":"Empirical Likelihood","text":"can include predictors enter response model (constrained auxiliaries) placing right | formula. Auxiliary means formulas: Names auxiliary_means must match variables outcome RHS exactly. standardize = TRUE, engine automatically transforms auxiliary_means standardized scale internally reports coefficients original scale. Response-predictors (right |) need auxiliary means.","code":"N <- 400 X <- rnorm(N) Z <- rnorm(N) Y <- 1 + 0.6 * X + 0.3 * Z + rnorm(N) p <- plogis(-0.6 + 0.5 * scale(Y)[, 1] + 0.4 * Z) R <- runif(N) < p df2 <- data.frame(Y_miss = Y, X = X, Z = Z) df2$Y_miss[!R] <- NA_real_ engine <- el_engine(auxiliary_means = c(X = 0), variance_method = \"none\", standardize = TRUE)  # Use X as auxiliary (known population mean 0), and Z as response-only predictor fit_resp_only <- nmar(   formula = Y_miss ~ X | Z,   data = df2,   engine = engine ) summary(fit_resp_only) #> NMAR Model Summary #> ================= #> Y_miss mean: 1.422045 #> Converged: TRUE  #> Variance method: none  #> Variance notes: Variance skipped (variance_method='none')  #> Total units: 400  #> Respondents: 140  #> Call: nmar(Y_miss ~ X | Z, data = <data.frame: N=400>, engine = empirical_likelihood) #>  #> Missingness-model coefficients: #>              Estimate #> (Intercept) -0.557563 #> Y_miss      -0.044005 #> Z            0.003693"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/articles/tutorial_empirical_likelihood.html","id":"survey-design-example-optional","dir":"Articles","previous_headings":"","what":"Survey design example (optional)","title":"Empirical Likelihood","text":"estimator supports complex surveys via survey::svydesign(). chunk runs survey package available.","code":"if (requireNamespace(\"survey\", quietly = TRUE)) {   library(survey)   data(api)    set.seed(42)   apiclus1$api00_miss <- apiclus1$api00   ystd <- scale(apiclus1$api00)[, 1]   prob <- plogis(-0.5 + 0.4 * ystd + 0.2 * scale(apiclus1$ell)[, 1])   miss <- runif(nrow(apiclus1)) > prob   apiclus1$api00_miss[miss] <- NA_real_    dclus1 <- svydesign(id = ~dnum, weights = ~pw, data = apiclus1, fpc = ~fpc) # Let the engine infer auxiliary means from the full design (design-weighted). # Alternatively, you can supply known population means via auxiliary_means.   engine <- el_engine(auxiliary_means = NULL, variance_method = \"none\", standardize = TRUE)    fit_svy <- nmar(     formula = api00_miss ~ ell,     data = dclus1,     engine = engine   )   summary(fit_svy) } #> Loading required package: grid #> Loading required package: Matrix #> Loading required package: survival #>  #> Attaching package: 'survival' #> The following object is masked from 'package:future': #>  #>     cluster #>  #> Attaching package: 'survey' #> The following object is masked from 'package:graphics': #>  #>     dotchart #> NMAR Model Summary #> ================= #> api00_miss mean: 691.822197 #> Converged: TRUE  #> Variance method: none  #> Variance notes: Variance skipped (variance_method='none')  #> Total units: 6194  #> Respondents: 65  #> Call: nmar(api00_miss ~ ell, data = <survey.design: N=6194>, engine = empirical_likelihood) #>  #> Missingness-model coefficients: #>              Estimate #> (Intercept)  3.231721 #> api00_miss  -0.005586"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/articles/tutorial_empirical_likelihood.html","id":"practical-guidance","dir":"Articles","previous_headings":"","what":"Practical guidance","title":"Empirical Likelihood","text":"Variance method: Analytical delta variance EL currently disabled; use bootstrap standard errors. Trimming: Use finite trim_cap improve robustness large weights occur; prefer bootstrap variance trimming. Solver control: set control = list(xtol = 1e-10, ftol = 1e-10, maxit = 200) tighter tolerances needed. Globalization details managed internally nleqslv. Standardization: standardize = TRUE typically improves numerical stability comparability across predictors auxiliary means. Diagnostics: Inspect fit$diagnostics (Jacobian condition number, max equation residuals, trimming fraction) assess numerical health identification strength. Response-predictors: Variables right | need appear RHS outcome formula; enter response model. Auxiliary means must supplied variables outcome RHS. Inconsistent auxiliaries: provided auxiliary means grossly inconsistent sample, EL weights may go negative solver may fail. Consider revisiting constraints, relaxing , using trim_cap bootstrap variance. Troubleshooting: Negative extreme weights: set finite trim_cap; prefer variance_method = \"bootstrap\" SE. Ill-conditioned Jacobian (large fit$diagnostics$jacobian_condition_number): prefer variance_method = \"bootstrap\". may also tighten solver tolerances via control = list(xtol=..., ftol=..., maxit=...). Convergence issues: check fit$diagnostics$max_equation_residual, rescale predictors (standardize = TRUE), reduce number constraints.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/articles/tutorial_empirical_likelihood.html","id":"solver-control-and-notes","dir":"Articles","previous_headings":"","what":"Solver control and notes","title":"Empirical Likelihood","text":"Control example: increase iterations tighten tolerances via control (passed nleqslv):","code":"ctrl <- list(maxit = 200, xtol = 1e-10, ftol = 1e-10) eng_ctrl <- el_engine(auxiliary_means = c(X = 0), variance_method = \"none\", control = ctrl) invisible(nmar(Y_miss ~ X, data = dat, engine = eng_ctrl))"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/articles/tutorial_empirical_likelihood.html","id":"references-and-further-reading","dir":"Articles","previous_headings":"","what":"References and further reading","title":"Empirical Likelihood","text":"Qin, J., Leung, D., Shao, J. (2002). Estimation survey data nonignorable nonresponse informative sampling. Journal American Statistical Association, 97(457), 193-200. doi:10.1198/016214502753479338","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/articles/tutorial_empirical_likelihood.html","id":"families-and-numerical-stability","dir":"Articles","previous_headings":"","what":"Families and numerical stability","title":"Empirical Likelihood","text":"Family: el_engine(family = \"logit\") (default) family = \"probit\". Probit stability: response-model score evaluated Mills ratio œï(Œ∑)/Œ¶(Œ∑)\\phi(\\eta)/\\Phi(\\eta) log domain numerical stability; logit score simplifies 1‚àíplogis(Œ∑)1-\\mathrm{plogis}(\\eta). also cap linear predictor clip probabilities used ratios. Theory mapping: see companion article ‚ÄúEmpirical Likelihood Theory NMAR‚Äù equations, Jacobian blocks, variance details.","code":"sessionInfo() #> R version 4.5.2 (2025-10-31) #> Platform: x86_64-pc-linux-gnu #> Running under: Ubuntu 24.04.3 LTS #>  #> Matrix products: default #> BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  #> LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.26.so;  LAPACK version 3.12.0 #>  #> locale: #>  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        #>  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    #>  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           #> [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    #>  #> time zone: UTC #> tzcode source: system (glibc) #>  #> attached base packages: #> [1] grid      stats     graphics  grDevices utils     datasets  methods   #> [8] base      #>  #> other attached packages: #> [1] survey_4.4-8   survival_3.8-3 Matrix_1.7-4   future_1.68.0  NMAR_0.0.0.1   #>  #> loaded via a namespace (and not attached): #>  [1] sass_0.4.10         generics_0.1.4      tidyr_1.3.1         #>  [4] lattice_0.22-7      listenv_0.10.0      digest_0.6.39       #>  [7] magrittr_2.0.4      evaluate_1.0.5      nleqslv_3.3.5       #> [10] fastmap_1.2.0       jsonlite_2.0.0      backports_1.5.0     #> [13] DBI_1.2.3           Formula_1.2-5       purrr_1.2.0         #> [16] codetools_0.2-20    textshaping_1.0.4   jquerylib_0.1.4     #> [19] cli_3.6.5           mitools_2.4         rlang_1.1.6         #> [22] parallelly_1.45.1   future.apply_1.20.1 splines_4.5.2       #> [25] cachem_1.1.0        yaml_2.3.12         tools_4.5.2         #> [28] parallel_4.5.2      dplyr_1.1.4         globals_0.18.0      #> [31] broom_1.0.11        vctrs_0.6.5         R6_2.6.1            #> [34] lifecycle_1.0.4     fs_1.6.6            htmlwidgets_1.6.4   #> [37] ragg_1.5.0          pkgconfig_2.0.3     desc_1.4.3          #> [40] pkgdown_2.2.0       progressr_0.18.0    pillar_1.11.1       #> [43] bslib_0.9.0         Rcpp_1.1.0          glue_1.8.0          #> [46] systemfonts_1.3.1   xfun_0.54           tibble_3.3.0        #> [49] tidyselect_1.2.1    knitr_1.50          htmltools_0.5.9     #> [52] rmarkdown_2.30      compiler_4.5.2"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/articles/tutorial_empirical_likelihood.html","id":"notes-on-variance-choices","dir":"Articles","previous_headings":"","what":"Notes on variance choices","title":"Empirical Likelihood","text":"Analytical delta variance EL implemented version. Use variance_method = \"bootstrap\" SEs. speed-critical bootstraps, can set variance_method = \"none\" point fits let bootstrap call use internally replicates (default behavior request bootstrap SEs el_engine(...)).","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Maciej Berƒôsewicz. Author, maintainer. Igor Ko≈Çodziej. Author. Mateusz Iwaniuk. Author.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Berƒôsewicz M, Ko≈Çodziej , Iwaniuk M (2025). NMAR: Missing Random. R package version 0.0.0.1, https://github.com/ncn-foreigners/NMAR.","code":"@Manual{,   title = {NMAR: Not Missing at Random},   author = {Maciej Berƒôsewicz and Igor Ko≈Çodziej and Mateusz Iwaniuk},   year = {2025},   note = {R package version 0.0.0.1},   url = {https://github.com/ncn-foreigners/NMAR}, }"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/index.html","id":"nmar","dir":"","previous_headings":"","what":"Not Missing at Random","title":"Not Missing at Random","text":"goal NMAR provide set functions estimate population mean data subject Missing Random (NMAR) mechanisms using advanced statistical methods","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"Not Missing at Random","text":"NMAR library provides functions estimate mean Missing Random (NMAR) data. estimation functions built upon following engine functions, implementing distinct method: exptilt_engine: Exponential Tilting Estimator Minsun Kim Riddles, Jae Kwang Kim, Jongho Im Propensity-score-adjustment Method Nonignorable Nonresponsehttps://doi.org/10.1093/jssam/smv047 exptilt_nonparam_engine: Nonparametric Exponential Tilting Estimator Minsun Kim Riddles, Jae Kwang Kim, Jongho Im Propensity-score-adjustment Method Nonignorable Nonresponse Appendix 2https://doi.org/10.1093/jssam/smv047 el_engine: Empirical Likelihood Estimator Jing Qin, Denis Leung, Jun Shao Estimation Survey Data Nonignorable Nonresponse Informative Samplinghttp://dx.doi.org/10.1198/016214502753479338 main user-facing function nmar(), acts unified wrapper around engine functions.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Not Missing at Random","text":"can install development version NMAR GitHub : ","code":"# install.packages(\"pak\") pak::pak(\"ncn-foreigners/NMAR\") remotes::install_github(\"ncn-foreigners/NMAR@main\", force = T, build = T, build_manual = T, build_vignettes = T)"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/index.html","id":"project-branches","dir":"","previous_headings":"Installation","what":"Project branches:","title":"Not Missing at Random","text":"main - stable production branch. version install general use package-pre_prod - pre-production development branch. stable, installable version reflecting latest features. (1:1 clone package-dev) package-dev - internal development branch. branch uses non-R package structure internal development purposes. download install branch. contribution guidelines, please see CONTRIBUTING.md file [project webpage (TODO: add link webpage)]","code":""},{"path":[]},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/index.html","id":"general-naming","dir":"","previous_headings":"Usage","what":"General naming","title":"Not Missing at Random","text":"outcome_var (f.e Y): outcome variable (missing values). covariates_for_outcome(f.e x1,x2): Predictors outcome_var value (used response model). covariates_for_missingness(f.e x3): Predictor outcome_var missingness (used missingness model). formula = outcome_var ~ covariates_for_outcome","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/index.html","id":"example","dir":"","previous_headings":"Usage","what":"Example","title":"Not Missing at Random","text":", salary survey, richer people less likely answer, Y salary, x1 x2 experience education, x3 might gender (assume gender affects likelihood responding salary value ).","code":"library(NMAR, quietly = T)  exptilt_config <- exptilt_engine(   y_dens = 'normal',   family = 'probit', # or logit   variance_method = 'bootstrap', # or delta   bootstrap_reps = 10 )  formula = y ~ x res <- nmar(formula = formula, data = riddles_case1, engine = exptilt_config, trace_level = 0) print(coef(res)) #> (Intercept)           y  #>   0.5330497  -0.1026425 print(res) #> NMAR Result #> ------------ #> y mean: -1.002967 (0.055358) #> Converged: TRUE  #> Variance method: bootstrap  #> Estimator: exponential_tilting"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/index.html","id":"getting-help","dir":"","previous_headings":"","what":"Getting help","title":"Not Missing at Random","text":"encounter clear bug, please file issue minimal reproducible example GitHub","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/index.html","id":"authors-and-acknowledgments","dir":"","previous_headings":"","what":"Authors and acknowledgments","title":"Not Missing at Random","text":"Research grant: OPUS 20 #2020/39/B/HS4/00941 Maciej Berƒôsewicz Igor Ko≈Çodziej Mateusz Iwaniuk","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/apply_nmar_scaling.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply scaling to a matrix using a recipe ‚Äî apply_nmar_scaling","title":"Apply scaling to a matrix using a recipe ‚Äî apply_nmar_scaling","text":"Apply scaling matrix using recipe","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/apply_nmar_scaling.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply scaling to a matrix using a recipe ‚Äî apply_nmar_scaling","text":"","code":"apply_nmar_scaling(matrix_to_scale, recipe)"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/apply_nmar_scaling.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Apply scaling to a matrix using a recipe ‚Äî apply_nmar_scaling","text":"matrix_to_scale numeric matrix column names present `recipe`. recipe object class `nmar_scaling_recipe`.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/apply_nmar_scaling.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Apply scaling to a matrix using a recipe ‚Äî apply_nmar_scaling","text":"matrix named column centered scaled using recipe","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/bootstrap_variance.data.frame.html","id":null,"dir":"Reference","previous_headings":"","what":"Bootstrap for i.i.d. data.frames ‚Äî bootstrap_variance.data.frame","title":"Bootstrap for i.i.d. data.frames ‚Äî bootstrap_variance.data.frame","text":"Bootstrap ..d. data.frames","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/bootstrap_variance.data.frame.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Bootstrap for i.i.d. data.frames ‚Äî bootstrap_variance.data.frame","text":"","code":"bootstrap_variance.data.frame(   data,   estimator_func,   point_estimate,   bootstrap_reps = 500,   ... )"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/bootstrap_variance.data.frame.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Bootstrap for i.i.d. data.frames ‚Äî bootstrap_variance.data.frame","text":"data `data.frame` `survey.design`. estimator_func function returns S3 result object; primary estimate extracted via `$y_hat` convergence via `$converged`. point_estimate numeric; point estimate used survey variance formulas. bootstrap_reps integer; number resamples. ... passed `estimator_func`.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/bootstrap_variance.data.frame.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Bootstrap for i.i.d. data.frames ‚Äî bootstrap_variance.data.frame","text":"list `se`, `variance`, vector `replicates`.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/bootstrap_variance.default.html","id":null,"dir":"Reference","previous_headings":"","what":"Default method dispatch (internal safety net) ‚Äî bootstrap_variance.default","title":"Default method dispatch (internal safety net) ‚Äî bootstrap_variance.default","text":"Default method dispatch (internal safety net)","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/bootstrap_variance.default.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Default method dispatch (internal safety net) ‚Äî bootstrap_variance.default","text":"","code":"bootstrap_variance.default(data, estimator_func, point_estimate, ...)"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/bootstrap_variance.html","id":null,"dir":"Reference","previous_headings":"","what":"Shared bootstrap variance helpers ‚Äî bootstrap_variance","title":"Shared bootstrap variance helpers ‚Äî bootstrap_variance","text":"Internal helpers estimate variance scalar estimator   via bootstrap resampling (IID data) bootstrap replicate weights   (survey designs). Designed reused across NMAR engines.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/bootstrap_variance.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Shared bootstrap variance helpers ‚Äî bootstrap_variance","text":"","code":"bootstrap_variance(data, estimator_func, point_estimate, ...)"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/bootstrap_variance.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Shared bootstrap variance helpers ‚Äî bootstrap_variance","text":"data `data.frame` `survey.design`. estimator_func function returns S3 result object; primary estimate extracted via `$y_hat` convergence via `$converged`. point_estimate numeric; point estimate used survey variance formulas. ... passed `estimator_func`.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/bootstrap_variance.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Shared bootstrap variance helpers ‚Äî bootstrap_variance","text":"- `data.frame` inputs, performs IID bootstrap resampling rows     rerunning `estimator_func` resample, computing empirical     variance replicate estimates.   - `survey.design` inputs, converts design bootstrap     replicate-weight design `svrep::as_bootstrap_design()`, reconstructs     original sampling design replicate weight vector, passes     resulting replicate estimates replicate scaling factors     `survey::svrVar()`. `estimator_func` typically engine-level estimator (example   EL engine) called arguments used point   estimate, except `data` argument replaced resampled data   (IID) replicate `survey.design` (survey).","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/bootstrap_variance.html","id":"progress-reporting","dir":"Reference","previous_headings":"","what":"Progress Reporting","title":"Shared bootstrap variance helpers ‚Äî bootstrap_variance","text":"optional progressr package installed, bootstrap calls   signal progress via progressr::progressor inside   progressr::with_progress(). Users control whether progress shown   () registering handlers progressr::handlers().   progressr installed handlers active, bootstrap runs   silently. Progress reporting compatible future backends.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/bootstrap_variance.html","id":"reproducibility","dir":"Reference","previous_headings":"","what":"Reproducibility","title":"Shared bootstrap variance helpers ‚Äî bootstrap_variance","text":"reproducible bootstrap results, always set seed calling   estimation function:  future framework (via future.seed = TRUE   future.apply::future_lapply()) ensures bootstrap replicate   uses independent L'Ecuyer-CMRG random number stream derived   seed. gives reproducible results across supported future backends   (sequential, multisession, cluster, ).","code":"set.seed(123)  # Set seed for reproducibility   result <- nmar(Y ~ X, data = df,                  engine = el_engine(variance_method = \"bootstrap\",                                     bootstrap_reps = 500))"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/bootstrap_variance.survey.design.html","id":null,"dir":"Reference","previous_headings":"","what":"Bootstrap for survey designs via replicate weights ‚Äî bootstrap_variance.survey.design","title":"Bootstrap for survey designs via replicate weights ‚Äî bootstrap_variance.survey.design","text":"Bootstrap survey designs via replicate weights","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/bootstrap_variance.survey.design.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Bootstrap for survey designs via replicate weights ‚Äî bootstrap_variance.survey.design","text":"","code":"bootstrap_variance.survey.design(   data,   estimator_func,   point_estimate,   bootstrap_reps = 500,   survey_na_policy = c(\"strict\", \"omit\"),   ... )"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/bootstrap_variance.survey.design.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Bootstrap for survey designs via replicate weights ‚Äî bootstrap_variance.survey.design","text":"data `data.frame` `survey.design`. estimator_func function returns S3 result object; primary estimate extracted via `$y_hat` convergence via `$converged`. point_estimate numeric; point estimate used survey variance formulas. bootstrap_reps integer; number bootstrap replicates. survey_na_policy Character string specifying handle replicates fail produce estimates. Options: \"strict\" (default) failed replicate causes error.     ensures full replicate design structure maintained     required proper calibration-based variance. \"omit\" Failed replicates omitted. corresponding     rscales also omitted maintain correct variance scaling.     Use caution: failures non-random, variance may biased. ... passed `estimator_func`.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/bootstrap_variance.survey.design.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Bootstrap for survey designs via replicate weights ‚Äî bootstrap_variance.survey.design","text":"list `se`, `variance`, vector `replicates`.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/bootstrap_variance.survey.design.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Bootstrap for survey designs via replicate weights ‚Äî bootstrap_variance.survey.design","text":"path constructs replicate-weight design using   [svrep::as_bootstrap_design()] rebuilds original sampling design   replicate weight vector. supplied design must created   directly [survey::svydesign()]. NA policy: default, survey bootstrap uses strict NA policy:   replicate fails produce finite estimate, entire bootstrap   fails error. ensures full replicate design structure   maintained design-calibrated variance via survey::svrVar().   contrast, IID bootstrap allows 10% failures warning   uses stats::var() successful replicates.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/bootstrap_variance.survey.design.html","id":"limitations","dir":"Reference","previous_headings":"","what":"Limitations","title":"Bootstrap for survey designs via replicate weights ‚Äî bootstrap_variance.survey.design","text":"Design reconstruction: Survey bootstrap currently supports   designs created directly survey::svydesign(). Post-hoc   adjustments applied via survey::calibrate(),   survey::postStratify(), survey::rake()   reconstructed across bootstrap replicates cause function   error. Calibrated post-stratified designs supported bootstrap   path. Start original `survey::svydesign()` object prior   calibration/post-stratification. Supported design features: following svydesign()   parameters preserved reconstruction: ids (id): Sampling unit identifiers strata: Stratification variables fpc: Finite population correction nest: Nested vs non-nested strata following preserved (conflict replicate weights): probs: Sampling probabilities (incompatible direct weights) pps: PPS sampling specification (incompatible direct weights) Rationale: reconstructing designs replicate,   original analysis weights replaced bootstrap replicate weights.   Specifying weights probs/pps simultaneously   undefined behavior survey::svydesign(). structural   design parameters (ids, strata, fpc, nest) define sampling topology   preserved; weights define analysis weights   replaced.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/coef.nmar_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Default coefficients for NMAR results ‚Äî coef.nmar_result","title":"Default coefficients for NMAR results ‚Äî coef.nmar_result","text":"Returns missingness-model coefficients available.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/coef.nmar_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Default coefficients for NMAR results ‚Äî coef.nmar_result","text":"","code":"# S3 method for class 'nmar_result' coef(object, ...)"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/coef.nmar_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Default coefficients for NMAR results ‚Äî coef.nmar_result","text":"object `nmar_result` object. ... Ignored.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/coef.nmar_result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Default coefficients for NMAR results ‚Äî coef.nmar_result","text":"named numeric vector `NULL`.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/coef.summary_nmar_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Coefficient table for summary objects ‚Äî coef.summary_nmar_result","title":"Coefficient table for summary objects ‚Äî coef.summary_nmar_result","text":"Returns coefficients table (Estimate, Std. Error, statistic, p-value) `summary_nmar_result*` object missingness-model coefficients variance matrix available. summary carry missingness-model coefficients, returns `NULL`.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/coef.summary_nmar_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coefficient table for summary objects ‚Äî coef.summary_nmar_result","text":"","code":"# S3 method for class 'summary_nmar_result' coef(object, ...)"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/coef.summary_nmar_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coefficient table for summary objects ‚Äî coef.summary_nmar_result","text":"object object class `summary_nmar_result` (subclass). ... Ignored.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/coef.summary_nmar_result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Coefficient table for summary objects ‚Äî coef.summary_nmar_result","text":"data.frame rows named coefficient, `NULL` available.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/coef.summary_nmar_result.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Coefficient table for summary objects ‚Äî coef.summary_nmar_result","text":"statistic column labelled \"t value\" finite degrees freedom available (e.g., survey designs); otherwise, labelled \"z value\".","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/compute_weighted_stats.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute (possibly weighted) mean and standard deviation ‚Äî compute_weighted_stats","title":"Compute (possibly weighted) mean and standard deviation ‚Äî compute_weighted_stats","text":"Compute (possibly weighted) mean standard deviation","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/compute_weighted_stats.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute (possibly weighted) mean and standard deviation ‚Äî compute_weighted_stats","text":"","code":"compute_weighted_stats(values, weights = NULL)"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/confint.nmar_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Wald confidence interval for base NMAR results ‚Äî confint.nmar_result","title":"Wald confidence interval for base NMAR results ‚Äî confint.nmar_result","text":"Wald confidence interval base NMAR results","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/confint.nmar_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Wald confidence interval for base NMAR results ‚Äî confint.nmar_result","text":"","code":"# S3 method for class 'nmar_result' confint(object, parm, level = 0.95, ...)"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/confint.nmar_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Wald confidence interval for base NMAR results ‚Äî confint.nmar_result","text":"object object class `nmar_result`. parm Ignored. level Confidence level. ... Ignored.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/confint.summary_nmar_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Confidence intervals for coefficient table (summary objects) ‚Äî confint.summary_nmar_result","title":"Confidence intervals for coefficient table (summary objects) ‚Äî confint.summary_nmar_result","text":"Returns Wald-style confidence intervals missingness-model coefficients `summary_nmar_result*` object. Uses t-quantiles finite degrees freedom available, otherwise normal quantiles.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/confint.summary_nmar_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Confidence intervals for coefficient table (summary objects) ‚Äî confint.summary_nmar_result","text":"","code":"# S3 method for class 'summary_nmar_result' confint(object, parm, level = 0.95, ...)"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/confint.summary_nmar_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Confidence intervals for coefficient table (summary objects) ‚Äî confint.summary_nmar_result","text":"object object class `summary_nmar_result` (subclass). parm specification coefficients given confidence intervals, either vector names vector indices; default, coefficients considered. level confidence level required. ... Ignored.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/confint.summary_nmar_result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Confidence intervals for coefficient table (summary objects) ‚Äî confint.summary_nmar_result","text":"numeric matrix columns giving lower upper confidence limits parameter.   Row names correspond coefficient names. Returns `NULL` coefficients unavailable.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/constraint_summaries.html","id":null,"dir":"Reference","previous_headings":"","what":"Constraint summaries for EL diagnostics ‚Äî constraint_summaries","title":"Constraint summaries for EL diagnostics ‚Äî constraint_summaries","text":"Constraint summaries EL diagnostics","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/constraint_summaries.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Constraint summaries for EL diagnostics ‚Äî constraint_summaries","text":"","code":"constraint_summaries(w_i_hat, W_hat, mass_untrim, X_centered)"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/create_nmar_scaling_recipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Build a scaling recipe from one or more design matrices ‚Äî create_nmar_scaling_recipe","title":"Build a scaling recipe from one or more design matrices ‚Äî create_nmar_scaling_recipe","text":"Build scaling recipe one design matrices","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/create_nmar_scaling_recipe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Build a scaling recipe from one or more design matrices ‚Äî create_nmar_scaling_recipe","text":"","code":"create_nmar_scaling_recipe(   ...,   intercept_col = \"(Intercept)\",   weights = NULL,   weight_mask = NULL,   tol_constant = 1e-08,   warn_on_constant = TRUE )"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/create_nmar_scaling_recipe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Build a scaling recipe from one or more design matrices ‚Äî create_nmar_scaling_recipe","text":"... one matrices named columns. intercept_col Intercept column name remain unscaled. weights Optional numeric vector weights used compute weighted means/standard deviations. weight_mask Optional logical/ numeric mask applied `weights` computing moments (useful respondents-scaling). tol_constant Numeric tolerance columns treated constant left unscaled. warn_on_constant Logical; emit warning column treated constant.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/create_verboser.html","id":null,"dir":"Reference","previous_headings":"","what":"Create Verbose Printer Factory ‚Äî create_verboser","title":"Create Verbose Printer Factory ‚Äî create_verboser","text":"Creates verbose printing function based trace level settings. Messages printed level <= trace_level.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/create_verboser.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create Verbose Printer Factory ‚Äî create_verboser","text":"","code":"create_verboser(trace_level = 0)"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/create_verboser.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create Verbose Printer Factory ‚Äî create_verboser","text":"trace_level Integer 0-3; controls verbosity detail: - 0: output (silent mode) - 1: Major steps (initialization, convergence) - 2: Moderate detail (iteration summaries, key diagnostics) - 3: Full detail (diagnostics, intermediate values)","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/create_verboser.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create Verbose Printer Factory ‚Äî create_verboser","text":"function signature:   `verboser(msg, level = 1, type = c(\"info\", \"step\", \"detail\", \"result\"))`","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el.html","id":null,"dir":"Reference","previous_headings":"","what":"Empirical likelihood estimator ‚Äî el","title":"Empirical likelihood estimator ‚Äî el","text":"Generic empirical likelihood (EL) estimator NMAR.   Methods provided `data.frame` `survey.design`.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Empirical likelihood estimator ‚Äî el","text":"","code":"el(data, ...)"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Empirical likelihood estimator ‚Äî el","text":"data `data.frame` `survey.design`. ... Passed class-specific methods.","code":""},{"path":[]},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_assert_no_offset.html","id":null,"dir":"Reference","previous_headings":"","what":"Assert that terms object lacks offsets ‚Äî el_assert_no_offset","title":"Assert that terms object lacks offsets ‚Äî el_assert_no_offset","text":"Assert terms object lacks offsets","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_assert_no_offset.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Assert that terms object lacks offsets ‚Äî el_assert_no_offset","text":"","code":"el_assert_no_offset(terms_obj, label)"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_augment_strata_aux.html","id":null,"dir":"Reference","previous_headings":"","what":"Strata augmentation for survey designs ‚Äî el_augment_strata_aux","title":"Strata augmentation for survey designs ‚Äî el_augment_strata_aux","text":"Augments auxiliary design strata dummies (dropping one level) appends stratum-share means weights N_pop available. Intended survey workflows .","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_augment_strata_aux.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Strata augmentation for survey designs ‚Äî el_augment_strata_aux","text":"","code":"el_augment_strata_aux(   aux_design_full,   strata_factor,   weights_full,   N_pop,   auxiliary_means )"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_build_equation_system.html","id":null,"dir":"Reference","previous_headings":"","what":"Empirical likelihood estimating equations ‚Äî el_build_equation_system","title":"Empirical likelihood estimating equations ‚Äî el_build_equation_system","text":"Empirical likelihood estimating equations","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_build_equation_system.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Empirical likelihood estimating equations ‚Äî el_build_equation_system","text":"","code":"el_build_equation_system(   family,   missingness_model_matrix,   auxiliary_matrix,   respondent_weights,   N_pop,   n_resp_weighted,   mu_x_scaled )"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_build_equation_system.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Empirical likelihood estimating equations ‚Äî el_build_equation_system","text":"Returns function evaluates stacked EL system   \\(\\theta = (\\beta, z, \\lambda_x)\\) \\(z = \\operatorname{logit}(W)\\).   Blocks correspond : () missingness (response) model score equations \\(\\beta\\),   (ii) response-rate equation \\(W\\), (iii) auxiliary moment   constraints \\(\\lambda_x\\). auxiliaries present last   block omitted. system matches Qin, Leung, Shao (2002, Eqs. 7-10)   empirical masses \\(m_i = d_i/D_i(\\theta)\\), \\(D_i\\) paper.   cap \\(\\eta\\), clip \\(p\\), guard \\(D_i\\) away zero   ensure numerical stability; safeguards applied consistently   equations, Jacobian, post-solution weights. Guarding policy (must remain consistent across equations/Jacobian/post):   - Cap eta: eta <- pmax(pmin(eta, get_eta_cap()), -get_eta_cap())   - Compute w <- family$linkinv(eta); clip [1e-12, 1-1e-12] used ratios   - Denominator floor: Di <- pmax(Di_raw, nmar_get_el_denom_floor());     Jacobian, multiply terms depend d(1/Di)/d(.)     active = 1(Di_raw > floor) score respect linear predictor uses Bernoulli form   \\(s_{\\eta,}(\\beta) = \\partial \\log w_i / \\partial \\eta_i = \\mu.\\eta(\\eta_i)/w_i\\),   valid logit probit links \\(w_i\\) clipped.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_build_equation_system.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Empirical likelihood estimating equations ‚Äî el_build_equation_system","text":"Qin, J., Leung, D., Shao, J. (2002). Estimation survey data nonignorable nonresponse informative sampling. Journal American Statistical Association, 97(457), 193-200.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_build_equation_system_survey.html","id":null,"dir":"Reference","previous_headings":"","what":"Empirical likelihood equations for survey designs (design-weighted QLS system) ‚Äî el_build_equation_system_survey","title":"Empirical likelihood equations for survey designs (design-weighted QLS system) ‚Äî el_build_equation_system_survey","text":"Empirical likelihood equations survey designs (design-weighted QLS system)","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_build_equation_system_survey.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Empirical likelihood equations for survey designs (design-weighted QLS system) ‚Äî el_build_equation_system_survey","text":"","code":"el_build_equation_system_survey(   family,   missingness_model_matrix,   auxiliary_matrix,   respondent_weights,   N_pop,   n_resp_weighted,   mu_x_scaled )"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_build_equation_system_survey.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Empirical likelihood equations for survey designs (design-weighted QLS system) ‚Äî el_build_equation_system_survey","text":"Returns function evaluates stacked EL system complex survey   designs using design weights. Unknowns   \\(\\theta = (\\beta, z, \\lambda_W, \\lambda_x)\\) \\(z = \\operatorname{logit}(W)\\).   Blocks correspond : response-model score equations \\(\\beta\\), response-rate equation \\(W\\) based \\(\\sum d_i (w_i - W)/D_i = 0\\), auxiliary moment constraints \\(\\sum d_i (X_i - \\mu_x)/D_i = 0\\), design-based linkage \\(\\lambda_W\\)       nonrespondent total: \\(T_0/(1-W) - \\lambda_W \\sum d_i / D_i = 0\\),       \\(T_0 = N_{\\mathrm{pop}} - \\sum d_i\\) analysis scale. design weights equal \\(N_{\\mathrm{pop}}\\) respondent   count match simple random sampling setup, system reduces   Qin, Leung, Shao (2002) equations (6)-(10).","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_build_jacobian.html","id":null,"dir":"Reference","previous_headings":"","what":"Analytical Jacobian for empirical likelihood ‚Äî el_build_jacobian","title":"Analytical Jacobian for empirical likelihood ‚Äî el_build_jacobian","text":"Analytical Jacobian empirical likelihood","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_build_jacobian.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Analytical Jacobian for empirical likelihood ‚Äî el_build_jacobian","text":"","code":"el_build_jacobian(   family,   missingness_model_matrix,   auxiliary_matrix,   respondent_weights,   N_pop,   n_resp_weighted,   mu_x_scaled )"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_build_jacobian.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Analytical Jacobian for empirical likelihood ‚Äî el_build_jacobian","text":"Builds block Jacobian \\(= \\partial F/\\partial \\theta\\)   EL system \\(\\theta = (\\beta, z, \\lambda_x)\\) \\(z = \\operatorname{logit}(W)\\).   Blocks follow Qin, Leung, Shao (2002, Eqs. 7-10). derivative   respect linear predictor missingness (response) model uses Bernoulli score form   \\(\\partial/\\partial\\eta\\, \\log w(\\eta) = \\mu.\\eta(\\eta)/w(\\eta)\\)   link-inverse clipping. Denominator guards applied consistently   forming terms depending \\(D_i(\\theta)\\). Guarding policy (must remain consistent across equations/Jacobian/post):   - Cap eta: eta <- pmax(pmin(eta, get_eta_cap()), -get_eta_cap())   - Compute w <- family$linkinv(eta); clip [1e-12, 1-1e-12] used ratios   - Denominator floor: Di <- pmax(Di_raw, nmar_get_el_denom_floor());     multiply terms depend d(1/Di)/d(.) active = 1(Di_raw > floor)","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_build_jacobian.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Analytical Jacobian for empirical likelihood ‚Äî el_build_jacobian","text":"Qin, J., Leung, D., Shao, J. (2002). Estimation survey data nonignorable nonresponse informative sampling. Journal American Statistical Association, 97(457), 193-200.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_build_jacobian_survey.html","id":null,"dir":"Reference","previous_headings":"","what":"Analytical Jacobian for survey EL system (design-weighted QLS analogue) ‚Äî el_build_jacobian_survey","title":"Analytical Jacobian for survey EL system (design-weighted QLS analogue) ‚Äî el_build_jacobian_survey","text":"Analytical Jacobian survey EL system (design-weighted QLS analogue)","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_build_jacobian_survey.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Analytical Jacobian for survey EL system (design-weighted QLS analogue) ‚Äî el_build_jacobian_survey","text":"","code":"el_build_jacobian_survey(   family,   missingness_model_matrix,   auxiliary_matrix,   respondent_weights,   N_pop,   n_resp_weighted,   mu_x_scaled )"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_build_jacobian_survey.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Analytical Jacobian for survey EL system (design-weighted QLS analogue) ‚Äî el_build_jacobian_survey","text":"Builds block Jacobian \\(= \\partial g/\\partial \\theta\\)   survey EL system \\(\\theta = (\\beta, z, \\lambda_W, \\lambda_x)\\)   \\(z = \\operatorname{logit}(W)\\). Blocks follow design-weighted analogue   Qin, Leung, Shao (2002) used el_build_equation_system_survey().   Guarding policy matches IID Jacobian: cap eta: eta <- pmax(pmin(eta, get_eta_cap()), -get_eta_cap()) compute w <- family$linkinv(eta) clip [1e-12, 1-1e-12]       used ratios denominator floor: Di <- pmax(Di_raw, nmar_get_el_denom_floor());       multiply terms depending d(1/Di)/d(.) active = 1(Di_raw > floor) Jacobian uses score second-derivative machinery   el_build_jacobian(); family$d2mu.deta2 missing,   function returns NULL solver falls back numeric/Broyden   Jacobians.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_build_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Build EL result object (success or failure) ‚Äî el_build_result","title":"Build EL result object (success or failure) ‚Äî el_build_result","text":"Build EL result object (success failure)","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_build_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Build EL result object (success or failure) ‚Äî el_build_result","text":"","code":"el_build_result(   core_results,   inputs,   call,   formula,   engine_name = \"empirical_likelihood\" )"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_build_start.html","id":null,"dir":"Reference","previous_headings":"","what":"Build starting values for the EL solver (beta, z, lambda) ‚Äî el_build_start","title":"Build starting values for the EL solver (beta, z, lambda) ‚Äî el_build_start","text":"Build starting values EL solver (beta, z, lambda)","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_build_start.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Build starting values for the EL solver (beta, z, lambda) ‚Äî el_build_start","text":"","code":"el_build_start(   missingness_model_matrix_scaled,   auxiliary_matrix_scaled,   nmar_scaling_recipe,   start,   N_pop,   respondent_weights )"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_check_auxiliary_inconsistency_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Check auxiliary means consistency against respondents' sample support. ‚Äî el_check_auxiliary_inconsistency_matrix","title":"Check auxiliary means consistency against respondents' sample support. ‚Äî el_check_auxiliary_inconsistency_matrix","text":"Computes simple z-score diagnostic comparing user-supplied auxiliary means respondents' sample means. caller responsible comparing returned maximum z-score desired threshold.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_check_auxiliary_inconsistency_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check auxiliary means consistency against respondents' sample support. ‚Äî el_check_auxiliary_inconsistency_matrix","text":"","code":"el_check_auxiliary_inconsistency_matrix(   auxiliary_matrix_resp,   provided_means = NULL )"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_check_auxiliary_inconsistency_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check auxiliary means consistency against respondents' sample support. ‚Äî el_check_auxiliary_inconsistency_matrix","text":"auxiliary_matrix_resp Respondent-side auxiliary design matrix. provided_means Optional named numeric vector auxiliary means aligned matrix columns.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_check_auxiliary_inconsistency_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check auxiliary means consistency against respondents' sample support. ‚Äî el_check_auxiliary_inconsistency_matrix","text":"list(max_z = numeric(1) NA, cols = character())","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_compute_diagnostics.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute diagnostics at the EL solution ‚Äî el_compute_diagnostics","title":"Compute diagnostics at the EL solution ‚Äî el_compute_diagnostics","text":"Compute diagnostics EL solution","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_compute_diagnostics.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute diagnostics at the EL solution ‚Äî el_compute_diagnostics","text":"","code":"el_compute_diagnostics(   estimates,   equation_system_func,   analytical_jac_func,   post,   respondent_weights,   auxiliary_matrix_scaled,   K_beta,   K_aux,   X_centered )"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_compute_variance.html","id":null,"dir":"Reference","previous_headings":"","what":"Variance driver for EL (bootstrap or none) ‚Äî el_compute_variance","title":"Variance driver for EL (bootstrap or none) ‚Äî el_compute_variance","text":"Variance driver EL (bootstrap none)","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_compute_variance.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Variance driver for EL (bootstrap or none) ‚Äî el_compute_variance","text":"","code":"el_compute_variance(   y_hat,   full_data,   formula,   N_pop,   variance_method,   bootstrap_reps,   standardize,   trim_cap,   on_failure,   auxiliary_means,   control,   start,   family )"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_core_helpers.html","id":null,"dir":"Reference","previous_headings":"","what":"EL core helpers ‚Äî el_core_helpers","title":"EL core helpers ‚Äî el_core_helpers","text":"Internal helpers solving post-processing EL system.   `el_run_solver()` orchestrates `nleqslv` small, deterministic fallback   ladder; `el_post_solution()` computes masses point estimate   denominator guards optional trimming.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_dataframe.html","id":null,"dir":"Reference","previous_headings":"","what":"Empirical likelihood for data frames (NMAR) ‚Äî el_dataframe","title":"Empirical likelihood for data frames (NMAR) ‚Äî el_dataframe","text":"Internal method dispatched `el()` `data` `data.frame`.   Returns `c('nmar_result_el','nmar_result')` point estimate, optional   bootstrap SE, weights, coefficients, diagnostics, metadata.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_dataframe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Empirical likelihood for data frames (NMAR) ‚Äî el_dataframe","text":"","code":"# S3 method for class 'data.frame' el(   data,   formula,   auxiliary_means = NULL,   standardize = TRUE,   trim_cap = Inf,   control = list(),   on_failure = c(\"return\", \"error\"),   variance_method = c(\"delta\", \"bootstrap\", \"none\"),   bootstrap_reps = 500,   n_total = NULL,   start = NULL,   trace_level = 0,   family = logit_family(),   ... )"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_dataframe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Empirical likelihood for data frames (NMAR) ‚Äî el_dataframe","text":"data `data.frame` outcome column contains `NA` nonrespondents. formula Two-sided formula `Y_miss ~ auxiliaries` `Y_miss ~ auxiliaries | missingness_predictors`. auxiliary_means Named numeric vector population means auxiliary design columns. Names must match materialized `model.matrix` columns first RHS (formula expansion), including factor indicators transformed terms. intercept always excluded. standardize Logical; whether standardize predictors prior estimation. trim_cap Numeric; cap EL weights (`Inf` = trimming). control List; optional solver control parameters `nleqslv(control=...)`. on_failure Character; one `\"return\"` `\"error\"` solver failure. variance_method Character; one `\"delta\"`, `\"bootstrap\"`, `\"none\"`. bootstrap_reps Integer; number bootstrap reps `variance_method = \"bootstrap\"`. n_total Optional integer population size. outcome contains least one `NA`, `n_total` defaults `nrow(data)`; respondents-data supplied (`NA` outcome), `n_total` must provided. start Optional list starting values passed solver helpers. trace_level Integer 0-3 controlling estimator logging detail. family Missingness (response) model family specification (defaults logit bundle). ... Additional arguments passed solver.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_dataframe.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Empirical likelihood for data frames (NMAR) ‚Äî el_dataframe","text":"Implements empirical likelihood estimator IID data   optional auxiliary moment constraints. missingness-model score   Bernoulli derivative respect linear predictor, supporting logit   probit links. respondents-data supplied (`NA`   outcome), `n_total` required response-rate equation targets   full sample size. missingness observed (`NA` present), default   population total `nrow(data)`. respondents-data used   auxiliaries requested, must also provide population auxiliary   means via `auxiliary_means`. Result weights unnormalized EL   masses d_i/D_i(theta) analysis scale.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_dataframe.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Empirical likelihood for data frames (NMAR) ‚Äî el_dataframe","text":"Qin, J., Leung, D., Shao, J. (2002). Estimation survey data nonignorable nonresponse informative sampling. Journal American Statistical Association, 97(457), 193-200.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_denominator.html","id":null,"dir":"Reference","previous_headings":"","what":"Build denominator and floor pack ‚Äî el_denominator","title":"Build denominator and floor pack ‚Äî el_denominator","text":"Build denominator floor pack","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_denominator.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Build denominator and floor pack ‚Äî el_denominator","text":"","code":"el_denominator(lambda_W, W, Xc_lambda, p_i, floor)"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_denominator.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Build denominator and floor pack ‚Äî el_denominator","text":"lambda_W numeric scalar W numeric scalar (0,1) Xc_lambda numeric vector (X_centered %*% lambda_x) 0 p_i numeric vector response probabilities floor numeric scalar > 0, denominator floor","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_denominator.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Build denominator and floor pack ‚Äî el_denominator","text":"list denom, active, inv, inv_sq","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_engine.html","id":null,"dir":"Reference","previous_headings":"","what":"Empirical likelihood (EL) engine for NMAR ‚Äî el_engine","title":"Empirical likelihood (EL) engine for NMAR ‚Äî el_engine","text":"Constructs configuration object empirical likelihood estimator nonignorable nonresponse (NMAR) optional auxiliary moment constraints. data.frame inputs (IID setting) estimator solves stacked system \\(\\theta = (\\beta, z, \\lambda_x)\\) \\(z = \\operatorname{logit}(W)\\) using Newton method analytic Jacobian globalization via nleqslv. survey.design inputs solves design-weighted analogue \\(\\theta = (\\beta, z, \\lambda_W, \\lambda_x)\\). response family supplies second derivatives (logit probit) analytic Jacobian used; otherwise solver falls back numeric/Broyden Jacobians. Numerical safeguards (bounded linear predictor, link-inverse clipping, denominator floors, stable linear algebra) improve robustness. Pass engine nmar together formula data.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_engine.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Empirical likelihood (EL) engine for NMAR ‚Äî el_engine","text":"","code":"el_engine(   standardize = TRUE,   trim_cap = Inf,   on_failure = c(\"return\", \"error\"),   variance_method = c(\"delta\", \"bootstrap\", \"none\"),   bootstrap_reps = 500,   auxiliary_means = NULL,   control = list(),   strata_augmentation = TRUE,   n_total = NULL,   start = NULL,   family = c(\"logit\", \"probit\") )"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_engine.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Empirical likelihood (EL) engine for NMAR ‚Äî el_engine","text":"standardize logical; standardize predictors. Default TRUE. trim_cap numeric; cap EL weights (Inf = trimming). on_failure character; \"return\" \"error\" solver failure. variance_method character; one \"delta\", \"bootstrap\", \"none\". analytical delta method EL currently implemented; \"delta\" supplied coerced \"none\" warning. bootstrap_reps integer; number bootstrap replicates variance_method = \"bootstrap\". auxiliary_means named numeric vector; population means auxiliary design columns. Names must match materialized model.matrix column names first RHS (formula expansion), e.g., factor indicators like `F_b` transformed terms `(X^2)`. Auxiliary intercepts always dropped automatically, supply `(Intercept)`. Optional. control list; optional solver control nleqslv::nleqslv(). Recognized fields (defaults parentheses): Top-level: global = \"qline\" (quadratic line search) one     \"dbldog\", \"pwldog\", \"cline\", \"gline\", \"hook\", \"none\";     xscalm = \"auto\" \"fixed\" control=: xtol, ftol, btol, maxit, trace,     stepmax, delta, allowSing Unknown names ignored. data.frame inputs EL system solved Newton analytic Jacobian; survey.design inputs design-weighted analogue solved analytic Jacobian available numeric/Broyden Jacobians otherwise. strata_augmentation logical; TRUE (default), survey designs identifiable strata structure augmented stratum indicators corresponding population shares auxiliary block (Wu-style strata augmentation). effect data.frame inputs survey designs without strata. n_total numeric; optional supplying respondents-data (NA outcome). data.frame inputs, set total number sampled units filtering respondents. survey.design inputs, set total design weight known population total. omitted outcome contains NAs, estimator errors, requesting n_total. start list; optional starting point solver. Fields: beta: named numeric vector missingness-model coefficients     original (unscaled) scale, including (Intercept). W z: starting value population response rate (0 < W < 1)     logit (z). provided, z takes precedence. lambda: named numeric vector auxiliary multipliers original     scale (names must match auxiliary design columns; intercept). Values     mapped scaled space internally. family character; missingness (response) model family, either \"logit\" \"probit\", family object created logit_family() / probit_family().","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_engine.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Empirical likelihood (EL) engine for NMAR ‚Äî el_engine","text":"list class \"nmar_engine_el\" (also inheriting \"nmar_engine\") containing configuration fields supplied nmar(). Users rarely access fields directly; instead, pass engine nmar() together formula data.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_engine.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Empirical likelihood (EL) engine for NMAR ‚Äî el_engine","text":"engine implements empirical likelihood estimator NMAR response based Qin, Leung Shao (2002) IID data, design-weighted analogue complex survey designs inspired Chen Sitter (1999) Wu (2005). data.frame inputs unknowns (beta, z, lambda_x) z = logit(W), QLS closed-form identity used profile multiplier lambda_W. survey.design inputs system extended (beta, z, lambda_W, lambda_x) solved design weights , present, Wu-style strata augmentation auxiliary block. Numerical guards (capped linear predictors, clipped response probabilities, denominator floors) applied consistently equations Jacobians. Formula syntax: nmar() supports partitioned right-hand side y_miss ~ aux1 + aux2 | z1 + z2. Variables left | auxiliaries (used EL moment constraints); variables right | missingness-model predictors . outcome appears left-hand side included response predictor default. Auxiliary design matrices constructed intercept dropped automatically; missingness models always include intercept even formula uses -1 +0. Variance: Analytical delta variance EL implemented. Requesting variance_method = \"delta\" coerced \"none\" warning. standard errors IID survey settings, use variance_method = \"bootstrap\".","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_engine.html","id":"progress-reporting","dir":"Reference","previous_headings":"","what":"Progress Reporting","title":"Empirical likelihood (EL) engine for NMAR ‚Äî el_engine","text":"variance_method = \"bootstrap\", progress reporting available via progressr package. enable : disable progress simulations batch jobs: handlers(\"void\")  # Silent progressr installed handlers set, bootstrap runs silently (default behavior). Progress reporting works future backends affect reproducibility.","code":"library(progressr) library(future)  # Enable progress reporting handlers(global = TRUE) handlers(\"txtprogressbar\")  # or \"progress\", \"cli\", etc.  # Set parallel backend (optional) plan(multisession, workers = 4)  # Always set seed for reproducibility set.seed(123)  # Run with progress bar result <- nmar(Y ~ X, data = df,                engine = el_engine(variance_method = \"bootstrap\",                                   bootstrap_reps = 500))  # Reset to sequential plan(sequential)"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_engine.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Empirical likelihood (EL) engine for NMAR ‚Äî el_engine","text":"Qin, J., Leung, D., Shao, J. (2002). Estimation survey data nonignorable nonresponse informative sampling. Journal American Statistical Association, 97(457), 193-200. Chen, J., Sitter, R. R. (1999). pseudo empirical likelihood approach complex survey data. Biometrika, 86(2), 373-385. Wu, C. (2005). Algorithms R codes pseudo empirical likelihood method survey sampling. Canadian Journal Statistics, 33(3), 497-509.","code":""},{"path":[]},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_engine.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Empirical likelihood (EL) engine for NMAR ‚Äî el_engine","text":"","code":"# \\donttest{ set.seed(1) n <- 200 X <- rnorm(n) Z <- rnorm(n) Y <- 2 + 0.5 * X + Z p <- plogis(-0.7 + 0.4 * scale(Y)[, 1]) R <- runif(n) < p df <- data.frame(Y_miss = Y, X = X) df$Y_miss[!R] <- NA_real_ eng <- el_engine(auxiliary_means = c(X = 0), variance_method = \"none\") fit <- nmar(Y_miss ~ X, data = df, engine = eng) summary(fit) #> NMAR Model Summary #> ================= #> Y_miss mean: 1.979080 #> Converged: TRUE  #> Variance method: none  #> Variance notes: Variance skipped (variance_method='none')  #> Total units: 200  #> Respondents: 76  #> Call: nmar(Y_miss ~ X, data = <data.frame: N=200>, engine = empirical_likelihood) #>  #> Missingness-model coefficients: #>              Estimate #> (Intercept) -2.535301 #> Y_miss       0.987603  # Response-only predictors can be placed to the right of `|`: df2 <- data.frame(Y_miss = Y, X = X, Z = Z) df2$Y_miss[!R] <- NA_real_ eng2 <- el_engine(auxiliary_means = c(X = 0), variance_method = \"none\") fit2 <- nmar(Y_miss ~ X | Z, data = df2, engine = eng2) print(fit2) #> Call: nmar(Y_miss ~ X | Z, data = <data.frame: N=200>, engine = empirical_likelihood) #>  #> NMAR Result #> ------------ #> Y_miss mean: 2.372442 #> Converged: TRUE  #> Variance method: none  #> Estimator: empirical_likelihood  #> Sample size: 200 (respondents: 76) #>  #> Method: empirical_likelihood #> Max equation residual: 8.380e-09 #> Constraint sum (W): -8.380e-09 #> Constraint sums (aux): #>             X  #> -3.356769e-09   # Survey design usage if (requireNamespace(\"survey\", quietly = TRUE)) {   des <- survey::svydesign(ids = ~1, weights = ~1, data = df)   eng3 <- el_engine(auxiliary_means = c(X = 0), variance_method = \"none\")   fit3 <- nmar(Y_miss ~ X, data = des, engine = eng3)   summary(fit3) } #> NMAR Model Summary #> ================= #> Y_miss mean: 1.979080 #> Converged: TRUE  #> Variance method: none  #> Variance notes: Variance skipped (variance_method='none')  #> Total units: 200  #> Respondents: 76  #> Call: nmar(Y_miss ~ X, data = <survey.design: N=200>, engine = empirical_likelihood) #>  #> Missingness-model coefficients: #>              Estimate #> (Intercept) -2.535301 #> Y_miss       0.987603 # }"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_estimator_core.html","id":null,"dir":"Reference","previous_headings":"","what":"Core Empirical Likelihood Estimator ‚Äî el_estimator_core","title":"Core Empirical Likelihood Estimator ‚Äî el_estimator_core","text":"Implements core computational engine empirical likelihood estimation nonignorable nonresponse, including parameter solving, variance calculation, diagnostic computation.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_estimator_core.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Core Empirical Likelihood Estimator ‚Äî el_estimator_core","text":"","code":"el_estimator_core(   missingness_design,   aux_matrix,   aux_means,   respondent_weights,   analysis_data,   outcome_expr,   N_pop,   formula,   standardize,   trim_cap,   control,   on_failure,   family = logit_family(),   variance_method,   bootstrap_reps,   start = NULL,   trace_level = 0,   auxiliary_means = NULL )"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_estimator_core.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Core Empirical Likelihood Estimator ‚Äî el_estimator_core","text":"missingness_design Respondent-side missingness (response) model design matrix (intercept + predictors). aux_matrix Auxiliary design matrix respondents (may zero columns). aux_means Named numeric vector auxiliary population means (aligned columns `aux_matrix`). respondent_weights Numeric vector respondent weights aligned `missingness_design` rows. analysis_data Data object used logging variance (survey designs supply design object). outcome_expr Character string identifying outcome expression displayed outputs. N_pop Population size analysis scale. formula Original model formula used estimation. standardize Logical. Whether standardize predictors estimation. trim_cap Numeric. Upper bound empirical likelihood weight trimming. control List control parameters nonlinear equation solver. on_failure Character. Action solver fails: \"return\" \"error\". family List. Link function specification (typically logit). variance_method Character. Variance estimation method. bootstrap_reps Integer. Number bootstrap replications. auxiliary_means Named numeric vector known population means supplied user (optional; used diagnostics).","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_estimator_core.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Core Empirical Likelihood Estimator ‚Äî el_estimator_core","text":"List containing estimation results, diagnostics, metadata.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_estimator_core.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Core Empirical Likelihood Estimator ‚Äî el_estimator_core","text":"Orchestrates EL estimation NMAR following Qin, Leung, Shao (2002). data.frame inputs (IID setting) stacked system \\((\\beta, z, \\lambda_x)\\) \\(z = \\logit(W)\\) solved nleqslv using analytic Jacobian. survey.design inputs design-weighted analogue \\((\\beta, z, \\lambda_W, \\lambda_x)\\) solved analytic Jacobian response family supplies second derivatives, numeric/Broyden Jacobians otherwise. Numerical safeguards applied consistently across equations, Jacobian, post-solution weights: bounded linear predictors, probability clipping ratios, small floor denominators \\(D_i(\\theta)\\) active-set mask derivatives. solving, unnormalized masses \\(d_i/D_i(\\theta)\\) formed, optional trimming may applied (normalization reporting), optional variance computed via bootstrap. analytical delta method EL implemented.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_extract_strata_factor.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract a strata factor from a survey.design object ‚Äî el_extract_strata_factor","title":"Extract a strata factor from a survey.design object ‚Äî el_extract_strata_factor","text":"Uses original svydesign() call stored object recreate stratum labels single factor. multiple stratification variables supplied, interaction used.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_extract_strata_factor.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract a strata factor from a survey.design object ‚Äî el_extract_strata_factor","text":"","code":"el_extract_strata_factor(design)"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_lambda_W.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute lambda_W from C_const and W ‚Äî el_lambda_W","title":"Compute lambda_W from C_const and W ‚Äî el_lambda_W","text":"Compute lambda_W C_const W","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_lambda_W.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute lambda_W from C_const and W ‚Äî el_lambda_W","text":"","code":"el_lambda_W(C_const, W)"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_lambda_W.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute lambda_W from C_const and W ‚Äî el_lambda_W","text":"C_const numeric scalar: (N_pop / sum(d_resp) - 1) W numeric scalar (0,1)","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_log_banner.html","id":null,"dir":"Reference","previous_headings":"","what":"Log a step banner line ‚Äî el_log_banner","title":"Log a step banner line ‚Äî el_log_banner","text":"Log step banner line","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_log_banner.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Log a step banner line ‚Äî el_log_banner","text":"","code":"el_log_banner(verboser, title)"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_log_data_prep.html","id":null,"dir":"Reference","previous_headings":"","what":"Log data prep summary ‚Äî el_log_data_prep","title":"Log data prep summary ‚Äî el_log_data_prep","text":"Log data prep summary","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_log_data_prep.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Log data prep summary ‚Äî el_log_data_prep","text":"","code":"el_log_data_prep(   verboser,   outcome_var,   family_name,   K_beta,   K_aux,   auxiliary_names,   standardize,   is_survey,   N_pop,   n_resp_weighted )"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_log_detailed_diagnostics.html","id":null,"dir":"Reference","previous_headings":"","what":"Log detailed diagnostics ‚Äî el_log_detailed_diagnostics","title":"Log detailed diagnostics ‚Äî el_log_detailed_diagnostics","text":"Log detailed diagnostics","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_log_detailed_diagnostics.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Log detailed diagnostics ‚Äî el_log_detailed_diagnostics","text":"","code":"el_log_detailed_diagnostics(   verboser,   beta_hat_unscaled,   W_hat,   lambda_W_hat,   lambda_hat,   denominator_hat )"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_log_final.html","id":null,"dir":"Reference","previous_headings":"","what":"Log final summary ‚Äî el_log_final","title":"Log final summary ‚Äî el_log_final","text":"Log final summary","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_log_final.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Log final summary ‚Äî el_log_final","text":"","code":"el_log_final(verboser, y_hat, se)"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_log_solver_config.html","id":null,"dir":"Reference","previous_headings":"","what":"Log solver configuration ‚Äî el_log_solver_config","title":"Log solver configuration ‚Äî el_log_solver_config","text":"Log solver configuration","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_log_solver_config.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Log solver configuration ‚Äî el_log_solver_config","text":"","code":"el_log_solver_config(verboser, control_top, final_control)"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_log_solver_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Log solver termination status ‚Äî el_log_solver_result","title":"Log solver termination status ‚Äî el_log_solver_result","text":"Log solver termination status","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_log_solver_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Log solver termination status ‚Äî el_log_solver_result","text":"","code":"el_log_solver_result(verboser, converged_success, solution, elapsed)"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_log_solving.html","id":null,"dir":"Reference","previous_headings":"","what":"Log a short solver progress note ‚Äî el_log_solving","title":"Log a short solver progress note ‚Äî el_log_solving","text":"Log short solver progress note","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_log_solving.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Log a short solver progress note ‚Äî el_log_solving","text":"","code":"el_log_solving(verboser)"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_log_start_values.html","id":null,"dir":"Reference","previous_headings":"","what":"Log starting values ‚Äî el_log_start_values","title":"Log starting values ‚Äî el_log_start_values","text":"Log starting values","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_log_start_values.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Log starting values ‚Äî el_log_start_values","text":"","code":"el_log_start_values(verboser, init_beta, init_z, init_lambda)"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_log_trace.html","id":null,"dir":"Reference","previous_headings":"","what":"Log a short trace message with the chosen level ‚Äî el_log_trace","title":"Log a short trace message with the chosen level ‚Äî el_log_trace","text":"Log short trace message chosen level","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_log_trace.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Log a short trace message with the chosen level ‚Äî el_log_trace","text":"","code":"el_log_trace(verboser, trace_level)"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_log_variance_header.html","id":null,"dir":"Reference","previous_headings":"","what":"Log variance header and result ‚Äî el_log_variance_header","title":"Log variance header and result ‚Äî el_log_variance_header","text":"Log variance header result","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_log_variance_header.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Log variance header and result ‚Äî el_log_variance_header","text":"","code":"el_log_variance_header(verboser, variance_method, bootstrap_reps)"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_log_weight_diagnostics.html","id":null,"dir":"Reference","previous_headings":"","what":"Log weight diagnostics ‚Äî el_log_weight_diagnostics","title":"Log weight diagnostics ‚Äî el_log_weight_diagnostics","text":"Log weight diagnostics","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_log_weight_diagnostics.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Log weight diagnostics ‚Äî el_log_weight_diagnostics","text":"","code":"el_log_weight_diagnostics(verboser, W_hat, weights, trimmed_fraction)"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_masses.html","id":null,"dir":"Reference","previous_headings":"","what":"EL masses and probabilities from denominators ‚Äî el_masses","title":"EL masses and probabilities from denominators ‚Äî el_masses","text":"EL masses probabilities denominators","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_masses.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"EL masses and probabilities from denominators ‚Äî el_masses","text":"","code":"el_masses(weights, denom, floor, trim_cap)"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_masses.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"EL masses and probabilities from denominators ‚Äî el_masses","text":"weights numeric respondent base weights (d_i) denom numeric denominators Di floor guard floor numeric small positive guard (unused core logic , kept API symmetry) trim_cap numeric cap (>0) Inf","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_masses.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"EL masses and probabilities from denominators ‚Äî el_masses","text":"list mass_untrim, mass_trimmed, prob_mass, trimmed_fraction","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_mean.html","id":null,"dir":"Reference","previous_headings":"","what":"Mean from probability masses ‚Äî el_mean","title":"Mean from probability masses ‚Äî el_mean","text":"Mean probability masses","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_mean.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Mean from probability masses ‚Äî el_mean","text":"","code":"el_mean(prob_mass, y)"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_prepare_inputs.html","id":null,"dir":"Reference","previous_headings":"","what":"Prepare EL inputs for IID and survey designs ‚Äî el_prepare_inputs","title":"Prepare EL inputs for IID and survey designs ‚Äî el_prepare_inputs","text":"Parses two-part Formula, constructs EL design matrices, injects respondent delta indicator, attaches weights (optionally) survey metadata, returns pieces needed EL core. outcome enters missingness design evaluated LHS expression; explicit use outcome variable RHS2 rejected.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_prepare_inputs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prepare EL inputs for IID and survey designs ‚Äî el_prepare_inputs","text":"","code":"el_prepare_inputs(   formula,   data,   weights = NULL,   n_total = NULL,   design_object = NULL )"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_prepare_inputs.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Prepare EL inputs for IID and survey designs ‚Äî el_prepare_inputs","text":"Invariants enforced (relied downstream EL code): LHS references exactly one outcome source variable `data`;     transforms applied via formula environment must defined     respondent rows. outcome never allowed appear RHS1 (auxiliaries) RHS2     (missingness predictors), either explicitly formula implicitly     via dot (`.`) expansion. missingness model uses evaluated LHS     expression dedicated predictor column instead. RHS1 always yields intercept-free auxiliary design matrix     k-1 coding factor auxiliaries, regardless user `+0`/`-1` syntax     custom contrasts. Auxiliary columns validated fully observed     non-constant among respondents. RHS2 always yields missingness-design matrix respondents     includes intercept column zero-variance predictors emit     warnings (errors); NA among respondents rejected. `respondent_mask` defined raw outcome `data`,     transformed LHS; injected `..nmar_delta..` indicator     `analysis_data` matches mask exactly. `N_pop` analysis-scale population size used EL system:     IID `nrow(data)` unless overridden `n_total`; survey     designs `sum(weights)` `n_total` supplied.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_prepare_nleqslv.html","id":null,"dir":"Reference","previous_headings":"","what":"Prepare nleqslv top-level args and control ‚Äî el_prepare_nleqslv","title":"Prepare nleqslv top-level args and control ‚Äî el_prepare_nleqslv","text":"Prepare nleqslv top-level args control","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_prepare_nleqslv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prepare nleqslv top-level args and control ‚Äî el_prepare_nleqslv","text":"","code":"el_prepare_nleqslv(control)"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_resolve_auxiliaries.html","id":null,"dir":"Reference","previous_headings":"","what":"EL auxiliary design resolution and population means ‚Äî el_resolve_auxiliaries","title":"EL auxiliary design resolution and population means ‚Äî el_resolve_auxiliaries","text":"Computes respondent-side auxiliary matrix population means vector used centering (X - mu_x). `auxiliary_means` supplied, respondent rows required fully observed; NA values permitted nonrespondent rows. `auxiliary_means` NULL, auxiliaries must fully observed full data used estimate population means.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_resolve_auxiliaries.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"EL auxiliary design resolution and population means ‚Äî el_resolve_auxiliaries","text":"","code":"el_resolve_auxiliaries(   aux_design_full,   respondent_mask,   auxiliary_means,   weights_full = NULL )"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_run_solver.html","id":null,"dir":"Reference","previous_headings":"","what":"Solver orchestration with staged policy ‚Äî el_run_solver","title":"Solver orchestration with staged policy ‚Äî el_run_solver","text":"Solver orchestration staged policy","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_run_solver.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Solver orchestration with staged policy ‚Äî el_run_solver","text":"","code":"el_run_solver(   equation_system_func,   analytical_jac_func,   init,   final_control,   top_args,   solver_method,   use_solver_jac,   K_beta,   K_aux,   respondent_weights,   N_pop,   trace_level = 0 )"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_run_solver.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Solver orchestration with staged policy ‚Äî el_run_solver","text":"equation_system_func Function mapping parameter vector equation residuals. analytical_jac_func Analytic Jacobian function; may NULL unavailable forcing Broyden. init Numeric vector initial parameter values. final_control List passed `nleqslv(control = ...)`. top_args List top-level `nleqslv` args (e.g., `global`, `xscalm`). solver_method Character; one \"auto\", \"newton\", \"broyden\". use_solver_jac Logical; whether pass analytic Jacobian Newton. K_beta Integer; number response model parameters. K_aux Integer; number auxiliary constraints. respondent_weights Numeric vector base sampling weights. N_pop Numeric; population total (weighted survey design). trace_level Integer; verbosity level (0 silent, 1-3 increasingly verbose).","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_survey.html","id":null,"dir":"Reference","previous_headings":"","what":"Empirical likelihood for survey designs (NMAR) ‚Äî el_survey","title":"Empirical likelihood for survey designs (NMAR) ‚Äî el_survey","text":"Internal method dispatched `el()` `data` `survey.design`.   Variance via bootstrap supported. Analytical delta variance EL   implemented returns NA requested.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_survey.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Empirical likelihood for survey designs (NMAR) ‚Äî el_survey","text":"","code":"# S3 method for class 'survey.design' el(   data,   formula,   auxiliary_means = NULL,   standardize = TRUE,   strata_augmentation = TRUE,   trim_cap = Inf,   control = list(),   on_failure = c(\"return\", \"error\"),   variance_method = c(\"delta\", \"bootstrap\", \"none\"),   bootstrap_reps = 500,   n_total = NULL,   start = NULL,   trace_level = 0,   family = logit_family(),   ... )"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_survey.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Empirical likelihood for survey designs (NMAR) ‚Äî el_survey","text":"data `survey.design` created [survey::svydesign()]. formula Two-sided formula NA-valued outcome LHS; auxiliaries first RHS , optionally, missingness predictors second RHS partition. auxiliary_means Named numeric vector population means auxiliary design columns. Names must match materialized `model.matrix` columns first RHS (formula expansion), including factor indicators transformed terms. intercept always excluded. standardize Logical; standardize predictors. strata_augmentation Logical; TRUE (default), augment auxiliary design stratum indicators stratum shares strata structure present survey design. trim_cap Numeric; cap EL weights (Inf = trimming). control List; solver control `nleqslv(control=...)`. on_failure Character; \"return\" \"error\" solver failure. variance_method Character; \"delta\", \"bootstrap\", \"none\". bootstrap_reps Integer; reps `variance_method = \"bootstrap\"`. n_total Optional analysis-scale population size N_pop; required respondents-designs. start Optional list starting values passed solver helpers. trace_level Integer 0-3 controlling estimator logging detail. family Missingness (response) model family specification (defaults logit). ... Passed solver.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_survey.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Empirical likelihood for survey designs (NMAR) ‚Äî el_survey","text":"`c('nmar_result_el','nmar_result')`.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_survey.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Empirical likelihood for survey designs (NMAR) ‚Äî el_survey","text":"Implements empirical likelihood estimator design weights.   n_total supplied, treated analysis-scale population   size N_pop used design-weighted QLS system. n_total   supplied, sum(weights(design)) used N_pop. Design   weights rescaled internally; EL equations use respondent weights   N_pop via T0 = N_pop - sum(d_i) linkage equation.   respondents-designs used (NA outcome), n_total   must provided; auxiliaries requested must also provide   population auxiliary means via auxiliary_means. Result weights   unnormalized EL masses d_i/D_i(theta) analysis scale;   weights(result, scale = \"population\") sums N_pop.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_survey.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Empirical likelihood for survey designs (NMAR) ‚Äî el_survey","text":"Qin, J., Leung, D., Shao, J. (2002). Estimation survey data nonignorable nonresponse informative sampling. Journal American Statistical Association, 97(457), 193-200.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_utils_aux.html","id":null,"dir":"Reference","previous_headings":"","what":"EL utility helpers ‚Äî el_utils_aux","title":"EL utility helpers ‚Äî el_utils_aux","text":"Internal helpers auxiliary consistency checks shared validation routines used input parsing.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_validate_design_spec.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate design spec dimensions ‚Äî el_validate_design_spec","title":"Validate design spec dimensions ‚Äî el_validate_design_spec","text":"Validate design spec dimensions","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_validate_design_spec.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate design spec dimensions ‚Äî el_validate_design_spec","text":"","code":"el_validate_design_spec(design, data_nrow)"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_validate_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate matrix columns for NA and zero variance ‚Äî el_validate_matrix","title":"Validate matrix columns for NA and zero variance ‚Äî el_validate_matrix","text":"Validate matrix columns NA zero variance","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/el_validate_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate matrix columns for NA and zero variance ‚Äî el_validate_matrix","text":"","code":"el_validate_matrix(   mat,   allow_na,   label,   severity,   row_map = NULL,   scope_note = NULL,   plural_label = FALSE )"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/enforce_nonneg_weights.html","id":null,"dir":"Reference","previous_headings":"","what":"Enforce (near-)nonnegativity of weights ‚Äî enforce_nonneg_weights","title":"Enforce (near-)nonnegativity of weights ‚Äî enforce_nonneg_weights","text":"Softly enforces nonnegativity numeric weight vector. Large negative values (beyond tolerance) treated errors; small negative values (example, numerical noise) truncated zero.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/enforce_nonneg_weights.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Enforce (near-)nonnegativity of weights ‚Äî enforce_nonneg_weights","text":"","code":"enforce_nonneg_weights(weights, tol = 1e-08)"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/enforce_nonneg_weights.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Enforce (near-)nonnegativity of weights ‚Äî enforce_nonneg_weights","text":"weights numeric vector weights. tol numeric tolerance negative values treated numerical noise clipped zero.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/enforce_nonneg_weights.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Enforce (near-)nonnegativity of weights ‚Äî enforce_nonneg_weights","text":"list components: ok logical; TRUE clearly negative weights       found. message character; diagnostic message ok       FALSE, otherwise NULL. weights numeric vector adjusted weights (original       ok FALSE, otherwise small negatives clipped       zero).","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/engine_config.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract engine configuration ‚Äî engine_config","title":"Extract engine configuration ‚Äî engine_config","text":"Returns underlying configuration engine named list. intended programmatic inspection (e.g., parameter tuning, logging). returned object treated read-.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/engine_config.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract engine configuration ‚Äî engine_config","text":"","code":"engine_config(x)"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/engine_config.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract engine configuration ‚Äî engine_config","text":"x object inheriting class `nmar_engine`.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/engine_config.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract engine configuration ‚Äî engine_config","text":"named list configuration fields.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/engine_name.html","id":null,"dir":"Reference","previous_headings":"","what":"Canonical engine name ‚Äî engine_name","title":"Canonical engine name ‚Äî engine_name","text":"Returns stable, machine-friendly identifier engine object. identifier also used `nmar_result$meta$engine_name` keep consistent naming scheme configurations results.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/engine_name.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Canonical engine name ‚Äî engine_name","text":"","code":"engine_name(x)"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/engine_name.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Canonical engine name ‚Äî engine_name","text":"x object inheriting class `nmar_engine`.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/engine_name.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Canonical engine name ‚Äî engine_name","text":"single character string, e.g. \"empirical_likelihood\".","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/exptilt.html","id":null,"dir":"Reference","previous_headings":"","what":"Exponential tilting estimator ‚Äî exptilt","title":"Exponential tilting estimator ‚Äî exptilt","text":"Generic exponential tilting (ET) estimator NMAR.   Methods provided `data.frame` `survey.design`.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/exptilt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Exponential tilting estimator ‚Äî exptilt","text":"","code":"exptilt(data, ...)"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/exptilt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Exponential tilting estimator ‚Äî exptilt","text":"data `data.frame` `survey.design`. ... Passed class-specific methods.","code":""},{"path":[]},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/exptilt_engine.html","id":null,"dir":"Reference","previous_headings":"","what":"Exponential tilting (ET) engine for NMAR estimation ‚Äî exptilt_engine","title":"Exponential tilting (ET) engine for NMAR estimation ‚Äî exptilt_engine","text":"Constructs configuration exponential tilting estimator nonignorable nonresponse (NMAR). estimator solves \\(S_2(\\boldsymbol{\\phi}, \\hat{\\boldsymbol{\\gamma}}) = 0,\\) using nleqslv apply EM algorithm.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/exptilt_engine.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Exponential tilting (ET) engine for NMAR estimation ‚Äî exptilt_engine","text":"","code":"exptilt_engine(   standardize = FALSE,   on_failure = c(\"return\", \"error\"),   variance_method = c(\"delta\", \"bootstrap\", \"none\"),   bootstrap_reps = 10,   supress_warnings = FALSE,   auxiliary_means = NULL,   control = list(),   family = c(\"logit\", \"probit\"),   y_dens = c(\"normal\", \"lognormal\", \"exponential\"),   stopping_threshold = 1,   sample_size = 2000 )"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/exptilt_engine.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Exponential tilting (ET) engine for NMAR estimation ‚Äî exptilt_engine","text":"standardize logical; standardize predictors. Default TRUE. on_failure character; \"return\" \"error\" solver failure variance_method character; one \"delta\", \"bootstrap\", \"none\". bootstrap_reps integer; number bootstrap replicates variance_method = \"bootstrap\". supress_warnings Logical; suppress variance-related warnings. auxiliary_means Optional named numeric vector population moments auxiliary covariates. control Named list control parameters passed nleqslv::nleqslv. Common parameters include: maxit: Maximum number iterations (default: 100) method: Solver method - \"Newton\" \"Broyden\" (default: \"Newton\") global: Global strategy - \"dbldog\", \"pwldog\", \"qline\", \"gline\", \"hook\", \"none\" (default: \"dbldog\") xtol: Tolerance relative error solution (default: 1e-8) ftol: Tolerance function value (default: 1e-8) btol: Tolerance backtracking (default: 0.01) allowSingular: Allow singular Jacobians (default: TRUE) See ?nleqslv::nleqslv full details. family character; response model family, either \"logit\" \"probit\", family object created logit_family() / probit_family(). y_dens Outcome density model (\"auto\", \"normal\", \"lognormal\", \"exponential\"). stopping_threshold Numeric; early stopping threshold. maximum absolute value score function falls threshold, algorithm stops early (default: 1). sample_size Integer; maximum sample size stratified random sampling (default: 2000). dataset exceeds size, stratified random sample drawn optimize memory usage. sampling preserves ratio respondents non-respondents original data.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/exptilt_engine.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Exponential tilting (ET) engine for NMAR estimation ‚Äî exptilt_engine","text":"engine object class c(\"nmar_engine_exptilt\",\"nmar_engine\").   configuration list; fit. Pass nmar.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/exptilt_engine.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Exponential tilting (ET) engine for NMAR estimation ‚Äî exptilt_engine","text":"method robust Propensity-Score Adjustment (PSA) approach Missing Random (NMAR). uses Maximum Likelihood Estimation (MLE), basing likelihood observed part sample (\\(f(\\boldsymbol{Y}_i | \\delta_i = 1, \\boldsymbol{X}_i)\\)), making robust outcome model misspecification. propensity score estimated assuming instrumental variable (\\(X_2\\)) independent response status given covariates study variable. Estimator calculates fractional imputation weights \\(w_i\\). final estimator weighted average, weights inverse estimated response probabilities \\(\\hat{\\pi}_i\\), satisfying estimating equation: $$ \\sum_{\\\\mathcal{R}} \\frac{\\boldsymbol{g}(\\boldsymbol{Y}_i, \\boldsymbol{X}_i ; \\boldsymbol{\\theta})}{\\hat{\\pi}_i} = 0, $$ \\(\\mathcal{R}\\) set observed respondents.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/exptilt_engine.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Exponential tilting (ET) engine for NMAR estimation ‚Äî exptilt_engine","text":"Minsun Kim Riddles, Jae Kwang Kim, Jongho Im Propensity-score-adjustment Method Nonignorable Nonresponse Journal Survey Statistics Methodology, Volume 4, Issue 2, June 2016, Pages 215‚Äì245.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/exptilt_engine.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Exponential tilting (ET) engine for NMAR estimation ‚Äî exptilt_engine","text":"","code":"# \\donttest{ generate_test_data <- function(   n_rows = 500,   n_cols = 1,   case = 1,   x_var = 0.5,   eps_var = 0.9,   a = 0.8,   b = -0.2 ) { # Generate X variables - fixed to match comparison   X <- as.data.frame(replicate(n_cols, rnorm(n_rows, 0, sqrt(x_var))))   colnames(X) <- paste0(\"x\", 1:n_cols)  # Generate Y - fixed coefficients to match comparison   eps <- rnorm(n_rows, 0, sqrt(eps_var))   if (case == 1) { # Use fixed coefficient of 1 for all x variables to match: y = -1 + x1 + epsilon     X$Y <- as.vector(-1 + as.matrix(X) %*% rep(1, n_cols) + eps)   }   else if (case == 2) {     X$Y <- -2 + 0.5 * exp(as.matrix(X) %*% rep(1, n_cols)) + eps   }   else if (case == 3) {     X$Y <- -1 + sin(2 * as.matrix(X) %*% rep(1, n_cols)) + eps   }   else if (case == 4) {     X$Y <- -1 + 0.4 * as.matrix(X)^3 %*% rep(1, n_cols) + eps   }    Y_original <- X$Y  # Missingness mechanism - identical to comparison   pi_obs <- 1 / (1 + exp(-(a + b * X$Y)))  # Create missing values   mask <- runif(nrow(X)) > pi_obs   mask[1] <- FALSE # Ensure at least one observation is not missing   X$Y[mask] <- NA    return(list(X = X, Y_original = Y_original)) } res_test_data <- generate_test_data(n_rows = 500, n_cols = 1, case = 1) x <- res_test_data$X  exptilt_config <- exptilt_engine(   y_dens = 'normal',   control = list(maxit = 10),   stopping_threshold = 0.1,   standardize = FALSE,   family = 'logit',   bootstrap_reps = 5 ) formula = Y ~ x1 res <- nmar(formula = formula, data = x, engine = exptilt_config, trace_level = 1) #> [STEP-1] ============================================================  #> [STEP-1]   EXPTILT ESTIMATION STARTED  #> [STEP-1] ============================================================  #> [INFO] Running with trace_level = 1 | For more detailed output, use trace_level = 2. Available trace_level = c(1,2,3)  #> [INFO] Formula: Y ~ x1  #> [INFO]   #> [INFO] -- DATA SUMMARY --  #> [INFO]   Total observations:      500  #> [INFO]   Respondents:             348 (30.4%)  #> [INFO]   Non-respondents:         152 (69.6%)  #> [INFO]   #> [INFO] -- CONDITIONAL DENSITY ESTIMATION --  #> [INFO]   Selected distribution:   normal  #> [INFO]   #> [INFO] -- NONLINEAR SOLVER (nleqslv) --  #> [INFO]   Solving...  #> [INFO]   #> [INFO]   OK Converged  #> [INFO]   Iterations:               6  #> [INFO]   #> [INFO] -- VARIANCE ESTIMATION (Delta Method) --  #> Warning: Delta variance failed to evaluate; using bootstrap instead. #> [INFO]   #> [INFO] -- VARIANCE ESTIMATION (Bootstrap) --  #> [INFO]   Bootstrap replications:   5  #> [INFO]   OK Bootstrap complete  #> [INFO]   Standard error:           0.091309  #> [INFO]   #> [RESULT] ============================================================  #> [RESULT]   ESTIMATION COMPLETE  #> [RESULT] ============================================================  #> [RESULT]   Mean estimate:            -0.942440  #> [RESULT]   Standard error:           0.091309  #> [RESULT]   95% CI:                   [-1.121405, -0.763474]  #> [RESULT] ============================================================  summary(res) #> NMAR Model Summary #> ================= #> Y mean: -0.942440 (0.091309) #> 95% CI: (-1.121402, -0.763478) #> Converged: TRUE  #> Variance method: delta  # }"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/exptilt_nonparam.html","id":null,"dir":"Reference","previous_headings":"","what":"Nonparametric Exponential Tilting (Internal Generic) ‚Äî exptilt_nonparam","title":"Nonparametric Exponential Tilting (Internal Generic) ‚Äî exptilt_nonparam","text":"Nonparametric Exponential Tilting (Internal Generic)","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/exptilt_nonparam.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Nonparametric Exponential Tilting (Internal Generic) ‚Äî exptilt_nonparam","text":"","code":"exptilt_nonparam(data, ...)"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/exptilt_nonparam.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Nonparametric Exponential Tilting (Internal Generic) ‚Äî exptilt_nonparam","text":"data data.frame survey.design object ... arguments passed methods","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/exptilt_nonparam_engine.html","id":null,"dir":"Reference","previous_headings":"","what":"Nonparametric exponential tilting (EM) engine for NMAR ‚Äî exptilt_nonparam_engine","title":"Nonparametric exponential tilting (EM) engine for NMAR ‚Äî exptilt_nonparam_engine","text":"Constructs configuration nonparametric exponential tilting estimator nonignorable nonresponse (NMAR). engine implements \"Fully Nonparametric Approach\" **Appendix 2** Riddles et al. (2016). estimator uses Expectation-Maximization (EM) algorithm directly estimate nonresponse odds \\(O(x_1, y)\\) aggregated, categorical data.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/exptilt_nonparam_engine.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Nonparametric exponential tilting (EM) engine for NMAR ‚Äî exptilt_nonparam_engine","text":"","code":"exptilt_nonparam_engine(refusal_col = \"\", max_iter = 100, tol_value = 1e-06)"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/exptilt_nonparam_engine.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Nonparametric exponential tilting (EM) engine for NMAR ‚Äî exptilt_nonparam_engine","text":"refusal_col character; column name data contains aggregated counts non-respondents (refusals). max_iter integer; maximum number iterations EM algorithm. tol_value numeric; convergence tolerance EM algorithm. loop stops sum absolute changes odds matrix less value.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/exptilt_nonparam_engine.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Nonparametric exponential tilting (EM) engine for NMAR ‚Äî exptilt_nonparam_engine","text":"engine object class c(\"nmar_engine_exptilt_nonparam\",\"nmar_engine\").   configuration list; fit. Pass nmar.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/exptilt_nonparam_engine.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Nonparametric exponential tilting (EM) engine for NMAR ‚Äî exptilt_nonparam_engine","text":"engine designed cases variables (outcomes $Y$, response predictors $X_1$, instrumental variables $X_2$) categorical, input data pre-aggregated strata. method assumes instrumental variable \\(X_2\\) available. response probability assumed depend \\(X_1\\) $Y$, ** \\(X_2\\). EM algorithm iteratively solves nonresponse odds: $$ O^{(t+1)}(x_1^*, y^*) = \\frac{M_{y^*x_1^*}^{(t)}}{N_{y^*x_1^*}} $$ \\(M_{y^*x_1^*}^{(t)}\\) expected count non-respondents (calculated E-step) \\(N_{y^*x_1^*}\\) observed count respondents given stratum $(x_1, y)$. final output nmar call object containing data_to_return, aggregated data frame original 'refusal' counts redistributed outcome columns (e.g., 'Voted_A', 'Voted_B') expected non-respondent counts.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/exptilt_nonparam_engine.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Nonparametric exponential tilting (EM) engine for NMAR ‚Äî exptilt_nonparam_engine","text":"Minsun Kim Riddles, Jae Kwang Kim, Jongho Im Propensity-score-adjustment Method Nonignorable Nonresponse Journal Survey Statistics Methodology, Volume 4, Issue 2, June 2016, Pages 215‚Äì245. (See **Appendix 2** specific method).","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/exptilt_nonparam_engine.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Nonparametric exponential tilting (EM) engine for NMAR ‚Äî exptilt_nonparam_engine","text":"","code":"# Test data (Riddles 2016, Table 9) voting_data_example <- data.frame(   Gender = rep(c(\"Male\", \"Male\", \"Male\", \"Male\", \"Female\", \"Female\", \"Female\", \"Female\"), 1),   Age_group = c(\"20-29\", \"30-39\", \"40-49\", \">=50\", \"20-29\", \"30-39\", \"40-49\", \"50+\"),   Voted_A = c(93, 104, 146, 560, 106, 129, 170, 501),   Voted_B = c(115, 233, 295, 350, 159, 242, 262, 218),   Other = c(4, 8, 5, 3, 8, 5, 5, 7),   Refusal = c(28, 82, 49, 174, 62, 70, 69, 211),   Total = c(240, 427, 495, 1087, 335, 446, 506, 937) )  np_em_config <- exptilt_nonparam_engine(   refusal_col = \"Refusal\",   max_iter = 100,   tol_value = 0.001 )  # Formula: Y1 + Y2 + ... ~ X1_vars | X2_vars # Here, Y = Voted_A, Voted_B, Other #      x1 = Gender (response model) #      x2 = Age_group (instrumental variable) em_formula <- Voted_A + Voted_B + Other ~ Gender | Age_group  # \\donttest{ results_em_np <- nmar(   formula = em_formula,   data = voting_data_example,   engine = np_em_config,   trace_level = 0 )  # View the final adjusted counts # (Original counts + expected non-respondent counts) print(results_em_np$data_final) #>   Gender Age_group  Voted_A  Voted_B    Other Total #> 1   Male     20-29 108.4560 118.8595 12.68447   240 #> 2   Male     30-39 137.3696 248.0971 41.53330   427 #> 3   Male     40-49 172.4092 305.7756 16.81518   495 #> 4   Male      >=50 705.4611 368.3589 13.18002  1087 #> 5 Female     20-29 149.2433 166.3526 19.40414   335 #> 6 Female     30-39 180.9255 253.0418 12.03269   446 #> 7 Female     40-49 224.0130 271.4359 10.55110   506 #> 8 Female       50+ 693.1421 227.4771 16.38086   937 # }"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/extract_nleqslv_top.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract top-level nleqslv arguments from a control-like list ‚Äî extract_nleqslv_top","title":"Extract top-level nleqslv arguments from a control-like list ‚Äî extract_nleqslv_top","text":"Extract top-level nleqslv arguments control-like list","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/extract_nleqslv_top.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract top-level nleqslv arguments from a control-like list ‚Äî extract_nleqslv_top","text":"","code":"extract_nleqslv_top(ctrl)"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/fitted.nmar_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Default fitted values for NMAR results ‚Äî fitted.nmar_result","title":"Default fitted values for NMAR results ‚Äî fitted.nmar_result","text":"Returns fitted response probabilities available.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/fitted.nmar_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Default fitted values for NMAR results ‚Äî fitted.nmar_result","text":"","code":"# S3 method for class 'nmar_result' fitted(object, ...)"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/fitted.nmar_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Default fitted values for NMAR results ‚Äî fitted.nmar_result","text":"object `nmar_result` object. ... Ignored.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/fitted.nmar_result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Default fitted values for NMAR results ‚Äî fitted.nmar_result","text":"numeric vector (possibly length 0).","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/format.nmar_engine.html","id":null,"dir":"Reference","previous_headings":"","what":"One-line formatter for NMAR engines ‚Äî format.nmar_engine","title":"One-line formatter for NMAR engines ‚Äî format.nmar_engine","text":"Returns single concise line summarizing engine configuration.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/format.nmar_engine.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"One-line formatter for NMAR engines ‚Äî format.nmar_engine","text":"","code":"# S3 method for class 'nmar_engine' format(x, ...)"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/format.nmar_engine.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"One-line formatter for NMAR engines ‚Äî format.nmar_engine","text":"x engine object inheriting `nmar_engine`. ... Unused.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/format.nmar_engine.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"One-line formatter for NMAR engines ‚Äî format.nmar_engine","text":"length-1 character vector.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/formula.nmar_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Default formula for NMAR results ‚Äî formula.nmar_result","title":"Default formula for NMAR results ‚Äî formula.nmar_result","text":"Returns estimation formula available.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/formula.nmar_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Default formula for NMAR results ‚Äî formula.nmar_result","text":"","code":"# S3 method for class 'nmar_result' formula(x, ...)"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/formula.nmar_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Default formula for NMAR results ‚Äî formula.nmar_result","text":"x `nmar_result` object. ... Ignored.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/formula.nmar_result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Default formula for NMAR results ‚Äî formula.nmar_result","text":"formula `NULL`.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/glance.nmar_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Glance summary for NMAR results ‚Äî glance.nmar_result","title":"Glance summary for NMAR results ‚Äî glance.nmar_result","text":"One-row diagnostics NMAR fits.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/glance.nmar_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Glance summary for NMAR results ‚Äî glance.nmar_result","text":"","code":"# S3 method for class 'nmar_result' glance(x, ...)"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/glance.nmar_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Glance summary for NMAR results ‚Äî glance.nmar_result","text":"x object class `nmar_result`. ... Ignored.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/logit_family.html","id":null,"dir":"Reference","previous_headings":"","what":"Logit family functions (link and derivatives) ‚Äî logit_family","title":"Logit family functions (link and derivatives) ‚Äî logit_family","text":"Logit family functions (link derivatives)","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/logit_family.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Logit family functions (link and derivatives) ‚Äî logit_family","text":"","code":"logit_family()"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/merge_nleqslv_top.html","id":null,"dir":"Reference","previous_headings":"","what":"Prefer explicit solver_args over control-provided top-level args ‚Äî merge_nleqslv_top","title":"Prefer explicit solver_args over control-provided top-level args ‚Äî merge_nleqslv_top","text":"Prefer explicit solver_args control-provided top-level args","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/merge_nleqslv_top.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prefer explicit solver_args over control-provided top-level args ‚Äî merge_nleqslv_top","text":"","code":"merge_nleqslv_top(solver_args, control_top)"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/new_nmar_engine_el.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct EL Engine Object ‚Äî new_nmar_engine_el","title":"Construct EL Engine Object ‚Äî new_nmar_engine_el","text":"Construct EL Engine Object","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/new_nmar_engine_el.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct EL Engine Object ‚Äî new_nmar_engine_el","text":"","code":"new_nmar_engine_el(engine)"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/new_nmar_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct Result Object (parent helper) ‚Äî new_nmar_result","title":"Construct Result Object (parent helper) ‚Äî new_nmar_result","text":"Builds `nmar_result` list using shared schema validates . Engines must pass named fields; legacy positional signature supported.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/new_nmar_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct Result Object (parent helper) ‚Äî new_nmar_result","text":"","code":"new_nmar_result(...)"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/new_nmar_result.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Construct Result Object (parent helper) ‚Äî new_nmar_result","text":"Engine-level constructors call helper named arguments rather assembling result lists hand. minimum, engines supply estimate (numeric scalar) converged (logical). fields optional: estimate_name: label primary estimand (defaults     NA_character_ omitted). se: standard error primary estimand (defaults     NA_real_ available). model, weights_info, sample, inference,     diagnostics, meta, extra: lists may partially     specified NULL; validate_nmar_result() back-fill     missing subfields safe defaults. class: engine-specific result subclass name, e.g.     \"nmar_result_el\"; combined parent class     \"nmar_result\". Calling new_nmar_result() ensures every engine returns objects satisfy shared schema immediately compatible parent S3 methods vcov(), confint(), tidy(), glance(), weights().","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/new_nmar_result_el.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct EL Result Object ‚Äî new_nmar_result_el","title":"Construct EL Result Object ‚Äî new_nmar_result_el","text":"Construct EL Result Object","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/new_nmar_result_el.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct EL Result Object ‚Äî new_nmar_result_el","text":"","code":"new_nmar_result_el(   y_hat,   se,   weights,   coefficients,   vcov,   converged,   diagnostics,   inputs,   nmar_scaling_recipe,   fitted_values,   call,   formula = NULL )"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/nmar.html","id":null,"dir":"Reference","previous_headings":"","what":"Not Missing at Random (NMAR) Estimation ‚Äî nmar","title":"Not Missing at Random (NMAR) Estimation ‚Äî nmar","text":"Provides unified interface Missing Random (NMAR) estimation.   function orchestrates estimation process validating inputs   dispatching appropriate engine based provided `engine` object.   ensures necessary data model specifications correctly   formatted computation begins.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/nmar.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Not Missing at Random (NMAR) Estimation ‚Äî nmar","text":"","code":"nmar(formula, data, engine, trace_level = 0)"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/nmar.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Not Missing at Random (NMAR) Estimation ‚Äî nmar","text":"formula two-sided formula form `y_miss ~ aux1 + aux2 | z1 + z2`. left-hand side outcome (`NA` values indicating nonresponse). right-hand side split `|` two parts: - left `|`: auxiliary variables (enter moment constraints); - right `|`: missingness (response) model predictors (enter missingness model ). `|` omitted, auxiliary variables used parsing printing. outcome variable implicitly included response model. data data frame `survey.design` containing variables referenced formula. engine engine configuration object, typically created engine constructor function like `exptilt()`. object defines specific NMAR estimation method parameters. must inherit class `nmar_engine`. trace_level Integer 0-3; controls verbosity level estimation (default: 1): 0: output (silent mode) 1: Major steps (initialization, convergence, final results) 2: Moderate detail (iteration summaries, key diagnostics) 3: Full detail (diagnostics, intermediate values)","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/nmar.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Not Missing at Random (NMAR) Estimation ‚Äî nmar","text":"object containing estimation results, whose structure   specific `engine` used. might include estimated parameters,   convergence information, relevant output chosen NMAR method.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/nmar_engine_helpers.html","id":null,"dir":"Reference","previous_headings":"","what":"S3 helpers for NMAR engine objects ‚Äî nmar_engine_helpers","title":"S3 helpers for NMAR engine objects ‚Äî nmar_engine_helpers","text":"Lightweight, user-facing methods engine configuration objects (class `nmar_engine`). improve discoverability provide consistent print surface across engines keeping objects simple lists internally.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/nmar_engine_helpers.html","id":"design","dir":"Reference","previous_headings":"","what":"Design","title":"S3 helpers for NMAR engine objects ‚Äî nmar_engine_helpers","text":"- `engine_name()` returns canonical identifier used across   package (e.g., `nmar_result$meta$engine_name`). - `print.nmar_engine()` provides concise, readable summary   engine configuration; engine-specific classes reuse parent   method unless need override . - `engine_config()` returns underlying configuration named   list programmatic inspection.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/nmar_fmt_num.html","id":null,"dir":"Reference","previous_headings":"","what":"Format a number with fixed decimal places using nmar.digits ‚Äî nmar_fmt_num","title":"Format a number with fixed decimal places using nmar.digits ‚Äî nmar_fmt_num","text":"Format number fixed decimal places using nmar.digits","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/nmar_fmt_num.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Format a number with fixed decimal places using nmar.digits ‚Äî nmar_fmt_num","text":"","code":"nmar_fmt_num(x, digits = nmar_get_digits())"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/nmar_format_call_line.html","id":null,"dir":"Reference","previous_headings":"","what":"Format an abridged call line for printing ‚Äî nmar_format_call_line","title":"Format an abridged call line for printing ‚Äî nmar_format_call_line","text":"Builds concise one-line summary original call without materializing large objects (e.g., full data frames). Intended use print/summary methods.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/nmar_format_call_line.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Format an abridged call line for printing ‚Äî nmar_format_call_line","text":"","code":"nmar_format_call_line(x)"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/nmar_format_call_line.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Format an abridged call line for printing ‚Äî nmar_format_call_line","text":"Uses option `nmar.show_call` (default TRUE). Width can tuned via option `nmar.call_width` (default 120), formatter aims keep line compact regardless width.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/nmar_get_digits.html","id":null,"dir":"Reference","previous_headings":"","what":"Resolve global digits setting for printing ‚Äî nmar_get_digits","title":"Resolve global digits setting for printing ‚Äî nmar_get_digits","text":"Resolve global digits setting printing","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/nmar_get_digits.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Resolve global digits setting for printing ‚Äî nmar_get_digits","text":"","code":"nmar_get_digits()"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/nmar_get_el_denom_floor.html","id":null,"dir":"Reference","previous_headings":"","what":"EL denominator floor (global, consistent) ‚Äî nmar_get_el_denom_floor","title":"EL denominator floor (global, consistent) ‚Äî nmar_get_el_denom_floor","text":"Returns small positive floor \\(\\delta\\) used guard empirical likelihood denominator \\(D_i(\\theta)\\) away zero. guard must applied consistently estimating equations, analytic Jacobian, post-solution weight construction. Advanced users can override via `options(nmar.el_denom_floor = 1e-8)`.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/nmar_get_el_denom_floor.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"EL denominator floor (global, consistent) ‚Äî nmar_get_el_denom_floor","text":"","code":"nmar_get_el_denom_floor()"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/nmar_get_numeric_settings.html","id":null,"dir":"Reference","previous_headings":"","what":"NMAR numeric settings ‚Äî nmar_get_numeric_settings","title":"NMAR numeric settings ‚Äî nmar_get_numeric_settings","text":"NMAR numeric settings","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/nmar_get_numeric_settings.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"NMAR numeric settings ‚Äî nmar_get_numeric_settings","text":"","code":"nmar_get_numeric_settings()"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/nmar_get_numeric_settings.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"NMAR numeric settings ‚Äî nmar_get_numeric_settings","text":"named list entries `eta_cap`, `grad_eps`, `grad_d`.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/nmar_get_numeric_settings.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"NMAR numeric settings ‚Äî nmar_get_numeric_settings","text":"Centralized access numeric thresholds used across package. settings can overridden via options() advanced users: - `nmar.eta_cap`: scalar > 0. Caps response-model linear predictor   avoid extreme link values Newton updates. Default 50. - `nmar.grad_eps`: finite-difference step size epsilon numeric   gradients smooth functionals. Default 1e-6. - `nmar.grad_d`: relative step adjustment numeric gradients.   Default 1e-3. defaults chosen conservative stable across typical NMAR problems. Engines retrieve values via helper rather hard-coding numbers, documentation stays consistent.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/nmar_result_get_estimate.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal helpers for nmar_result objects ‚Äî nmar_result_get_estimate","title":"Internal helpers for nmar_result objects ‚Äî nmar_result_get_estimate","text":"Internal helpers nmar_result objects","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/nmar_result_get_estimate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal helpers for nmar_result objects ‚Äî nmar_result_get_estimate","text":"","code":"nmar_result_get_estimate(x)"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/nmar_result_s3_parent.html","id":null,"dir":"Reference","previous_headings":"","what":"Parent S3 surface for NMAR results ‚Äî nmar_result_s3_parent","title":"Parent S3 surface for NMAR results ‚Äî nmar_result_s3_parent","text":"Methods apply parent `nmar_result` class   specific particular engine (e.g., EL). Engines return child class   (e.g., `nmar_result_el`) inherits `nmar_result` may override   extend behavior.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/nmar_result_s3_parent.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Parent S3 surface for NMAR results ‚Äî nmar_result_s3_parent","text":"S3 surface base `nmar_result` Result objects expose universal schema:   - `y_hat`, `estimate_name`, `se`, `converged`.   - `model`: list `coefficients`, `vcov`, plus optional extras.   - `weights_info`: list respondent weights trimming metadata.   - `sample`: list total units, respondent count, survey flag, `design`.   - `inference`: variance metadata (`variance_method`, `df`, diagnostic flags).   - `diagnostics`, `meta`, `extra` estimator-specific details. New engines populate components constructors rely   `nmar_result_get_*` utilities implementing child-specific S3   methods.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/nmar_scaling_infra.html","id":null,"dir":"Reference","previous_headings":"","what":"Shared scaling infrastructure for NMAR engines ‚Äî nmar_scaling_infra","title":"Shared scaling infrastructure for NMAR engines ‚Äî nmar_scaling_infra","text":"Centralized feature scaling parameter unscaling routines used NMAR estimation engines ensure consistent, numerically stable behavior.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/nmar_scaling_infra.html","id":"goals","dir":"Reference","previous_headings":"","what":"Goals","title":"Shared scaling infrastructure for NMAR engines ‚Äî nmar_scaling_infra","text":"Provide engine-agnostic API standardizing design matrices     auxiliary moments solving. Return minimal \"recipe\" (per-column mean standard deviation)     unscaling coefficients covariance matrices solving.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/nmar_scaling_infra.html","id":"inputs-outputs","dir":"Reference","previous_headings":"","what":"Inputs/Outputs","title":"Shared scaling infrastructure for NMAR engines ‚Äî nmar_scaling_infra","text":"Inputs Z_un (response model matrix intercept),     optional X_un (auxiliary model matrix, intercept),     optional named mu_x_un (auxiliary means original scale),     logical standardize flag. Outputs Scaled matrices Z, X, mu_x, plus     nmar_scaling_recipe used later unscaling.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/nmar_scaling_infra.html","id":"integration-pattern","dir":"Reference","previous_headings":"","what":"Integration pattern","title":"Shared scaling infrastructure for NMAR engines ‚Äî nmar_scaling_infra","text":"solving: call validate_and_apply_nmar_scaling() (engine-level)         prepare_nmar_scaling() (low-level) obtain scaled matrices         recipe. Solve scaled space. solving: call unscale_coefficients() unscale coefficients         covariance matrices. Store nmar_scaling_recipe results diagnostics reproducibility.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/nmar_scaling_infra.html","id":"notes","dir":"Reference","previous_headings":"","what":"Notes","title":"Shared scaling infrastructure for NMAR engines ‚Äî nmar_scaling_infra","text":"intercept column never scaled. Columns near-zero variance centered assigned     sd = 1 corresponding parameter inflated     division small standard deviation. Engines may use design-weighted scaling via weights         weight_mask arguments.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/polish_households.html","id":null,"dir":"Reference","previous_headings":"","what":"Polish Household Budget Data with Simulated Nonignorable Nonresponse ‚Äî polish_households","title":"Polish Household Budget Data with Simulated Nonignorable Nonresponse ‚Äî polish_households","text":"dataset derived `h05` dataset (Polish household budgets 2005) found `RClas` package. original data cleaned remove rows missing values.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/polish_households.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Polish Household Budget Data with Simulated Nonignorable Nonresponse ‚Äî polish_households","text":"","code":"polish_households"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/polish_households.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Polish Household Budget Data with Simulated Nonignorable Nonresponse ‚Äî polish_households","text":"data frame 19,330 rows 17 columns. key variables : class TODO voi TODO bio TODO type TODO d345 TODO d347 TODO d348 TODO d36 TODO d38 TODO d61 TODO noper TODO income TODO expenditure TODO y_exp Numeric. **true** scaled expenditure                (`expenditure / mean(expenditure)`). complete                study variable without missingness. resp TODO R Integer. simulated response indicator (1=responded, 0=nonresponse). y_exp_miss Numeric. **observed** scaled expenditure, containing                    7,778 `NA` values `R = 0`. variable                    used NMAR-affected outcome.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/polish_households.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Polish Household Budget Data with Simulated Nonignorable Nonresponse ‚Äî polish_households","text":"TODO","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/polish_households.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Polish Household Budget Data with Simulated Nonignorable Nonresponse ‚Äî polish_households","text":"create realistic test case nonignorable nonresponse (NMAR), nonresponse mechanism simulated applied scaled expenditure variable (`y_exp`). key simulation steps : 1.  `y_exp` (true study variable) created scaling total expenditure. 2.  true response probability (`resp`) created using logistic     model: `plogis(1 - 0.6 * y_exp)`. 3.  response indicator (`R`) simulated based probability. 4.  final variable `y_exp_miss` generated setting `y_exp` `NA`     wherever `R` 0. response **nonignorable** probability missingness depends directly value expenditure variable .","code":""},{"path":[]},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/prepare_nmar_scaling.html","id":null,"dir":"Reference","previous_headings":"","what":"Prepare scaled matrices and moments (low-level) ‚Äî prepare_nmar_scaling","title":"Prepare scaled matrices and moments (low-level) ‚Äî prepare_nmar_scaling","text":"Prepare scaled matrices moments (low-level)","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/prepare_nmar_scaling.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prepare scaled matrices and moments (low-level) ‚Äî prepare_nmar_scaling","text":"","code":"prepare_nmar_scaling(   Z_un,   X_un,   mu_x_un,   standardize,   weights = NULL,   weight_mask = NULL )"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/prepare_nmar_scaling.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prepare scaled matrices and moments (low-level) ‚Äî prepare_nmar_scaling","text":"Z_un response model matrix (intercept column). X_un auxiliary model matrix (intercept), NULL. mu_x_un named numeric vector auxiliary means original scale (names must match `colnames(X_un)`), NULL. standardize logical; apply standardization TRUE. weights Optional numeric vector used weighted scaling. weight_mask Optional logical/numeric mask applied `weights`.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/prepare_nmar_scaling.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Prepare scaled matrices and moments (low-level) ‚Äî prepare_nmar_scaling","text":"list `Z`, `X`, `mu_x`, `recipe`.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/print.nmar_engine.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for NMAR engines ‚Äî print.nmar_engine","title":"Print method for NMAR engines ‚Äî print.nmar_engine","text":"Provides compact, human-friendly summary `nmar_engine` objects. Child classes inherit method; can override need different presentation.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/print.nmar_engine.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for NMAR engines ‚Äî print.nmar_engine","text":"","code":"# S3 method for class 'nmar_engine' print(x, ...)"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/print.nmar_engine.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for NMAR engines ‚Äî print.nmar_engine","text":"x engine object inheriting `nmar_engine`. ... Unused.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/print.nmar_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for nmar_result ‚Äî print.nmar_result","title":"Print method for nmar_result ‚Äî print.nmar_result","text":"Print method nmar_result","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/print.nmar_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for nmar_result ‚Äî print.nmar_result","text":"","code":"# S3 method for class 'nmar_result' print(x, ...)"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/print.nmar_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for nmar_result ‚Äî print.nmar_result","text":"x nmar_result object ... Additional parameters","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/print.nmar_result_el.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for EL results ‚Äî print.nmar_result_el","title":"Print method for EL results ‚Äî print.nmar_result_el","text":"Compact print objects class `nmar_result_el`.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/print.nmar_result_el.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for EL results ‚Äî print.nmar_result_el","text":"","code":"# S3 method for class 'nmar_result_el' print(x, ...)"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/print.nmar_result_el.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for EL results ‚Äî print.nmar_result_el","text":"x object class `nmar_result_el`. ... Ignored.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/print.summary_nmar_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for summary.nmar_result ‚Äî print.summary_nmar_result","title":"Print method for summary.nmar_result ‚Äî print.summary_nmar_result","text":"Print method summary.nmar_result","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/print.summary_nmar_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for summary.nmar_result ‚Äî print.summary_nmar_result","text":"","code":"# S3 method for class 'summary_nmar_result' print(x, ...)"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/print.summary_nmar_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for summary.nmar_result ‚Äî print.summary_nmar_result","text":"x summary_nmar_result object ... Additional parameters","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/probit_family.html","id":null,"dir":"Reference","previous_headings":"","what":"Probit family functions (link and derivatives) ‚Äî probit_family","title":"Probit family functions (link and derivatives) ‚Äî probit_family","text":"Probit family functions (link derivatives)","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/probit_family.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Probit family functions (link and derivatives) ‚Äî probit_family","text":"","code":"probit_family()"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/riddles_case1.html","id":null,"dir":"Reference","previous_headings":"","what":"Riddles Simulation, Case 1: Linear Mean ‚Äî riddles_case1","title":"Riddles Simulation, Case 1: Linear Mean ‚Äî riddles_case1","text":"simulated dataset 500 observations based Simulation Study (Model 1, Case 1) Riddles, Kim, Im (2016). data features nonignorable nonresponse (NMAR) mechanism response probability depends study variable `y`.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/riddles_case1.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Riddles Simulation, Case 1: Linear Mean ‚Äî riddles_case1","text":"","code":"riddles_case1"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/riddles_case1.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Riddles Simulation, Case 1: Linear Mean ‚Äî riddles_case1","text":"data frame 500 rows 4 variables: x Numeric. auxiliary variable, x ~ Normal(0, 0.5). y Numeric. study variable nonignorable nonresponse.            `y` contains `NA`s nonrespondents. y_true Numeric. complete, true value `y`                 missingness introduced. delta Integer. response indicator (1 = responded, 0 = nonresponse).","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/riddles_case1.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Riddles Simulation, Case 1: Linear Mean ‚Äî riddles_case1","text":"Riddles, M. K., Kim, J. K., & Im, J. (2016).         Propensity-Score-Adjustment Method Nonignorable Nonresponse.         Journal Survey Statistics Methodology, 4(1), 1-31.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/riddles_case1.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Riddles Simulation, Case 1: Linear Mean ‚Äî riddles_case1","text":"dataset generated using following model parameters (n = 500): Density x: x ~ Normal(mean = 0, variance = 0.5) Density error: e ~ Normal(mean = 0, variance = 0.9) True Model (Case 1): y_true = -1 + x + e Response Model (NMAR): logit(pi) = 0.8 - 0.2 * y_true","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/riddles_case2.html","id":null,"dir":"Reference","previous_headings":"","what":"Riddles Simulation, Case 2: Exponential Mean ‚Äî riddles_case2","title":"Riddles Simulation, Case 2: Exponential Mean ‚Äî riddles_case2","text":"simulated dataset 500 observations based Simulation Study (Model 1, Case 2) Riddles, Kim, Im (2016). data features nonignorable nonresponse (NMAR) mechanism response probability depends study variable `y`.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/riddles_case2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Riddles Simulation, Case 2: Exponential Mean ‚Äî riddles_case2","text":"","code":"riddles_case2"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/riddles_case2.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Riddles Simulation, Case 2: Exponential Mean ‚Äî riddles_case2","text":"data frame 500 rows 4 variables: x Numeric. auxiliary variable, x ~ Normal(0, 0.5). y Numeric. study variable nonignorable nonresponse.            `y` contains `NA`s nonrespondents. y_true Numeric. complete, true value `y`                 missingness introduced. delta Integer. response indicator (1 = responded, 0 = nonresponse).","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/riddles_case2.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Riddles Simulation, Case 2: Exponential Mean ‚Äî riddles_case2","text":"Riddles, M. K., Kim, J. K., & Im, J. (2016).         Propensity-Score-Adjustment Method Nonignorable Nonresponse.         Journal Survey Statistics Methodology, 4(1), 1-31.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/riddles_case2.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Riddles Simulation, Case 2: Exponential Mean ‚Äî riddles_case2","text":"dataset generated using following model parameters (n = 500): Density x: x ~ Normal(mean = 0, variance = 0.5) Density error: e ~ Normal(mean = 0, variance = 0.9) True Model (Case 2): y_true = -2 + 0.5 * exp(x) + e Response Model (NMAR): logit(pi) = 0.8 - 0.2 * y_true","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/riddles_case3.html","id":null,"dir":"Reference","previous_headings":"","what":"Riddles Simulation, Case 3: Sine Wave Mean ‚Äî riddles_case3","title":"Riddles Simulation, Case 3: Sine Wave Mean ‚Äî riddles_case3","text":"simulated dataset 500 observations based Simulation Study (Model 1, Case 3) Riddles, Kim, Im (2016). data features nonignorable nonresponse (NMAR) mechanism response probability depends study variable `y`.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/riddles_case3.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Riddles Simulation, Case 3: Sine Wave Mean ‚Äî riddles_case3","text":"","code":"riddles_case3"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/riddles_case3.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Riddles Simulation, Case 3: Sine Wave Mean ‚Äî riddles_case3","text":"data frame 500 rows 4 variables: x Numeric. auxiliary variable, x ~ Normal(0, 0.5). y Numeric. study variable nonignorable nonresponse.            `y` contains `NA`s nonrespondents. y_true Numeric. complete, true value `y`                 missingness introduced. delta Integer. response indicator (1 = responded, 0 = nonresponse).","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/riddles_case3.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Riddles Simulation, Case 3: Sine Wave Mean ‚Äî riddles_case3","text":"Riddles, M. K., Kim, J. K., & Im, J. (2016).         Propensity-Score-Adjustment Method Nonignorable Nonresponse.         Journal Survey Statistics Methodology, 4(1), 1-31.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/riddles_case3.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Riddles Simulation, Case 3: Sine Wave Mean ‚Äî riddles_case3","text":"dataset generated using following model parameters (n = 500): Density x: x ~ Normal(mean = 0, variance = 0.5) Density error: e ~ Normal(mean = 0, variance = 0.9) True Model (Case 3): y_true = -1 + sin(2 * x) + e Response Model (NMAR): logit(pi) = 0.8 - 0.2 * y_true","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/riddles_case4.html","id":null,"dir":"Reference","previous_headings":"","what":"Riddles Simulation, Case 4: Cubic Mean ‚Äî riddles_case4","title":"Riddles Simulation, Case 4: Cubic Mean ‚Äî riddles_case4","text":"simulated dataset 500 observations based Simulation Study (Model 1, Case 4) Riddles, Kim, Im (2016). data features nonignorable nonresponse (NMAR) mechanism response probability depends study variable `y`.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/riddles_case4.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Riddles Simulation, Case 4: Cubic Mean ‚Äî riddles_case4","text":"","code":"riddles_case4"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/riddles_case4.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Riddles Simulation, Case 4: Cubic Mean ‚Äî riddles_case4","text":"data frame 500 rows 4 variables: x Numeric. auxiliary variable, x ~ Normal(0, 0.5). y Numeric. study variable nonignorable nonresponse.            `y` contains `NA`s nonrespondents. y_true Numeric. complete, true value `y`                 missingness introduced. delta Integer. response indicator (1 = responded, 0 = nonresponse).","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/riddles_case4.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Riddles Simulation, Case 4: Cubic Mean ‚Äî riddles_case4","text":"Riddles, M. K., Kim, J. K., & Im, J. (2016).         Propensity-Score-Adjustment Method Nonignorable Nonresponse.         Journal Survey Statistics Methodology, 4(1), 1-31.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/riddles_case4.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Riddles Simulation, Case 4: Cubic Mean ‚Äî riddles_case4","text":"dataset generated using following model parameters (n = 500): Density x: x ~ Normal(mean = 0, variance = 0.5) Density error: e ~ Normal(mean = 0, variance = 0.9) True Model (Case 4): y_true = -1 + 0.4 * x^3 + e Response Model (NMAR): logit(pi) = 0.8 - 0.2 * y_true","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/run_engine.nmar_engine_el.html","id":null,"dir":"Reference","previous_headings":"","what":"Run method for EL engine ‚Äî run_engine.nmar_engine_el","title":"Run method for EL engine ‚Äî run_engine.nmar_engine_el","text":"Run method EL engine","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/run_engine.nmar_engine_el.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run method for EL engine ‚Äî run_engine.nmar_engine_el","text":"","code":"# S3 method for class 'nmar_engine_el' run_engine(engine, formula, data, trace_level = 0)"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/sanitize_nleqslv_control.html","id":null,"dir":"Reference","previous_headings":"","what":"Sanitize nleqslv control list for compatibility ‚Äî sanitize_nleqslv_control","title":"Sanitize nleqslv control list for compatibility ‚Äî sanitize_nleqslv_control","text":"Sanitize nleqslv control list compatibility","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/sanitize_nleqslv_control.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sanitize nleqslv control list for compatibility ‚Äî sanitize_nleqslv_control","text":"","code":"sanitize_nleqslv_control(ctrl)"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/scale_aux_multipliers.html","id":null,"dir":"Reference","previous_headings":"","what":"Map unscaled auxiliary multipliers to scaled space ‚Äî scale_aux_multipliers","title":"Map unscaled auxiliary multipliers to scaled space ‚Äî scale_aux_multipliers","text":"Map unscaled auxiliary multipliers scaled space","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/scale_aux_multipliers.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Map unscaled auxiliary multipliers to scaled space ‚Äî scale_aux_multipliers","text":"","code":"scale_aux_multipliers(lambda_unscaled, recipe, columns)"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/scale_aux_multipliers.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Map unscaled auxiliary multipliers to scaled space ‚Äî scale_aux_multipliers","text":"lambda_unscaled named numeric vector auxiliary multipliers aligned auxiliary design columns (intercept) original scale. recipe `nmar_scaling_recipe`. columns character vector auxiliary column names (order) scaled design.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/scale_aux_multipliers.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Map unscaled auxiliary multipliers to scaled space ‚Äî scale_aux_multipliers","text":"numeric vector multipliers scaled space.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/scale_coefficients.html","id":null,"dir":"Reference","previous_headings":"","what":"Map unscaled coefficients to scaled space ‚Äî scale_coefficients","title":"Map unscaled coefficients to scaled space ‚Äî scale_coefficients","text":"Map unscaled coefficients scaled space","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/scale_coefficients.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Map unscaled coefficients to scaled space ‚Äî scale_coefficients","text":"","code":"scale_coefficients(beta_unscaled, recipe, columns)"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/scale_coefficients.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Map unscaled coefficients to scaled space ‚Äî scale_coefficients","text":"beta_unscaled named numeric vector coefficients response model original scale, including intercept named `\"(Intercept)\"`. recipe `nmar_scaling_recipe` returned scaling utilities. columns character vector column names (order) scaled design matrix (including intercept).","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/scale_coefficients.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Map unscaled coefficients to scaled space ‚Äî scale_coefficients","text":"numeric vector coefficients scaled space, ordered   `columns`.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/se.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract standard error for NMAR results ‚Äî se","title":"Extract standard error for NMAR results ‚Äî se","text":"Returns standard error primary mean estimate.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/se.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract standard error for NMAR results ‚Äî se","text":"","code":"se(object, ...)"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/se.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract standard error for NMAR results ‚Äî se","text":"object `nmar_result` subclass. ... Ignored.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/se.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract standard error for NMAR results ‚Äî se","text":"Numeric scalar.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/shared_weighted_gram.html","id":null,"dir":"Reference","previous_headings":"","what":"Weighted linear algebra helpers ‚Äî shared_weighted_gram","title":"Weighted linear algebra helpers ‚Äî shared_weighted_gram","text":"Weighted linear algebra helpers","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/shared_weighted_gram.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Weighted linear algebra helpers ‚Äî shared_weighted_gram","text":"","code":"shared_weighted_gram(X, w)"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/summary.nmar_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Summary method for nmar_result ‚Äî summary.nmar_result","title":"Summary method for nmar_result ‚Äî summary.nmar_result","text":"Summary method nmar_result","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/summary.nmar_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summary method for nmar_result ‚Äî summary.nmar_result","text":"","code":"# S3 method for class 'nmar_result' summary(object, conf.level = 0.95, ...)"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/summary.nmar_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summary method for nmar_result ‚Äî summary.nmar_result","text":"object nmar_result object conf.level Confidence level intervals. ... Additional parameters","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/summary.nmar_result_el.html","id":null,"dir":"Reference","previous_headings":"","what":"Summary method for EL results ‚Äî summary.nmar_result_el","title":"Summary method for EL results ‚Äî summary.nmar_result_el","text":"Summarize estimation, standard error missingness-model coefficients.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/summary.nmar_result_el.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summary method for EL results ‚Äî summary.nmar_result_el","text":"","code":"# S3 method for class 'nmar_result_el' summary(object, ...)"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/summary.nmar_result_el.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summary method for EL results ‚Äî summary.nmar_result_el","text":"object object class `nmar_result_el`. ... Ignored.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/tidy.nmar_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Tidy summary for NMAR results ‚Äî tidy.nmar_result","title":"Tidy summary for NMAR results ‚Äî tidy.nmar_result","text":"Return data frame primary estimate (available) missingness-model coefficients.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/tidy.nmar_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tidy summary for NMAR results ‚Äî tidy.nmar_result","text":"","code":"# S3 method for class 'nmar_result' tidy(x, conf.level = 0.95, ...)"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/tidy.nmar_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Tidy summary for NMAR results ‚Äî tidy.nmar_result","text":"x object class `nmar_result`. conf.level Confidence level primary estimate. ... Ignored.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/trim_weights.html","id":null,"dir":"Reference","previous_headings":"","what":"Trim weights by capping and proportional redistribution ‚Äî trim_weights","title":"Trim weights by capping and proportional redistribution ‚Äî trim_weights","text":"Applies cap nonnegative weight vector , feasible, redistributes excess mass across remaining positive entries total sum preserved. requested cap tight preserve total mass, positive entries set cap total sum decreases.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/trim_weights.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Trim weights by capping and proportional redistribution ‚Äî trim_weights","text":"","code":"trim_weights(weights, cap, tol = 1e-12, warn_tol = 1e-08)"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/trim_weights.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Trim weights by capping and proportional redistribution ‚Äî trim_weights","text":"weights numeric vector weights. cap positive numeric scalar; maximum allowed weight, Inf disable trimming. tol numeric tolerance used testing whether rescaling step respects cap. warn_tol numeric tolerance used testing whether total sum preserved.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/trim_weights.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Trim weights by capping and proportional redistribution ‚Äî trim_weights","text":"list components: weights numeric vector trimmed weights. trimmed_fraction fraction entries close       cap (within tol). preserved_sum logical; TRUE total sum       weights preserved within warn_tol. total_before numeric; sum original weights. total_after numeric; sum trimmed weights.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/trim_weights.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Trim weights by capping and proportional redistribution ‚Äî trim_weights","text":"Internally, simple water-filling style algorithm used positive weights: largest weights successively saturated cap remaining weights rescaled common factor chosen maintain total sum.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/unscale_coefficients.html","id":null,"dir":"Reference","previous_headings":"","what":"Unscale regression coefficients and covariance ‚Äî unscale_coefficients","title":"Unscale regression coefficients and covariance ‚Äî unscale_coefficients","text":"Unscale regression coefficients covariance","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/unscale_coefficients.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Unscale regression coefficients and covariance ‚Äî unscale_coefficients","text":"","code":"unscale_coefficients(scaled_coeffs, scaled_vcov, recipe)"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/unscale_coefficients.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Unscale regression coefficients and covariance ‚Äî unscale_coefficients","text":"scaled_coeffs named numeric vector coefficients estimated scaled space. scaled_vcov covariance matrix `scaled_coeffs`. recipe `nmar_scaling_recipe` produced scaling applied.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/unscale_coefficients.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Unscale regression coefficients and covariance ‚Äî unscale_coefficients","text":"list unscaled `coefficients` `vcov`.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/validate_and_apply_nmar_scaling.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate and apply scaling (engine-friendly) ‚Äî validate_and_apply_nmar_scaling","title":"Validate and apply scaling (engine-friendly) ‚Äî validate_and_apply_nmar_scaling","text":"Validate apply scaling (engine-friendly)","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/validate_and_apply_nmar_scaling.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate and apply scaling (engine-friendly) ‚Äî validate_and_apply_nmar_scaling","text":"","code":"validate_and_apply_nmar_scaling(   standardize,   has_aux,   response_model_matrix_unscaled,   aux_matrix_unscaled,   mu_x_unscaled,   weights = NULL,   weight_mask = NULL )"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/validate_and_apply_nmar_scaling.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Validate and apply scaling (engine-friendly) ‚Äî validate_and_apply_nmar_scaling","text":"standardize logical; apply standardization TRUE. has_aux logical; whether engine uses auxiliary constraints. response_model_matrix_unscaled response model matrix (intercept). aux_matrix_unscaled auxiliary matrix (intercept) empty matrix. mu_x_unscaled named auxiliary means original scale, NULL. weights Optional numeric vector used weighted scaling. weight_mask Optional logical/numeric mask applied `weights`.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/validate_and_apply_nmar_scaling.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Validate and apply scaling (engine-friendly) ‚Äî validate_and_apply_nmar_scaling","text":"list `nmar_scaling_recipe`, `response_model_matrix_scaled`,   `auxiliary_matrix_scaled`, `mu_x_scaled`.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/validate_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate Data for NMAR Analysis ‚Äî validate_data","title":"Validate Data for NMAR Analysis ‚Äî validate_data","text":"Little sanity-check data","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/validate_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate Data for NMAR Analysis ‚Äî validate_data","text":"","code":"validate_data(data)"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/validate_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Validate Data for NMAR Analysis ‚Äî validate_data","text":"data data frame survey object.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/validate_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Validate Data for NMAR Analysis ‚Äî validate_data","text":"Returns `invisible(NULL)` success, stopping descriptive error failure.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/validate_nleqslv_top.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate top-level nleqslv arguments (coerce invalid to defaults) ‚Äî validate_nleqslv_top","title":"Validate top-level nleqslv arguments (coerce invalid to defaults) ‚Äî validate_nleqslv_top","text":"Validate top-level nleqslv arguments (coerce invalid defaults)","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/validate_nleqslv_top.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate top-level nleqslv arguments (coerce invalid to defaults) ‚Äî validate_nleqslv_top","text":"","code":"validate_nleqslv_top(top)"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/validate_nmar_engine_el.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate EL Engine Settings ‚Äî validate_nmar_engine_el","title":"Validate EL Engine Settings ‚Äî validate_nmar_engine_el","text":"Validate EL Engine Settings","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/validate_nmar_engine_el.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate EL Engine Settings ‚Äî validate_nmar_engine_el","text":"","code":"validate_nmar_engine_el(engine)"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/validate_nmar_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate nmar_result structure ‚Äî validate_nmar_result","title":"Validate nmar_result structure ‚Äî validate_nmar_result","text":"Ensures child class parent schema satisfied. validator also back-fills defaults downstream code can rely presence optional components without defensive checks.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/validate_nmar_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate nmar_result structure ‚Äî validate_nmar_result","text":"","code":"validate_nmar_result(x, class_name)"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/validate_nmar_result.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Validate nmar_result structure ‚Äî validate_nmar_result","text":"helper single authority `nmar_result` schema. expects list already carries class c(class_name, \"nmar_result\") least primary estimate stored y_hat. components optional; NULL missing, validator supplies safe defaults: Core scalars: se (numeric, default NA_real_),     estimate_name (character, default NA_character_),     converged (logical, default NA). model: list coefficients vcov,     defaulting NULL. weights_info: list values (default NULL)     trimmed_fraction (default NA_real_). sample: list n_total, n_respondents,     is_survey, design, defaulted missing/empty values. inference: list variance_method, df,     message, defaulted missing values. diagnostics, meta, extra: defaulted empty     lists, meta carrying engine_name, call,     formula unset. Engine constructors normally call new_nmar_result() rather invoking function directly. new_nmar_result() attaches classes funnels objects validate_nmar_result() downstream S3 methods can assume consistent structure.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/vcov.nmar_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Variance-covariance for base NMAR results ‚Äî vcov.nmar_result","title":"Variance-covariance for base NMAR results ‚Äî vcov.nmar_result","text":"Variance-covariance base NMAR results","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/vcov.nmar_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Variance-covariance for base NMAR results ‚Äî vcov.nmar_result","text":"","code":"# S3 method for class 'nmar_result' vcov(object, ...)"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/vcov.nmar_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Variance-covariance for base NMAR results ‚Äî vcov.nmar_result","text":"object object class `nmar_result`. ... Ignored.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/voting.html","id":null,"dir":"Reference","previous_headings":"","what":"Aggregated Exit Poll Data for Gangdong-Gap (2012) ‚Äî voting","title":"Aggregated Exit Poll Data for Gangdong-Gap (2012) ‚Äî voting","text":"dataset contains aggregated exit poll results Gangdong-Gap district Seoul 2012 nineteenth South Korean legislative election. data transcribed directly Table 9 Riddles, Kim, Im (2016).","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/voting.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Aggregated Exit Poll Data for Gangdong-Gap (2012) ‚Äî voting","text":"","code":"voting"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/voting.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Aggregated Exit Poll Data for Gangdong-Gap (2012) ‚Äî voting","text":"data frame 8 rows 7 variables: Gender Factor. gender voter (\"Male\", \"Female\"). Age_group Character. age group voter. Voted_A Numeric. Count respondents voting Party . Voted_B Numeric. Count respondents voting Party B. Numeric. Count respondents voting another party. Refusal Numeric. Count sampled individuals refused                  respond (nonresponse count). Total Numeric. Total individuals sampled group                (Responders + Refusals).","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/voting.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Aggregated Exit Poll Data for Gangdong-Gap (2012) ‚Äî voting","text":"Riddles, M. K., Kim, J. K., & Im, J. (2016).         Propensity-Score-Adjustment Method Nonignorable Nonresponse.         *Journal Survey Statistics Methodology*, 4(1), 1‚Äì31.         (Data Table 9, p. 20).","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/voting.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Aggregated Exit Poll Data for Gangdong-Gap (2012) ‚Äî voting","text":"paper's application, `Gender` used nonresponse instrumental variable `Age_group` primary auxiliary variable .","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/weights.nmar_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract Weights from NMAR Result ‚Äî weights.nmar_result","title":"Extract Weights from NMAR Result ‚Äî weights.nmar_result","text":"Extract Weights NMAR Result","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/weights.nmar_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract Weights from NMAR Result ‚Äî weights.nmar_result","text":"","code":"# S3 method for class 'nmar_result' weights(object, scale = c(\"probability\", \"population\"), ...)"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/weights.nmar_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract Weights from NMAR Result ‚Äî weights.nmar_result","text":"object object class nmar_result. scale Character: \"probability\" (default) \"population\". \"probability\" Returns \\(p_i = \\tilde w_i / \\sum_j \\tilde w_j\\) \\(\\sum_i p_i = 1\\).     canonical form computing means, example     \\(\\bar y = \\sum_i p_i y_i\\). \"population\" Returns \\(w_i = N_\\mathrm{pop} p_i\\) \\(\\sum_i w_i = N_\\mathrm{pop}\\).     follows survey conventions can used totals     \\(\\hat T = \\sum_i w_i y_i = N_\\mathrm{pop} \\bar y\\). ... Additional arguments (ignored).","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/weights.nmar_result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract Weights from NMAR Result ‚Äî weights.nmar_result","text":"Numeric vector weights length equal number respondents.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/weights.nmar_result.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Extract Weights from NMAR Result ‚Äî weights.nmar_result","text":"convention, NMAR engines expose analysis weights store unnormalized respondent masses \\(\\tilde w_i\\) analysis scale weights_info$values component, record population size \\(N_\\mathrm{pop}\\) sample$n_total. empirical likelihood (EL) engine masses \\(\\tilde w_i = d_i / D_i(\\theta)\\) Qin, Leung, Shao (2002); exponential tilting engines may store corresponding tilted masses. engine follows convention, helper standardizes masses probability population weights following properties (floating-point error, even trimming): sum(weights(object, scale = \"probability\")) = 1; sum(weights(object, scale = \"population\")) = N_pop; weights(object, \"population\") = N_pop * weights(object, \"probability\"). Engines use different internal weighting schemes can either map weights convention (populating weights_info$values sample$n_total accordingly) provide engine-specific methods weights.nmar_result_<method>() different interpretation required. Trimming effects: trim_cap < Inf trimming active, stored unnormalized masses \\(\\tilde w_i\\) may longer satisfy identities \\(\\sum_i \\tilde w_i = \\sum_i d_i\\). helper always renormalizes stored masses via $$w_i = N_\\mathrm{pop} \\tilde w_i / \\sum_j \\tilde w_j,$$ returned probability- population-scale weights satisfy stated sums regardless trimming denominator floors used internally.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/weights.nmar_result.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Extract Weights from NMAR Result ‚Äî weights.nmar_result","text":"Qin, J., Leung, D., Shao, J. (2002). Estimation survey data nonignorable nonresponse informative sampling. Journal American Statistical Association, 97(457), 193-200.","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/reference/weights.nmar_result.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract Weights from NMAR Result ‚Äî weights.nmar_result","text":"","code":"if (FALSE) { # \\dontrun{ res <- nmar(y_miss ~ x, data = df, engine = el_engine())  # Probability weights (default): sum to 1 w_prob <- weights(res) sum(w_prob) # 1 (up to numerical precision)  # Population weights: sum to N_pop w_pop <- weights(res, scale = \"population\") sum(w_pop) # nrow(df) for IID data  # Relationship (exact up to floating-point error): all.equal(w_pop, nrow(df) * w_prob) } # }"},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/news/index.html","id":"nmar-development-version","dir":"Changelog","previous_headings":"","what":"NMAR (development version)","title":"NMAR (development version)","text":"Preparing CRAN deploy","code":""},{"path":[]},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/news/index.html","id":"major-changes-0-0-0-1","dir":"Changelog","previous_headings":"","what":"Major changes","title":"NMAR 0.0.0.1","text":"Exptilt, el share similar structure design (#27)","code":""},{"path":"https://ncn-foreigners.ue.poznan.pl/NMAR/index.html/news/index.html","id":"minor-improvements-and-bug-fixes-0-0-0-1","dir":"Changelog","previous_headings":"","what":"Minor improvements and bug fixes","title":"NMAR 0.0.0.1","text":"feature 1 feature 2","code":""}]
