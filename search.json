[{"path":"https://ncn-foreigners.github.io/NMAR/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2025 nmar authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/articles/developing_new_nmar_estimator.html","id":"developing-a-new-nmar-estimator-in-the-nmar-package","dir":"Articles","previous_headings":"","what":"Developing a New NMAR Estimator in the nmar Package","title":"Developing a New NMAR Estimator","text":"guide explains add integrate new ‑Missing‑‑Random (NMAR) statistical estimator nmar, following architecture used Empirical Likelihood (EL) engine, emphasizing clean separation concerns: Shared, reusable utilities live src_dev/shared/ (scaling, families, bootstrap, numerics, diagnostics). Estimator‑specific math code live src_dev/engines/<method>/. Repository conventions - Always edit source src_dev/; flat files R/ generated running Rscript build_r_folder.R. - changing src_dev/, regenerate roxygen outputs R -q -e \"devtools::document()\" confirm git status clean; keeps S3 registrations Rd files sync. - Use testthat v3 tests/testthat/ tests run R -q -e \"devtools::test()\" opening PR. - Use roxygen2 documentation; edit NAMESPACE directly.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/articles/developing_new_nmar_estimator.html","id":"general-guidelines","dir":"Articles","previous_headings":"Developing a New NMAR Estimator in the nmar Package","what":"0) General guidelines","title":"Developing a New NMAR Estimator","text":"Adhere functional programming style design patterns (writing pure functions, function factories, functionals, function operators) appropriate (eg. building systems equations) use unpredictable functions like sapply, use vapply purrr equivalents instead Avoid code duplication, reuse shared infrastructure much possible Develop loosely coupled, modular architecture, identify shareable, method-agnostic functionalities Use S3 OOP system Use constructor validator functions S3 objects Follow best software engineering practices, including SOLID, DRY, KISS, YAGNI, Separation Concerns, Principle Least Astonishment, Law Demeter?","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/articles/developing_new_nmar_estimator.html","id":"overview-of-the-package-flow","dir":"Articles","previous_headings":"Developing a New NMAR Estimator in the nmar Package","what":"1) Overview of the package flow","title":"Developing a New NMAR Estimator","text":"User workflow: User creates engine configuration (e.g., el_engine(...)). User calls nmar(formula = ..., data = ..., engine = <engine>). nmar() creates nmar_input_spec via parse_nmar_spec(), validates validate_nmar_args() (using engine-specific traits), dispatches run_engine(engine, task) S3. *.data.frame(...) IID data *.survey.design(...) complex surveys method computes estimator returns result object class c(\"nmar_result_<method>\", \"nmar_result\") containing primary estimand supporting data S3 methods.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/articles/developing_new_nmar_estimator.html","id":"what-to-implement-for-a-new-estimator","dir":"Articles","previous_headings":"Developing a New NMAR Estimator in the nmar Package","what":"2) What to implement for a new estimator","title":"Developing a New NMAR Estimator","text":"Assume engine named <method> (e.g., exptilt2, abc, etc.). Create following files src_dev/engines/<method>/:","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/articles/developing_new_nmar_estimator.html","id":"engine-r-engine-constructor","dir":"Articles","previous_headings":"Developing a New NMAR Estimator in the nmar Package > 2) What to implement for a new estimator","what":"1) engine.R — engine constructor","title":"Developing a New NMAR Estimator","text":"Important: add @keywords engine roxygen ### 2) run_engine.R — run_engine method engine rely shared validation/traits infrastructure:","code":"method_engine <- function(...) { # Validate controls using validate_arguments.R as in exptilt.   validator$assert_choice(family, choices = c(\"logit\", \"probit\"), name = \"family\")    engine <- list(...)   class(engine) <- c(\"nmar_engine_method\", \"nmar_engine\")   engine } run_engine.nmar_engine_method <- function(engine, task) {   design <- prepare_nmar_design(     task,     standardize = engine$standardize,     auxiliary_means = engine$auxiliary_means,     include_response = TRUE,     include_auxiliary = TRUE   )    args <- c(     list(       data = design$survey_design %||% design$data,       formula = task$formula,       response_predictors = if (length(design$response_predictors)) design$response_predictors else NULL,       auxiliary_means = design$auxiliary_means,       standardize = design$standardize     ),     as.list(engine)   )    method_fn <- get(\"method\", mode = \"function\")   fit <- do.call(method_fn, args)   if (!inherits(fit, \"nmar_result_method\")) stop(\"Expected nmar_result_method.\")   fit } engine_traits.nmar_engine_method <- function(engine) {   utils::modifyList(     engine_traits.default(engine),     list(       allow_outcome_in_missingness = TRUE,      # customise as needed       allow_covariate_overlap = FALSE,       requires_single_outcome = TRUE     )   ) }"},{"path":"https://ncn-foreigners.github.io/NMAR/articles/developing_new_nmar_estimator.html","id":"implmethod-r-define-the-generic","dir":"Articles","previous_headings":"Developing a New NMAR Estimator in the nmar Package > 2) What to implement for a new estimator","what":"3) impl/<method>.R — define the generic","title":"Developing a New NMAR Estimator","text":"","code":"#' @param data A data.frame or survey.design. #' @export method <- function(data, ...) UseMethod(\"method\")"},{"path":"https://ncn-foreigners.github.io/NMAR/articles/developing_new_nmar_estimator.html","id":"implmethod_dataframe-r-method-for-iid-data","dir":"Articles","previous_headings":"Developing a New NMAR Estimator in the nmar Package > 2) What to implement for a new estimator","what":"4) impl/<method>_dataframe.R — method for IID data","title":"Developing a New NMAR Estimator","text":"","code":"#' @export method.data.frame <- function(data, formula, controls = list(), ...) { # Prepare inputs. You may adapt from EL’s prepare_el_inputs() pattern.   parsed <- build_method_inputs(data, formula, controls)   estimation_data <- parsed$data   internal_formula <- parsed$formula_list  # Identify respondents   response_var <- all.vars(internal_formula$response)[1]   obs_idx <- which(estimation_data[[response_var]] == 1)  # Build design matrices   Z_un <- model.matrix(update(internal_formula$response, NULL ~ .), data = estimation_data[obs_idx, ])   X_un <- build_method_auxiliary_matrix(estimation_data[obs_idx, ])   mu_x <- controls$auxiliary_means  # Shared scaling   sc <- validate_and_apply_nmar_scaling(     standardize = TRUE, has_aux = !is.null(X_un),     response_model_matrix_unscaled = Z_un,     auxiliary_matrix_unscaled = if (is.null(X_un)) matrix(nrow = nrow(Z_un), ncol = 0) else X_un,     mu_x_unscaled = mu_x   )  # Solve on the scaled space (method-specific code)   fit <- method_solve_core(     full_data = estimation_data,     respondent_data = estimation_data[obs_idx, ],     response_model_matrix_scaled = sc$response_model_matrix_scaled,     auxiliary_matrix_scaled = sc$auxiliary_matrix_scaled,     mu_x_scaled = sc$mu_x_scaled,     controls = controls,     ...   )  # Wrap into a standard result object (see Section 5)   new_nmar_result_method(     estimate = fit$estimate,     std_error = fit$std_error,     coefficients = fit$model$coefficients,     vcov = fit$model$vcov,     diagnostics = fit$diagnostics   ) }"},{"path":"https://ncn-foreigners.github.io/NMAR/articles/developing_new_nmar_estimator.html","id":"implmethod_survey-r-method-for-survey-design","dir":"Articles","previous_headings":"Developing a New NMAR Estimator in the nmar Package > 2) What to implement for a new estimator","what":"5) impl/<method>_survey.R — method for survey.design","title":"Developing a New NMAR Estimator","text":"Follow EL’s el.survey.design pattern: Subset respondents via observed_mask. Get respondent base weights via weights(resp_design) set N_pop <- sum(weights(design)). Compute covariance “total scores” delta variance using svytotal(~ scores, design) followed vcov(). See Variance subsection .","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/articles/developing_new_nmar_estimator.html","id":"implmethod_equations-r-implmethod_jacobian-r-optional","dir":"Articles","previous_headings":"Developing a New NMAR Estimator in the nmar Package > 2) What to implement for a new estimator","what":"6) impl/<method>_equations.R / impl/<method>_jacobian.R (optional)","title":"Developing a New NMAR Estimator","text":"estimator uses system estimating equations analytic Jacobian (like EL), define document . Otherwise, keep method‑specific math (e.g., likelihood, gradients, constraints).","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/articles/developing_new_nmar_estimator.html","id":"implmethod_variance-r","dir":"Articles","previous_headings":"Developing a New NMAR Estimator in the nmar Package > 2) What to implement for a new estimator","what":"7) impl/<method>_variance.R","title":"Developing a New NMAR Estimator","text":"Jacobian inversion policy: invert_jacobian() (ridge/pinv options). IID B: cross‑product respondent score rows “expanded” N (zeros nonrespondents). Survey B: covariance design totals via svytotal. Add option use shared bootstrap variance helpers (bootstrap_variance()) IID survey designs.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/articles/developing_new_nmar_estimator.html","id":"implmethod_constructors-r","dir":"Articles","previous_headings":"Developing a New NMAR Estimator in the nmar Package > 2) What to implement for a new estimator","what":"8) impl/<method>_constructors.R","title":"Developing a New NMAR Estimator","text":"Call new_nmar_result() inside constructor object carries class c(\"nmar_result_<method>\", \"nmar_result\") shares standard layout: Scalar fields: estimate, estimate_name, std_error, converged. Lists: model (coefficients/vcov), weights_info, sample, inference, diagnostics, meta, extra. Populate components directly; add extra top-level aliases y_hat data_info. Call validate_nmar_result() returning ensure structure complete. Minimal constructor example (inside src_dev/engines/<method>/impl/constructors.R):","code":"#' @keywords internal new_nmar_result_method <- function(estimate, std_error,                                    coefficients = NULL, vcov = NULL,                                    weights = NULL, sample = list(),                                    inference = list(variance_method = NA_character_,                                                     df = NA_real_,                                                     message = NA_character_,                                                     used_pseudoinverse = FALSE,                                                     used_ridge = FALSE),                                    diagnostics = list(),                                    meta = list(engine_name = \"method\", call = NULL, formula = NULL),                                    extra = list()) {   sample_defaults <- list(n_total = NA_integer_, n_respondents = NA_integer_,                           is_survey = FALSE, design = NULL, outcome_var = NA_character_)   sample <- utils::modifyList(sample_defaults, sample)   result <- new_nmar_result(     estimate = estimate,     estimate_name = sample$outcome_var,     std_error = std_error,     converged = TRUE,     model = list(coefficients = coefficients, vcov = vcov),     weights_info = list(values = weights, trimmed_fraction = NA_real_),     sample = list(n_total = sample$n_total,                   n_respondents = sample$n_respondents,                   is_survey = sample$is_survey,                   design = sample$design),     inference = inference,     diagnostics = diagnostics,     meta = meta,     extra = extra,     class = \"nmar_result_method\"   )   validate_nmar_result(result, \"nmar_result_method\") }"},{"path":"https://ncn-foreigners.github.io/NMAR/articles/developing_new_nmar_estimator.html","id":"s3-r-s3-methods-for-your-result-class","dir":"Articles","previous_headings":"Developing a New NMAR Estimator in the nmar Package > 2) What to implement for a new estimator","what":"9) s3.R — S3 methods for your result class","title":"Developing a New NMAR Estimator","text":"Implement (rely parent defaults): print.nmar_result_<method>(), summary.nmar_result_<method>() (optional). overriding, call NextMethod() first reuse parent output append estimator-specific details. estimate(), vcov(), confint(), tidy(), glance(): work box long populate shared schema. Optional accessors: weights(), fitted(), coef(), etc., engine exposes .","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/articles/developing_new_nmar_estimator.html","id":"reusing-shared-infrastructure","dir":"Articles","previous_headings":"Developing a New NMAR Estimator in the nmar Package","what":"3) Reusing shared infrastructure","title":"Developing a New NMAR Estimator","text":"Use shared modules src_dev/shared/:","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/articles/developing_new_nmar_estimator.html","id":"scaling","dir":"Articles","previous_headings":"Developing a New NMAR Estimator in the nmar Package > 3) Reusing shared infrastructure","what":"Scaling","title":"Developing a New NMAR Estimator","text":"validate_and_apply_nmar_scaling() standardize Z/X auxiliary means solving, returning nmar_scaling_recipe unscaling. unscale_coefficients() map scaled coefficients vcov back original scale reporting. Intercept never scaled; constant columns get sd=1. Engines may create recipe respondents‑matrices (EL) full/design matrices.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/articles/developing_new_nmar_estimator.html","id":"families-response-model","dir":"Articles","previous_headings":"Developing a New NMAR Estimator in the nmar Package > 3) Reusing shared infrastructure","what":"Families (response model)","title":"Developing a New NMAR Estimator","text":"logit_family() / probit_family() expose linkinv, mu.eta, d2mu.deta2, score_eta link‑agnostic estimating equations Jacobians. Probit uses tail‑stable log‑ratio phi/Phi.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/articles/developing_new_nmar_estimator.html","id":"bootstrap-variance","dir":"Articles","previous_headings":"Developing a New NMAR Estimator in the nmar Package > 3) Reusing shared infrastructure","what":"Bootstrap variance","title":"Developing a New NMAR Estimator","text":"bootstrap_variance() S3 generic methods data.frame survey.design. IID: resample rows rerun estimator. Survey: convert bootstrap replicate weights (svrep::as_bootstrap_design), use survey::withReplicates, survey::svrVar.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/articles/developing_new_nmar_estimator.html","id":"engine-boundaries-and-naming","dir":"Articles","previous_headings":"Developing a New NMAR Estimator in the nmar Package > 3) Reusing shared infrastructure","what":"4) Engine boundaries and naming","title":"Developing a New NMAR Estimator","text":"call helpers engines’ impl/ folders. Engines must depend src_dev/shared/ src_dev/engines/<method>/impl/. Prefix engine‑specific helpers <method>_ (e.g., el_... empirical likelihood) signal ownership avoid accidental reuse. parent S3 class nmar_result provides default methods (estimate, vcov, confint, tidy, glance, plot/autoplot, coef, fitted, weights, formula). Implement child print/summary need extra presentation.","code":""},{"path":[]},{"path":"https://ncn-foreigners.github.io/NMAR/articles/el_empirical_likelihood_theory.html","id":"units","dir":"Articles","previous_headings":"Notation","what":"Units","title":"Empirical Likelihood Theory","text":"=1,…,ni = 1, \\ldots, n index respondents (observed YY) Ri∈{0,1}R_i \\\\{0, 1\\} response indicator; work observed subset Ri=1R_i = 1","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/articles/el_empirical_likelihood_theory.html","id":"data","dir":"Articles","previous_headings":"Notation","what":"Data","title":"Empirical Likelihood Theory","text":"Outcome: YiY_i (observed Ri=1R_i = 1; missing otherwise) Response covariates: row vector Zi∈ℝKZ_i \\\\mathbb{R}^K, model.matrix response RHS Auxiliary covariates: row vector Xi∈ℝLX_i \\\\mathbb{R}^L (possibly L=0L = 0), auxiliary RHS (intercept) Population auxiliary means: μx∈ℝL\\mu_x \\\\mathbb{R}^L, known; names match columns XX","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/articles/el_empirical_likelihood_theory.html","id":"response-model-family-functions","dir":"Articles","previous_headings":"Notation","what":"Response Model (Family functions)","title":"Empirical Likelihood Theory","text":"Linear predictor: ηi=Ziβ\\eta_i = Z_i \\, \\beta Response probability: wi≡g(ηi)=linkinv(ηi)w_i \\equiv g(\\eta_i) = \\mathrm{linkinv}(\\eta_i) First derivative: dwdη(ηi)=μη,=mu.eta(ηi)\\dfrac{dw}{d\\eta}(\\eta_i) = \\mu_{\\eta,} = \\mathrm{mu.eta}(\\eta_i) Second derivative: d2wdη2(ηi)=d2mu.deta2(ηi)\\dfrac{d^2 w}{d\\eta^2}(\\eta_i) = \\mathrm{d2mu.deta2}(\\eta_i) linkinv, mu.eta, d2mu.deta2 refer chosen response family (logit probit). follow paper’s wiw_i notation response probability reserve piELp_i^{\\text{EL}} empirical‑likelihood weights.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/articles/el_empirical_likelihood_theory.html","id":"weight-re-parameterization","dir":"Articles","previous_headings":"Notation","what":"Weight Re-parameterization","title":"Empirical Likelihood Theory","text":"W∈(0,1)W \\(0,1) nuisance scalar; parameterize via z=logit(W)z = \\text{logit}(W) stability set W=plogis(z)W = \\text{plogis}(z) λW∈ℝ\\lambda_W \\\\mathbb{R} λx∈ℝL\\lambda_x \\\\mathbb{R}^L EL Lagrange multipliers constraints; collected together θ\\theta","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/articles/el_empirical_likelihood_theory.html","id":"el-weights","dir":"Articles","previous_headings":"Notation","what":"EL Weights","title":"Empirical Likelihood Theory","text":"Denominator: Di=1+λW(wi−W)+(Xi−μx)TλxD_i = 1 + \\lambda_W (w_i - W) + (X_i - \\mu_x)^T \\lambda_x Base sampling weights: ai=1a_i = 1 (IID) ai=a_i = survey base weight respondent ii EL weights respondents: piEL∝ai/Dip_i^{\\text{EL}} \\propto a_i / D_i (proportionality normalized totals )","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/articles/el_empirical_likelihood_theory.html","id":"estimator","dir":"Articles","previous_headings":"Notation","what":"Estimator","title":"Empirical Likelihood Theory","text":"Ŷ=∑piELYi/∑piEL\\hat{Y} = \\sum p_i^{\\text{EL}} Y_i / \\sum p_i^{\\text{EL}}","code":""},{"path":[]},{"path":"https://ncn-foreigners.github.io/NMAR/articles/el_empirical_likelihood_theory.html","id":"engines","dir":"Articles","previous_headings":"Notation","what":"Engines","title":"Empirical Likelihood Theory","text":"Family: “logit” (default) “probit”; use log‑likelihood score w.r.t. η\\eta: si=∂logwi/∂ηi=μη,/wis_i = \\partial\\log w_i/\\partial\\eta_i = \\mu_{\\eta,}/w_i (respondents, δi=1\\delta_i=1) Scaling: optional standardization design matrices μx\\mu_x via nmar_scaling_recipe","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/articles/el_empirical_likelihood_theory.html","id":"from-paper-to-implementation-core-ideas","dir":"Articles","previous_headings":"","what":"From Paper to Implementation: Core Ideas","title":"Empirical Likelihood Theory","text":"paper (Qin–Leung–Shao, JASA 2002) sets EL nonignorable response using: Zero‑sum residual: ∑piEL(wi−W)=0\\sum p_i^{\\text{EL}} (w_i - W) = 0 Auxiliary moments: ∑piEL(Xi−μx)=0\\sum p_i^{\\text{EL}} (X_i - \\mu_x) = 0 response model probability wi=g(ηi)w_i = g(\\eta_i), ηi=Ziβ\\eta_i = Z_i \\, \\beta code, adopt EL structure estimating equations. extend arbitrary ZZ XX, survey designs via design-based covariance variance estimation. Ŷ\\hat Y ratio--weights estimator, common normalization piEL∝ai/Dip_i^{\\text{EL}} \\propto a_i/D_i cancels Ŷ\\hat Y; relative weights matter (KKT multipliers λ\\lambda enforce constraints; normalization affects common scale vanishes ratio).","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/articles/el_empirical_likelihood_theory.html","id":"equation-crosswalk-qls-2002-this-vignettecode","dir":"Articles","previous_headings":"From Paper to Implementation: Core Ideas","what":"Equation Crosswalk (QLS 2002 → This Vignette/Code)","title":"Empirical Likelihood Theory","text":"QLS (5): Discrete mass form pip_i two multipliers → Di=1+λW(wi−W)+(Xi−μx)TλxD_i = 1 + \\lambda_W (w_i - W) + (X_i - \\mu_x)^T \\lambda_x piEL∝ai/Dip_i^{\\text{EL}} \\propto a_i/D_i. QLS (7): ∑xi−x‾1+⋯=0\\sum \\dfrac{x_i - \\bar x}{1 + \\cdots} = 0 → auxiliary constraints ∑ai(Xi−μx)/Di=0\\sum a_i (X_i - \\mu_x)/D_i = 0. QLS (8): ∑wi−W1+⋯=0\\sum \\dfrac{w_i - W}{1 + \\cdots} = 0 → WW-equation ∑ai(wi−W)/Di=0\\sum a_i (w_i - W)/D_i = 0. QLS (10): λ̂2=(N/n−1)/(1−W)\\hat{\\lambda}_2 = (N/n - 1)/(1 - W) → λW=((Npop/nresp_weighted)−1)/(1−W)\\lambda_W = ((N_{\\text{pop}}/n_{\\text{resp\\_weighted}}) - 1)/(1 - W) (design-weighted generalization). Estimator Ŷ\\hat Y QLS → ratio Ŷ=∑piELYi/∑piEL\\hat Y = \\sum p_i^{\\mathrm{EL}} Y_i/\\sum p_i^{\\mathrm{EL}} using piEL∝ai/Dip_i^{\\mathrm{EL}} \\propto a_i/D_i. Note predictors: response model predictors ZZ (missingness mechanism) auxiliary predictors XX (moment constraints) need coincide. may include response-predictors part auxiliary set; variables XX require known population moments μx\\mu_x.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/articles/el_empirical_likelihood_theory.html","id":"semiparametric-likelihood-qls-eq--2","dir":"Articles","previous_headings":"","what":"Semiparametric Likelihood (QLS Eq. 2)","title":"Empirical Likelihood Theory","text":"paper’s semiparametric likelihood (Eq. (2)) combines response mechanism wi=g(ηi)w_i = g(\\eta_i) nonparametric distribution FF (Y,X)(Y,X): L(β,W,F)=∏=1n[w(yi,xi;β)dF(yi,xi)]Wn(1−W)N−n, L(\\beta, W, F) \\;=\\; \\prod_{=1}^{n} \\Big[\\, w( y_i, x_i; \\beta )\\, dF(y_i, x_i)\\,\\Big]\\; W^{n} (1-W)^{N-n}, nn number respondents (Ri=1R_i=1), NN population size, W=∬w(y,x;β)dF(y,x) W \\;=\\; \\iint w(y,x;\\beta)\\, dF(y,x) unconditional response rate model. first product contribution fully observed respondents; binomial factor Wn(1−W)N−nW^n(1-W)^{N-n} likelihood response indicators, marginalizing (Y,X)(Y,X) via FF. parametric form assumed FF. make inference without fully parameterizing FF, QLS discretize FF observed points treat masses unknown parameters, estimated subject moment constraints. yields empirical-likelihood solution. Remark conditioning: QLS’s Eq. (2) writes first product ∏[w(yi,xi;β)dF(yi,xi)/W]\\prod_i [\\, w(y_i,x_i;\\beta)\\,dF(y_i,x_i)/W\\,] explicitly represents likelihood (Yi,Xi)(Y_i,X_i) conditional Ri=1R_i=1. Multiplying binomial term Wn(1−W)N−nW^n(1-W)^{N-n} yields overall likelihood W−nW^{-n} first factor cancels WnW^n second. factorizations lead estimating equations profiled log‑likelihood form used subsequently QLS introducing multipliers.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/articles/el_empirical_likelihood_theory.html","id":"lagrange-multipliers-and-el-weights","dir":"Articles","previous_headings":"","what":"Lagrange Multipliers and EL Weights","title":"Empirical Likelihood Theory","text":"Let pip_i jump FF (yi,xi)(y_i,x_i) =1,…,ni=1,\\dots,n (respondents). known auxiliary mean μx\\mu_x (vector), maximize likelihood subject constraints ∑=1npi=1,∑=1npi(Xi−μx)=0,∑=1npi(wi−W)=0. \\sum_{=1}^n p_i = 1,\\quad \\sum_{=1}^n p_i\\,(X_i - \\mu_x) = 0,\\quad \\sum_{=1}^n p_i\\,(w_i - W) = 0. Introducing Lagrange multipliers (λ0,λx,λW)(\\lambda_0,\\lambda_x,\\lambda_W) constraints profiling pip_i’s gives KKT stationarity conditions ∂∂pi[logpi+λ0(∑jpj−1)+λxT∑jpj(Xj−μx)+λW∑jpj(wj−W)]=0, \\frac{\\partial}{\\partial p_i} \\Big[\\, \\log p_i + \\lambda_0 \\big(\\sum_j p_j - 1\\big) + \\lambda_x^T \\sum_j p_j (X_j-\\mu_x) + \\lambda_W \\sum_j p_j (w_j-W) \\,\\Big] = 0, solve pi∝11+λxT(Xi−μx)+λW(wi−W)≡1Di. p_i \\,\\propto\\, \\frac{1}{\\,1 + \\lambda_x^T (X_i-\\mu_x) + \\lambda_W (w_i - W)\\,} \\;\\equiv\\; \\frac{1}{D_i}. Normalizing enforce ∑pi=1\\sum p_i = 1 yields pi=Di−1∑jDj−1p_i = \\frac{D_i^{-1}}{\\sum_j D_j^{-1}}. presence base sampling weights aia_i (survey designs), derivation gives natural generalization piEL∝aiDiwithDi=1+λW(wi−W)+(Xi−μx)Tλx. p_i^{\\text{EL}} \\;\\propto\\; \\frac{a_i}{D_i} \\quad \\text{} \\quad D_i = 1 + \\lambda_W (w_i - W) + (X_i - \\mu_x)^T\\lambda_x. exactly working form used estimator. EL weights piELp_i^{\\text{EL}} used build mean estimator Ŷ=∑ipiELYi∑ipiEL. \\hat Y \\;=\\; \\frac{\\sum_i p_i^{\\text{EL}} Y_i}{\\sum_i p_i^{\\text{EL}}}. remaining unknowns (β,W,λx)(\\beta, W, \\lambda_x) determined estimating equations .","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/articles/el_empirical_likelihood_theory.html","id":"clarification-relationship-between-w-and-lambda_w","dir":"Articles","previous_headings":"Lagrange Multipliers and EL Weights","what":"Clarification: Relationship Between WW and λW\\lambda_W","title":"Empirical Likelihood Theory","text":"reparameterization, EL multiplier probability constraint expressed : λW=C1−W,C=Npopnresp_weighted−1 W=plogis(z)\\lambda_W = \\frac{C}{1 - W}, \\quad \\text{} C = \\frac{N_{\\text{pop}}}{n_{\\text{resp\\_weighted}}} - 1 \\text{ } W = \\text{plogis}(z) Intuition: EL KKT system, constraint ∑piEL(wi−W)=0\\sum p_i^{\\text{EL}} (w_i - W) = 0 sits alongside normalization (optionally) auxiliary constraints. Incorporating base weights aia_i ratio population respondent totals induces scaling multiplier linked mass constraint. Writing λW\\lambda_W scaled form keeps parameter numerically stable scale lets derivative structure (w.r.t. zz via WW) handled cleanly. consistent EL structure baseline mass nresp_weightedn_{\\text{resp\\_weighted}} “full population” target NpopN_{\\text{pop}}, exactly code uses match normalization implied base weights. Derivation sketch (KKT): discretized semiparametric likelihood (QLS, 2002) maximizes, unknown masses {pi}\\{p_i\\} observed points (β,W)(\\beta, W), ℓ(β,W,λx,λW)=∑=1nlogwi(β)+(Npop−nresp_weighted)log(1−W)−∑=1nlog(1+(Xi−μx)⊤λx+λW(wi−W)), \\ell(\\beta, W, \\lambda_x, \\lambda_W)  \\;=\\; \\sum_{=1}^{n} \\log w_i(\\beta) \\; +\\; (N_{\\text{pop}} - n_{\\text{resp\\_weighted}}) \\log(1 - W) \\; -\\; \\sum_{=1}^{n} \\log\\!\\Big(1 + (X_i - \\mu_x)^\\top \\lambda_x + \\lambda_W (w_i - W)\\Big), subject normalization moment constraints generate EL denominator. weighted-EL variant work unnormalized respondent weights proportional ai/Dia_i/D_i; choosing conventional normalization ∑=1naiDi=nresp_weighted≡∑=1nai \\sum_{=1}^{n} \\frac{a_i}{D_i} \\,=\\, n_{\\text{resp\\_weighted}} \\equiv \\sum_{=1}^{n} a_i recovers estimating system (common normalization cancels ratio estimator Ŷ=∑piYi/∑pi\\hat Y = \\sum p_i Y_i/\\sum p_i). Taking derivatives (KKT conditions) using ∂/∂W\\partial/\\partial W second third terms produces opposing contributions, one obtains system equivalent QLS (7)–(10). particular, first-order condition w.r.t. multiplier associated WW-constraint yields, together derivative w.r.t. WW, closed form λW=Npopnresp_weighted−11−W=C1−W, \\lambda_W  \\;=\\; \\frac{\\tfrac{N_{\\text{pop}}}{n_{\\text{resp\\_weighted}}} - 1}{1 - W} \\;=\\; \\frac{C}{1 - W}, generalizes QLS (10) design-weighted case (nresp_weighted=∑iain_{\\text{resp\\_weighted}} = \\sum_i a_i Npop=∑allaiN_{\\text{pop}} = \\sum_{\\text{}} a_i). quick derivation sketch mirrors QLS (7)–(10): W-FOC yields ∑iai(wi−W)/Di=0\\sum_i a_i (w_i - W) / D_i = 0; combining implicit normalization ∑iai/Di=nresp_weighted\\sum_i a_i / D_i = n_{\\text{resp\\_weighted}} binomial part WW gives λW(1−W)nresp_weighted=Npop−nresp_weighted\\lambda_W (1-W)\\, n_{\\text{resp\\_weighted}} = N_{\\text{pop}} - n_{\\text{resp\\_weighted}}, hence λW=(Npop/nresp_weighted−1)/(1−W)\\lambda_W = (N_{\\text{pop}}/n_{\\text{resp\\_weighted}} - 1)/(1-W). expression implemented estimator used throughout Jacobian variance calculations.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/articles/el_empirical_likelihood_theory.html","id":"estimating-equations","dir":"Articles","previous_headings":"","what":"Estimating Equations","title":"Empirical Likelihood Theory","text":"Unknown parameters: β∈ℝK\\beta \\\\mathbb{R}^K, z∈ℝz \\\\mathbb{R} (W=plogis(z)W = \\text{plogis}(z)), λx∈ℝL\\lambda_x \\\\mathbb{R}^L; define θ=(β,z,λx)\\theta = (\\beta, z, \\lambda_x). Define wi=linkinv(ηi)w_i = \\mathrm{linkinv}(\\eta_i) μη,=dwdη(ηi)\\mu_{\\eta,} = \\frac{dw}{d\\eta}(\\eta_i) (denoted mu.eta(eta_i) code). Define C=Npopnresp_weighted−1C = \\frac{N_{\\text{pop}}}{n_{\\text{resp\\_weighted}}} - 1, nresp_weighted=∑ain_{\\text{resp\\_weighted}} = \\sum a_i NpopN_{\\text{pop}} known (sum design weights survey; nn IID). λW=C1−W\\lambda_W = \\frac{C}{1 - W}. Denominator: Di=1+λW(wi−W)+(Xi−μx)TλxD_i = 1 + \\lambda_W (w_i - W) + (X_i - \\mu_x)^T \\lambda_x, Di≥ϵD_i \\geq \\epsilon enforced numerically. Define score term si=μη,/wis_i = \\mu_{\\eta,}/w_i (unit‑level contribution log‑likelihood score respect η\\eta). logit, si=1−wis_i = 1 - w_i; probit, si=ϕ(ηi)/Φ(ηi)s_i = \\phi(\\eta_i)/\\Phi(\\eta_i) (computed stably code). Intuition (score appears): respondent observe Ri=1R_i=1, Bernoulli log‑likelihood contribution response model logwi(ηi)\\log w_i(\\eta_i). Differentiating w.r.t. linear predictor gives ∂∂ηilogwi(ηi)=1widwidηi=μη,iwi≡si. \\frac{\\partial}{\\partial\\eta_i} \\log w_i(\\eta_i) \\,=\\, \\frac{1}{w_i}\\, \\frac{dw_i}{d\\eta_i} \\,=\\, \\frac{\\mu_{\\eta,}}{w_i} \\;\\equiv\\; s_i.  Thus sis_i measures local sensitivity observed‑response likelihood ηi\\eta_i. logit family, μη,=wi(1−wi)\\mu_{\\eta,}=w_i(1-w_i) si=1−wis_i=1-w_i—familiar residual‑like term; probit family, si=ϕ(ηi)/Φ(ηi)s_i=\\phi(\\eta_i)/\\Phi(\\eta_i), (inverse) Mills ratio. EL β\\beta‑equations balance likelihood score EL penalty term λWμη,/Di\\lambda_W\\,\\mu_{\\eta,}/D_i, enforcing calibration constraints fitting response model.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/articles/el_empirical_likelihood_theory.html","id":"the-system-of-estimating-equations-ftheta-0","dir":"Articles","previous_headings":"Estimating Equations","what":"The System of Estimating Equations F(θ)=0F(\\theta) = 0","title":"Empirical Likelihood Theory","text":"β\\beta-equations (KK equations): ∑aiZi[si−λWμη,/Di]=0\\sum a_i Z_i [s_i - \\lambda_W \\mu_{\\eta,} / D_i] = 0 W-equation (1 equation): ∑ai(wi−W)/Di=0\\sum a_i (w_i - W) / D_i = 0 Auxiliary constraints (LL equations): ∑ai(Xi−μx)/Di=0\\sum a_i (X_i - \\mu_x) / D_i = 0 exactly build_equation_system constructs function code (src/engines/el/impl/el_equations.R). Intuition: β\\beta-equations equate score respondent log-likelihood EL penalty term λWμη,/Di\\lambda_W \\mu_{\\eta,}/D_i; WW-equation centers modeled response probabilities around unconditional mean WW EL weights; auxiliary equations calibrate centered auxiliaries zero mean EL weights.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/articles/el_empirical_likelihood_theory.html","id":"remarks","dir":"Articles","previous_headings":"Estimating Equations","what":"Remarks","title":"Empirical Likelihood Theory","text":"logit probit, sis_i log‑likelihood score ∂logwi/∂ηi=μη,/wi\\partial\\log w_i/\\partial\\eta_i = \\mu_{\\eta,}/w_i (equals 1−wi1-w_i logit; ϕ/Φ\\phi/\\Phi probit). follows paper’s MLE derivation; EL constraints supply nonparametric part.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/articles/el_empirical_likelihood_theory.html","id":"analytical-jacobian-a-matrix","dir":"Articles","previous_headings":"","what":"Analytical Jacobian (AA Matrix)","title":"Empirical Likelihood Theory","text":"differentiate F(θ)=0F(\\theta) = 0 respect θ=(β,z,λx)\\theta = (\\beta, z, \\lambda_x). Let: ηi=Ziβ\\eta_i = Z_i \\beta, wi=linkinv(ηi)w_i = \\text{linkinv}(\\eta_i), μη,=dwdη(ηi)\\mu_{\\eta,} = \\dfrac{dw}{d\\eta}(\\eta_i), μ″=d2wdη2(ηi)\\mu''_i = \\dfrac{d^2 w}{d\\eta^2}(\\eta_i) W=plogis(z)W = \\text{plogis}(z), dWdz=W(1−W)\\frac{dW}{dz} = W(1 - W) λW=C1−W\\lambda_W = \\frac{C}{1 - W}, dλWdW=C(1−W)2\\frac{d\\lambda_W}{dW} = \\frac{C}{(1 - W)^2} dλWdz=dλWdW⋅dWdz\\frac{d\\lambda_W}{dz} = \\frac{d\\lambda_W}{dW} \\cdot \\frac{dW}{dz} Xcentered,=Xi−μxX_{\\text{centered},} = X_i - \\mu_x","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/articles/el_empirical_likelihood_theory.html","id":"intermediate-derivatives","dir":"Articles","previous_headings":"Analytical Jacobian (AA Matrix)","what":"Intermediate Derivatives","title":"Empirical Likelihood Theory","text":"si=μη,/wi⇒dsidηi=(μ′η,iwi−μη,i2)/wi2s_i = \\mu_{\\eta,}/w_i \\Rightarrow \\;\\frac{ds_i}{d\\eta_i} = (\\mu'_{\\eta,}w_i - \\mu_{\\eta,}^2)/w_i^2 μ′η,=dμη,idηi=d2wdηi2≡μ″\\mu'_{\\eta,} = \\dfrac{d\\mu_{\\eta,}}{d\\eta_i} = \\dfrac{d^2 w}{d\\eta_i^2} \\equiv \\mu''_i (d2mu.deta2(eta_i) code) ∂Di∂ηi=λWμη,\\frac{\\partial D_i}{\\partial \\eta_i} = \\lambda_W \\mu_{\\eta,} ∂Di∂z=∂λW∂z⋅(wi−W)−λW⋅dWdz\\frac{\\partial D_i}{\\partial z} = \\frac{\\partial \\lambda_W}{\\partial z} \\cdot (w_i - W) - \\lambda_W \\cdot \\frac{dW}{dz} ∂Di∂λx=Xcentered,\\frac{\\partial D_i}{\\partial \\lambda_x} = X_{\\text{centered},} Define invi=1/Di\\text{inv}_i = 1 / D_i scalar term driving β\\beta‑equations: Ti=si−λWμη,iinvi,si=μη,iwi.T_i = s_i - \\lambda_W \\mu_{\\eta,} \\text{inv}_i,\\quad s_i = \\frac{\\mu_{\\eta,}}{w_i}.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/articles/el_empirical_likelihood_theory.html","id":"compute-its-derivatives","dir":"Articles","previous_headings":"Analytical Jacobian (AA Matrix)","what":"Compute Its Derivatives","title":"Empirical Likelihood Theory","text":"Using μ′η,=dμη,/dηi=d2mudeta2(ηi)\\,\\mu'_{\\eta,} = d\\mu_{\\eta,}/d\\eta_i = \\mathrm{d2mu\\,deta2}(\\eta_i) dwi/dηi=μη,\\,dw_i/d\\eta_i = \\mu_{\\eta,}, ∂si∂ηi=μ′η,iwi−μη,i2wi2.\\frac{\\partial s_i}{\\partial \\eta_i} = \\frac{\\mu'_{\\eta,} w_i - \\mu_{\\eta,}^2}{w_i^2}. Also ∂invi∂ηi=−invi2⋅∂Di∂ηi=−invi2(λWμη,)\\,\\frac{\\partial \\text{inv}_i}{\\partial \\eta_i} = -\\text{inv}_i^2 \\cdot \\frac{\\partial D_i}{\\partial \\eta_i} = -\\text{inv}_i^2 (\\lambda_W \\mu_{\\eta,}). Therefore ∂Ti∂ηi=μ′η,iwi−μη,i2wi2−λWμ′η,iinvi+λW2(μη,)2invi2.\\frac{\\partial T_i}{\\partial \\eta_i} = \\frac{\\mu'_{\\eta,} w_i - \\mu_{\\eta,}^2}{w_i^2} - \\lambda_W \\mu'_{\\eta,} \\text{inv}_i + \\lambda_W^2 (\\mu_{\\eta,})^2 \\text{inv}_i^2. ∂Ti∂z=−∂λW∂z⋅μη,iinvi+λWμη,iinvi2⋅∂Di∂z\\frac{\\partial T_i}{\\partial z} = -\\frac{\\partial \\lambda_W}{\\partial z} \\cdot \\mu_{\\eta,} \\text{inv}_i + \\lambda_W \\mu_{\\eta,} \\text{inv}_i^2 \\cdot \\frac{\\partial D_i}{\\partial z} ∂Ti∂λx=λWμη,iinvi2⋅Xcentered,\\frac{\\partial T_i}{\\partial \\lambda_x} = \\lambda_W \\mu_{\\eta,} \\text{inv}_i^2 \\cdot X_{\\text{centered},}","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/articles/el_empirical_likelihood_theory.html","id":"assemble-jacobian-blocks-with-a_i-weights","dir":"Articles","previous_headings":"Analytical Jacobian (AA Matrix)","what":"Assemble Jacobian Blocks (with aia_i weights)","title":"Empirical Likelihood Theory","text":"JββJ_{\\beta\\beta} (K×KK \\times K): J11=∑aiZiT[∂Ti∂ηi]ZiJ_{11} = \\sum a_i Z_i^T \\left[ \\frac{\\partial T_i}{\\partial \\eta_i} \\right] Z_i JβzJ_{\\beta z} (K×1K \\times 1): J12=∑aiZiT[∂Ti∂z]J_{12} = \\sum a_i Z_i^T \\left[ \\frac{\\partial T_i}{\\partial z} \\right] JβλJ_{\\beta \\lambda} (K×LK \\times L): J13=∑aiZiT[∂Ti∂λx]J_{13} = \\sum a_i Z_i^T \\left[ \\frac{\\partial T_i}{\\partial \\lambda_x} \\right] JzβJ_{z\\beta} (1×K1 \\times K): derivative W-equation w.r.t. β\\beta Equation: GW=∑ai(wi−W)inviG_W = \\sum a_i (w_i - W) \\text{inv}_i ∂GW∂ηi=ai[μη,iinvi−(wi−W)invi2(∂Di∂ηi)]=ai[μη,iinvi−(wi−W)invi2(λWμη,)]\\frac{\\partial G_W}{\\partial \\eta_i} = a_i \\left[ \\mu_{\\eta,} \\text{inv}_i - (w_i - W) \\text{inv}_i^2 \\left(\\frac{\\partial D_i}{\\partial \\eta_i}\\right) \\right] = a_i \\left[ \\mu_{\\eta,} \\text{inv}_i - (w_i - W) \\text{inv}_i^2 (\\lambda_W \\mu_{\\eta,}) \\right] : J21=∑∂GW∂ηi⋅ZiJ_{21} = \\sum \\frac{\\partial G_W}{\\partial \\eta_i} \\cdot Z_i JzzJ_{zz} (1×11 \\times 1): ∂GW∂z=∑ai[−dWdz⋅invi−(wi−W)invi2⋅∂Di∂z]\\frac{\\partial G_W}{\\partial z} = \\sum a_i \\left[ -\\frac{dW}{dz} \\cdot \\text{inv}_i - (w_i - W) \\text{inv}_i^2 \\cdot \\frac{\\partial D_i}{\\partial z} \\right] JzλJ_{z\\lambda} (1×L1 \\times L): ∂GW∂λx=∑ai[−(wi−W)invi2Xcentered,]\\frac{\\partial G_W}{\\partial \\lambda_x} = \\sum a_i \\left[ -(w_i - W) \\text{inv}_i^2 X_{\\text{centered},} \\right] JλβJ_{\\lambda\\beta} (L×KL \\times K): constraints H(λ):∑aiinviXcentered,=0H(\\lambda): \\sum a_i \\text{inv}_i X_{\\text{centered},} = 0 ∂H∂ηi=−aiinvi2∂Di∂ηiXcentered,=−aiinvi2(λWμη,)Xcentered,\\frac{\\partial H}{\\partial \\eta_i} = -a_i \\text{inv}_i^2 \\frac{\\partial D_i}{\\partial \\eta_i} X_{\\text{centered},} = -a_i \\text{inv}_i^2 (\\lambda_W \\mu_{\\eta,}) X_{\\text{centered},} , component‑wise J31=∑iai(−λWμη,iinvi2)Xcentered,iTZiJ_{31} = \\sum_i a_i\\,(-\\lambda_W \\mu_{\\eta,}\\,\\text{inv}_i^2)\\, X_{\\text{centered},}^T Z_i. compact matrix form: J31=XcenteredTdiag(ai(−λWμη,iinvi2))Z, J_{31} \\;=\\; X_{\\text{centered}}^T \\, \\operatorname{diag}\\big( a_i\\,(-\\lambda_W \\mu_{\\eta,}\\,\\text{inv}_i^2) \\big) \\, Z, matches implementation crossprod(X_centered, Z * .numeric(respondent_weights * term31)) term31 = -dden_deta * inv_denom^2 dden_deta = \\lambda_W\\,\\mu_{\\eta}. JλzJ_{\\lambda z} (L×1L \\times 1): ∂H∂z=−∑aiinvi2∂Di∂zXcentered,\\frac{\\partial H}{\\partial z} = -\\sum a_i \\text{inv}_i^2 \\frac{\\partial D_i}{\\partial z} X_{\\text{centered},} JλλJ_{\\lambda\\lambda} (L×LL \\times L): ∂H∂λx=−∑aiinvi2Xcentered,iXcentered,\\frac{\\partial H}{\\partial \\lambda_x} = -\\sum a_i \\text{inv}_i^2 X_{\\text{centered},} X_{\\text{centered},}^T exactly build_el_jacobian computes (src/engines/el/impl/el_jacobian.R). =∂F∂θA = \\frac{\\partial F}{\\partial \\theta}, analytic Jacobian logit probit.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/articles/el_empirical_likelihood_theory.html","id":"why-a-matters-solver-and-variance","dir":"Articles","previous_headings":"Analytical Jacobian (AA Matrix)","what":"Why AA matters (solver and variance)","title":"Empirical Likelihood Theory","text":"Newton–Raphson (used nleqslv) linearizes F(θ)F(\\theta) near current iterate: F(θ+Δ)≈F(θ)+(θ)ΔF(\\theta + \\Delta) \\approx F(\\theta) + (\\theta)\\,\\Delta. update Δ\\Delta solves AΔ=−FA\\,\\Delta = -F, hence high‑quality AA critical fast, stable convergence. variance, delta method uses AA: asymptotic covariance θ̂\\hat\\theta −1BA−TA^{-1} B ^{-T}, inaccuracies AA propagate standard errors. provide analytic numeric AA “auto” policy prefers analytic unless diagnostics indicate poor agreement conditioning.","code":""},{"path":[]},{"path":"https://ncn-foreigners.github.io/NMAR/articles/el_empirical_likelihood_theory.html","id":"sandwich-variance-for-theta-analytical-covariance","dir":"Articles","previous_headings":"Variance Estimation","what":"Sandwich Variance for θ\\theta (Analytical Covariance)","title":"Empirical Likelihood Theory","text":"Uβ,=aiZiT[si−λWμη,/Di]U_{\\beta,} = a_i\\, Z_i^T\\,[\\, s_i - \\lambda_W \\mu_{\\eta,}/D_i\\,] (vector length KK) UW,=ai(wi−W)/DiU_{W,} = a_i\\, (w_i - W)/D_i (scalar) Uλ,=ai(Xi−μx)/DiU_{\\lambda,} = a_i\\, (X_i - \\mu_x)/D_i (vector length LL) Concatenating gives UiU_i length K+1+LK+1+L. =∂F/∂θA = \\partial F/\\partial\\theta (K+1+LK+1+L square) comes analytic Jacobian (numeric necessary). IID: Form N×(K+1+L)N\\times(K+1+L) matrix UiU_i respondent rows zeros nonrespondent rows, compute B̂=UTU\\widehat B = U^T U (empirical second moment totals). Survey: Treat column UU survey variable compute covariance totals using survey::svytotal(...); vcov(...). provides design‑based B̂\\widehat B complex designs. Asymptotic covariance: Var̂(θ̂)=−1B̂−T\\widehat{\\operatorname{Var}}(\\hat\\theta) = ^{-1}\\, \\widehat B\\, ^{-T}. AA BB totals (sum) scale, extra 1/N1/N factors introduced; matches survey path vcov(svytotal) returns covariances totals.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/articles/el_empirical_likelihood_theory.html","id":"delta-variance-for-haty","dir":"Articles","previous_headings":"Variance Estimation","what":"Delta Variance for Ŷ\\hat{Y}","title":"Empirical Likelihood Theory","text":"Estimator functional g(θ)=Ŷ(θ)g(\\theta) = \\hat{Y}(\\theta): recompute piEL(θ)p_i^{\\text{EL}}(\\theta) θ\\theta via Di(θ)D_i(\\theta), Ŷ=∑piELYi/∑piEL\\hat{Y} = \\sum p_i^{\\text{EL}} Y_i / \\sum p_i^{\\text{EL}}. trimming (cap=∞\\text{cap} = \\infty), use closed‑form analytic gradient ratio Ŷ(θ)\\hat Y(\\theta), ∂πi/∂θ\\partial \\pi_i/\\partial \\theta derived denominator guard Di≥εD_i \\ge \\varepsilon used estimating equations. yields smooth, numerically stable ∇g(θ)\\nabla g(\\theta). trimming active (non‑smooth map), use stabilized numeric gradient finite‑difference settings tuned problem. Variance: Var(Ŷ)≈∇gA−1B(−1)T∇gT\\mathrm{Var}(\\hat{Y}) \\approx \\nabla g \\, ^{-1} B (^{-1})^T \\nabla g^T using (totals‑scale) AA BB defined . Practical note stability: unconditional response rate WW low auxiliaries weak, λW\\lambda_W can large denominators DiD_i may approach zero, creating large EL weights heavy‑tailed sampling distribution Ŷ\\hat Y. regimes first‑order (delta) approximation may understate across‑sample variability. Prefer variance_method = \"bootstrap\" strengthen auxiliary constraints. trimming, estimator non‑smooth, bootstrap recommended inference. Implementation: el_compute_delta_variance() src_dev/engines/el/impl/variance.R assembles BB U_matrix_resp provided compute_score_variance_func (IID vs survey), computes ∇g\\nabla g (analytic smooth; stabilized numeric otherwise), returns Var(Ŷ)\\mathrm{Var}(\\hat{Y}) (scaled) sandwich vcov β\\beta.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/articles/el_empirical_likelihood_theory.html","id":"worked-example-analytic-nabla-g-in-a-1covariate-logit-case","dir":"Articles","previous_headings":"Variance Estimation","what":"Worked Example: Analytic ∇g\\nabla g in a 1‑Covariate Logit Case","title":"Empirical Likelihood Theory","text":"Consider simple, smooth setting trimming (cap =∞=\\infty), auxiliary constraints (L=0L=0), logit response model ηi=Ziβ=β0+β1xi,wi=logit−1(ηi),μη,=dwidηi=wi(1−wi). \\eta_i = Z_i\\,\\beta = \\beta_0 + \\beta_1 x_i,\\qquad w_i = \\operatorname{logit}^{-1}(\\eta_i),\\qquad \\mu_{\\eta,} = \\frac{dw_i}{d\\eta_i} = w_i (1-w_i).  Let C=Npop/nresp_weighted−1C = N_{\\text{pop}}/n_{\\text{resp\\_weighted}} - 1 W=logit−1(z)W = \\operatorname{logit}^{-1}(z), λW=C1−W,dWdz=W(1−W),dλWdz=CW(1−W)=λWW1−W. \\lambda_W = \\frac{C}{1-W},\\qquad \\frac{dW}{dz} = W(1-W),\\qquad \\frac{d\\lambda_W}{dz} = \\frac{C\\,W}{(1-W)} = \\lambda_W\\,\\frac{W}{1-W}.  auxiliaries, EL denominator weights respondents Di=1+λW(wi−W),πi=aiDi,B=∑iπi,Ŷ=g(θ)=∑iπiYiB, D_i = 1 + \\lambda_W (w_i - W),\\qquad \\pi_i = \\frac{a_i}{D_i},\\qquad B = \\sum_i \\pi_i,\\qquad \\hat Y = g(\\theta) = \\frac{\\sum_i \\pi_i Y_i}{B},  aia_i base weights (ai≡1a_i\\equiv 1 IID; design weights survey). analytic gradient gg follows ratio rule ∂πi/∂θ\\partial\\pi_i/\\partial\\theta. Gradient w.r.t. β\\beta. Since ∂Di/∂β=λWμη,iZi\\partial D_i/\\partial\\beta = \\lambda_W\\,\\mu_{\\eta,}\\,Z_i, ∂πi/∂β=−aiλWμη,iZi/Di2\\partial\\pi_i/\\partial\\beta = -\\,a_i\\,\\lambda_W\\,\\mu_{\\eta,}\\,Z_i/ D_i^2, therefore ∂g∂β=1B∑(Yi−Ŷ)∂πi∂β=−1B∑(Yi−Ŷ)aiλWμη,iDi2Zi. \\boxed{\\;\\frac{\\partial g}{\\partial \\beta} \\,=\\, \\frac{1}{B}\\sum_i (Y_i - \\hat Y)\\,\\frac{\\partial \\pi_i}{\\partial\\beta} \\;=\\; -\\,\\frac{1}{B}\\sum_i (Y_i - \\hat Y)\\,\\frac{a_i\\,\\lambda_W\\,\\mu_{\\eta,}}{D_i^2}\\,Z_i\\; }. Gradient w.r.t. reparametrized z=logit(W)z = \\operatorname{logit}(W). Using ∂Di/∂z=(dλW/dz)(wi−W)−λWdWdz\\partial D_i/\\partial z = (d\\lambda_W/dz)\\,(w_i - W) - \\lambda_W\\,\\frac{dW}{dz}, ∂g∂z=1B∑(Yi−Ŷ)∂πi∂z=−1B∑(Yi−Ŷ)aiDi2[dλWdz(wi−W)−λWdWdz]. \\boxed{\\;\\frac{\\partial g}{\\partial z} \\,=\\, \\frac{1}{B}\\sum_i (Y_i - \\hat Y)\\,\\frac{\\partial \\pi_i}{\\partial z} \\;=\\; -\\,\\frac{1}{B}\\sum_i (Y_i - \\hat Y)\\,\\frac{a_i}{D_i^2}\\,\\Big[\\,\\frac{d\\lambda_W}{dz}\\,(w_i - W) - \\lambda_W\\,\\frac{dW}{dz}\\,\\Big]\\; }. (Optional) auxiliaries XiX_i centered Xc,=Xi−μxX_{c,}=X_i-\\mu_x, Di=1+λW(wi−W)+Xc,⊤λxD_i = 1 + \\lambda_W(w_i - W) + X_{c,}^\\top\\lambda_x ∂Di/∂λx=Xc,\\partial D_i/\\partial\\lambda_x = X_{c,}, hence ∂g∂λx=−1B∑(Yi−Ŷ)aiDi2Xc,. \\boxed{\\;\\frac{\\partial g}{\\partial \\lambda_x} \\,=\\, -\\,\\frac{1}{B}\\sum_i (Y_i - \\hat Y)\\,\\frac{a_i}{D_i^2}\\,X_{c,}\\; }. Numerical safeguards. practice enforce Di≥εD_i \\ge \\varepsilon (e.g., ε=10−8\\varepsilon=10^{-8}) forming gradient score contributions used B̂\\widehat B. guard used estimating equations analytic Jacobian, ensuring consistency F(θ)F(\\theta), =∂F/∂θA=\\partial F/\\partial\\theta, ∇g(θ)\\nabla g(\\theta). Code mapping. implementation uses expressions trim_cap = Inf (smooth case) inside el_compute_delta_variance(); otherwise falls back stabilized numeric gradient. See src_dev/engines/el/impl/variance.R exact code paths src_dev/engines/el/impl/jacobian.R matching AA.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/articles/el_empirical_likelihood_theory.html","id":"solving-strategy-and-initialization","dir":"Articles","previous_headings":"Variance Estimation","what":"Solving Strategy and Initialization","title":"Empirical Likelihood Theory","text":"Newton analytic Jacobian available; Perturbation‑based re‑starts seed zz logit(observed response rate)\\mathrm{logit}(\\text{observed response rate}) align binomial part; Broyden fallback without Jacobian needed. reparameterization initialization improve stability strong NMAR settings. See src_dev/engines/el/impl/core.R.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/articles/el_empirical_likelihood_theory.html","id":"jacobian-inversion-policy-and-numerical-stability","dir":"Articles","previous_headings":"Variance Estimation","what":"Jacobian Inversion Policy and Numerical Stability","title":"Empirical Likelihood Theory","text":"Let =∂F∂θA = \\frac{\\partial F}{\\partial \\theta} Jacobian estimating system. delta variance uses −1A^{-1}. Numerically, follow principled, layered inversion policy implemented invert_jacobian() (src/shared/numerics.R): Condition number check: Compute condition number κ()\\kappa(). κ()≤κthr\\kappa() \\leq \\kappa_{\\text{thr}} (default 10810^8), attempt plain inverse via solve(). Ridge regularization: plain inversion fails κ()\\kappa() large variance_ridge requested: Apply ridge: invert +ϵIA + \\epsilon , ϵ\\epsilon either provided (numeric variance_ridge) chosen adaptively ϵ=base×σmax()\\epsilon = \\text{base} \\times \\sigma_{\\max}() (default base 10−810^{-8}). Pseudoinverse fallback: variance_pseudoinverse = TRUE, compute SVD-based pseudoinverse (MASS::ginv explicit SVD tolerance), use . Diagnostics: function returns inverse diagnostics: invert_rule ∈\\{“plain”,“ridge”,“pinv”}, used_ridge, used_pinv, kappa.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/articles/el_empirical_likelihood_theory.html","id":"remarks-1","dir":"Articles","previous_headings":"Variance Estimation","what":"Remarks","title":"Empirical Likelihood Theory","text":"minus sign −−1-^{-1} conventional; cancels sandwich ∇gA−1B(−1)T∇gT\\nabla g \\, ^{-1} B (^{-1})^T \\nabla g^T. Pseudoinverse ridge opt-, full diagnostics recorded. ill-conditioned regimes (weak identification, trimming, etc.), controlled stabilizers standard practice preferable failing silently. finite weight trimming, delta-variance approximate g(θ)g(\\theta) incorporates trimming; prefer variance_method = \"bootstrap\" case (implemented). Example: κ()≈1010\\kappa() \\approx 10^{10} variance_ridge = TRUE, inversion applies adaptive ridge ϵ≈10−8×σmax()\\epsilon \\approx 10^{-8} \\times \\sigma_{\\max}() inverts +ϵIA + \\epsilon . typically reduces ill-conditioning stabilizes Newton linear solve sandwich variance.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/articles/el_empirical_likelihood_theory.html","id":"practical-identifiability-and-diagnostics","dir":"Articles","previous_headings":"Variance Estimation","what":"Practical Identifiability and Diagnostics","title":"Empirical Likelihood Theory","text":"EL system balances parametric response-model score calibration constraints. Identifiability can weaken following situations: Weak nearly collinear auxiliaries: Xi−μxX_i-\\mu_x little variation nearly collinear response score direction, constraint block =∂F/∂θA=\\partial F/\\partial\\theta becomes ill‑conditioned. Inconsistent auxiliary means: supplied μx\\mu_x far respondent sample can support (response model), denominators DiD_i cluster near 0 κ()\\kappa() inflates. Heavy nonresponse near‑boundary WW: WW approaches 0 1, λW=C/(1−W)\\lambda_W=C/(1-W) can spike amplify sensitivity. Diagnostics exposed implementation help assess issues: jacobian_condition_number (κ()\\kappa()), jacobian_source (analytic vs numeric), jacobian_auto_rule (numeric chosen), max_equation_residual, trimming fraction. variance, whether ridge pseudoinverse used (used_ridge, used_pseudoinverse, invert_rule). Mitigations include standardizing predictors, trimming extreme weights (trim_cap), adding informative response‑model predictors, preferring bootstrap variance diagnostics indicate fragility.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/articles/el_empirical_likelihood_theory.html","id":"survey-design-details","dir":"Articles","previous_headings":"","what":"Survey Design Details","title":"Empirical Likelihood Theory","text":"extend QLS’s methodology complex surveys two complementary ways: Estimating equations base weights: sums already include base weight aia_i; set aia_i survey design weight respondents. Totals NpopN_{\\text{pop}} nresp_weighted=∑ain_{\\text{resp\\_weighted}}=\\sum a_i computed design weights, feeds λW=((Npop/nresp_weighted)−1)/(1−W)\\lambda_W = ((N_{\\text{pop}}/n_{\\text{resp\\_weighted}}) - 1)/(1-W). Design‑based variance totals: Rather assuming ..d. sampling, estimate B=Var(∑Ui)B = \\operatorname{Var}(\\sum U_i) using design: Create full‑design score variables placing respondent contributions UiU_i observed rows zeros nonrespondents. Compute survey totals svytotal(~U, design) take covariance via vcov(...) obtain B̂\\widehat B. short form, compute B̂=vcov(𝚜𝚟𝚢𝚝𝚘𝚝𝚊𝚕(∼U,𝚍𝚎𝚜𝚒𝚐𝚗)), \\widehat B \\;=\\; \\operatorname{vcov}\\!\\big(\\,\\texttt{svytotal}(\\,\\sim U,\\; \\texttt{design}\\,)\\,\\big), UU stacks respondent score contributions zeros elsewhere. matches paper’s guidance adapt likelihood/estimating framework stratification unequal‑probability sampling. approach keeps EL structure uses standard survey inference tools second‑order properties. Degrees‑‑freedom: confidence intervals, use survey degrees‑‑freedom (t‑quantiles) survey.design supplied; otherwise, use normal quantiles.","code":""},{"path":[]},{"path":"https://ncn-foreigners.github.io/NMAR/articles/el_empirical_likelihood_theory.html","id":"scaling-optional-standardizetrue","dir":"Articles","previous_headings":"Scaling and Unscaling","what":"Scaling (optional; standardize=TRUE)","title":"Empirical Likelihood Theory","text":"meanj\\text{mean}_j, sdj\\text{sd}_j; sdj≈0\\text{sd}_j \\approx 0, set sdj=1\\text{sd}_j = 1 avoid blow-ups. Zscaled[,j]=(Zun[,j]−meanj)/sdjZ_{\\text{scaled}}[,j] = (Z_{\\text{un}}[,j] - \\text{mean}_j) / \\text{sd}_j Xscaled[,j]=(Xun[,j]−meanj)/sdjX_{\\text{scaled}}[,j] = (X_{\\text{un}}[,j] - \\text{mean}_j) / \\text{sd}_j μx,scaled[j]=(μx,un[j]−meanj)/sdj\\mu_{x,\\text{scaled}}[j] = (\\mu_{x,\\text{un}}[j] - \\text{mean}_j) / \\text{sd}_j","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/articles/el_empirical_likelihood_theory.html","id":"unscaling-beta-and-vcov","dir":"Articles","previous_headings":"Scaling and Unscaling","what":"Unscaling β\\beta and vcov","title":"Empirical Likelihood Theory","text":"columns j≠j \\neq intercept: D[j,j]=1/sdjD[j,j] = 1/\\text{sd}_j intercept: adjust absorb centering: D[intercept,j]=−meanj/sdjD[\\text{intercept},j] = -\\text{mean}_j/\\text{sd}_j Transform: βunscaled=Dβscaled\\beta_{\\text{unscaled}} = D \\beta_{\\text{scaled}}; vcovunscaled=DvcovscaledDT\\text{vcov}_{\\text{unscaled}} = D \\, \\text{vcov}_{\\text{scaled}} \\, D^T Code: centralized src/shared/scaling.R; engines call validate_and_apply_nmar_scaling() unscale_coefficients().","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/articles/el_empirical_likelihood_theory.html","id":"bootstrap-variance","dir":"Articles","previous_headings":"","what":"Bootstrap Variance","title":"Empirical Likelihood Theory","text":"Resample rows replacement (nn nn), re-run estimator, compute var\\text{var} bootstrap Ŷ\\hat{Y}s; warn many failures; return var\\sqrt{\\text{var}}. Convert bootstrap replicate-weight design via svrep::as_bootstrap_design. replicate, re-construct temporary design run estimator; use survey::svrVar compute variance replicate estimates (scale/rscales). Code: src/shared/bootstrap.R S3 methods data.frame survey.design.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/articles/el_empirical_likelihood_theory.html","id":"families-logit-and-probit","dir":"Articles","previous_headings":"","what":"Families: Logit and Probit","title":"Empirical Likelihood Theory","text":"families implement: linkinv(eta), mu.eta(eta), d2mu.deta2(eta), score_eta(eta, delta).","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/articles/el_empirical_likelihood_theory.html","id":"logit","dir":"Articles","previous_headings":"Families: Logit and Probit","what":"Logit","title":"Empirical Likelihood Theory","text":"linkinv(eta) = stats::plogis(eta) mu.eta(eta) = p(1 - p) d2mu.deta2(eta) = p(1 - p)(1 - 2p) score_eta(eta, delta) = mu.eta(eta)/p(eta) = 1 - p(eta)","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/articles/el_empirical_likelihood_theory.html","id":"probit","dir":"Articles","previous_headings":"Families: Logit and Probit","what":"Probit","title":"Empirical Likelihood Theory","text":"linkinv(eta) = stats::pnorm(eta) mu.eta(eta) = stats::dnorm(eta) d2mu.deta2(eta) = -eta * stats::dnorm(eta) score_eta(eta, delta) = mu.eta(eta)/p(eta) = phi(eta)/Phi(eta) (computed via stable log‑ratio) definitions match semiparametric MLE equations Qin–Leung–Shao (2002), analytic Jacobian formulas valid links.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/articles/el_empirical_likelihood_theory.html","id":"score-functions-iid-vs-survey","dir":"Articles","previous_headings":"Families: Logit and Probit","what":"Score functions: IID vs Survey","title":"Empirical Likelihood Theory","text":"per‑unit score contributions UiU_i analytic form IID survey designs; difference presence base weights aia_i multiplying contribution, way estimate covariance totals BB. IID case: ai=1a_i = 1, B̂\\widehat B empirical crossproduct per‑unit scores (zeros nonrespondents). Survey case: aia_i equals design weight; B̂\\widehat B obtained svytotal/vcov clustering, stratification, unequal probabilities reflected covariance score totals. Remark calibration complex designs: analytic delta variance derived first‑order expansion score‑total map. strong weighting complex designs, linearization can ‑estimate variability even though form B̂\\widehat B correct. cases, prefer bootstrap variance via replicate weights (svrep) reliable calibration.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/articles/el_empirical_likelihood_theory.html","id":"trimming-and-delta-approximation","dir":"Articles","previous_headings":"Families: Logit and Probit","what":"Trimming and Delta Approximation","title":"Empirical Likelihood Theory","text":"finite trimming cap used (non‑smooth map θ\\theta), delta method approximate g(θ)g(\\theta) includes thresholding. implementation therefore: Uses closed‑form analytic ∇g\\nabla g smooth, untrimmed case (cap=∞\\text{cap}=\\infty). Falls back stabilized numeric gradient trimming active. practice, trimmed fits ill‑conditioned Jacobians, prefer variance_method = \"bootstrap\" reliable uncertainty quantification.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/articles/el_empirical_likelihood_theory.html","id":"choosing-analytic-vs-numeric-jacobian-auto","dir":"Articles","previous_headings":"Families: Logit and Probit","what":"Choosing Analytic vs Numeric Jacobian (“auto”)","title":"Empirical Likelihood Theory","text":"analytic numeric versions AA available, default selection “auto”: Prefer analytic AA available, unless quality gates suggest otherwise. Override numeric relative Frobenius difference analytic numeric exceeds small threshold (default 10−310^{-3}), condition number analytic AA much worse (κanalytic>10×κnumeric\\kappa_{\\text{analytic}} > 10 \\times \\kappa_{\\text{numeric}}). Record diagnostics source used (jacobian_source) (jacobian_auto_rule ∈\\{“default”,“rel_diff_high”,“kappa_ratio_high”}). balances accuracy/speed (analytic) numerical robustness (numeric) follows best practices nonlinear estimating systems.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/articles/el_empirical_likelihood_theory.html","id":"end-to-end-mapping-to-code","dir":"Articles","previous_headings":"","what":"End-to-End Mapping to Code","title":"Empirical Likelihood Theory","text":"Validated validate_nmar_engine_el(). Family objects: logit_family(), probit_family() src_dev/shared/families.R. Dispatch: run_engine.nmar_engine_el(...) src_dev/engines/el/run_engine.R adapts formula forwards arguments internal el() methods. el.data.frame() / el.survey.design() src_dev/engines/el/impl/dataframe.R src_dev/engines/el/impl/survey.R prepare inputs, call el_estimator_core(), wrap results. Scaling via validate_and_apply_nmar_scaling() Build equations via el_build_equation_system(family, ...) Solve nleqslv (multi-start fallback Broyden needed) Compute EL weights, Y_hat, diagnostics, constraints Variance (delta bootstrap), via build_el_jacobian(family, ...) B via compute_score_variance_func (IID vs survey), analytic/numeric ∇g inside el_compute_delta_variance() depending trimming Unscale coefficients vcov needed Jacobian: build_el_jacobian(...) src_dev/engines/el/impl/jacobian.R returns analytic whenever family supplies d2mu.deta2 (logit, probit). Variance: src_dev/engines/el/impl/variance.R assembles B computes delta variance; bootstrap variance src_dev/shared/bootstrap.R. Scaling: src_dev/shared/scaling.R (class ‘nmar_scaling_recipe’, constructor, validator, create/apply/prepare, unscale). Parent nmar_result S3 methods src_dev/S3/nmar_result_methods.R (estimate, vcov, confint, tidy, glance, plot, autoplot). EL-specific S3 methods src_dev/engines/el/s3.R (print/summary nmar_result_el).","code":""},{"path":[]},{"path":"https://ncn-foreigners.github.io/NMAR/articles/el_empirical_likelihood_theory.html","id":"worked-example-logit-one-auxiliary-mean","dir":"Articles","previous_headings":"","what":"Worked Example: Logit + One Auxiliary Mean","title":"Empirical Likelihood Theory","text":"Consider simple NMAR setup single auxiliary X whose population mean known. Data: outcome Y_miss (NA nonrespondents), auxiliary X. Response model (logit): wi=plogis(β0+β1Yi)w_i = \\mathrm{plogis}(\\beta_0 + \\beta_1\\,Y_i) respondents (Ri=1R_i=1). Auxiliary mean: μx\\mu_x known (e.g., mean(X) external source). Step 1 — Build design matrices moments Zi=[1,Yi]Z_i = [1,\\;Y_i] model.matrix(~ Y_miss, data=respondents). XiX_i model.matrix(~ X - 1, data=respondents); μx\\,\\mu_x scalar. Optionally standardize ZZ XX transform μx\\mu_x accordingly (recommend standardize=TRUE). Step 2 — Define EL denominator weights Di=1+λW(wi−W)+(Xi−μx)TλxD_i = 1 + \\lambda_W (w_i - W) + (X_i - \\mu_x)^T \\, \\lambda_x. Respondent EL weights proportional 1/Di1/D_i (times base weights aia_i, 1). mean estimator Ŷ=∑piELYi/∑piEL\\hat{Y} = \\sum p_i^{\\mathrm{EL}} Y_i / \\sum p_i^{\\mathrm{EL}}. Step 3 — Estimating equations Score term (logit): si=μη,/wi=1−wis_i = \\mu_{\\eta,}/w_i = 1 - w_i μη,=wi(1−wi)\\mu_{\\eta,} = w_i(1-w_i). Beta equations (2 unknowns): ∑Zi[si−λWμη,/Di]=0\\sum Z_i\\,[s_i - \\lambda_W\\,\\mu_{\\eta,}/D_i] = 0. W equation: ∑(wi−W)/Di=0\\sum (w_i - W)/D_i = 0. Auxiliary: ∑(Xi−μx)/Di=0\\sum (X_i - \\mu_x)/D_i = 0. λW\\lambda_W determined C=(Npop/nresp_weighted)−1C = (N_{\\text{pop}}/n_{\\text{resp\\_weighted}}) - 1 via λW=C/(1−W)\\lambda_W = C/(1 - W) (IID data, nresp_weighted=nn_{\\text{resp\\_weighted}} = n). Step 4 — Solve compute Ŷ\\hat{Y} Unknowns: (β0,β1,z,λx)(\\beta_0, \\beta_1, z, \\lambda_x) W=plogis(z)W=\\mathrm{plogis}(z). Solve F(θ)=0F(\\theta)=0 using Newton/Broyden (analytic Jacobian). solution, compute DiD_i, normalize piEL∝1/Dip_i^{\\mathrm{EL}} \\propto 1/D_i, return Ŷ\\hat{Y} diagnostics. Step 5 — Variance Assemble =∂F/∂θA=\\partial F/\\partial\\theta analytically; assemble BB score totals (IID crossproduct survey svytotal vcov). Compute Var(Ŷ)\\mathrm{Var}(\\hat{Y}) via delta method: ∇gA−1BA−T∇gT\\nabla g\\,^{-1} B ^{-T}\\,\\nabla g^T. run (code) maps code Equations: src_dev/engines/el/impl/equations.R Jacobian: src_dev/engines/el/impl/jacobian.R Core solve + weights + variance: src_dev/engines/el/impl/core.R, src_dev/engines/el/impl/variance.R Scaling: src_dev/shared/scaling.R","code":"eng <- el_engine(auxiliary_means = c(X = mu_x), family = \"logit\", standardize = TRUE) res <- nmar(   formula = Y_miss ~ X,   data = df,   engine = eng,   response_predictors = NULL ) estimate(res); confint(res)"},{"path":"https://ncn-foreigners.github.io/NMAR/articles/el_empirical_likelihood_theory.html","id":"worked-example-probit-one-auxiliary-mean","dir":"Articles","previous_headings":"","what":"Worked Example: Probit + One Auxiliary Mean","title":"Empirical Likelihood Theory","text":"setup , probit response model. Response model (probit): wi=Φ(β0+β1Yi)w_i = \\Phi(\\beta_0 + \\beta_1\\,Y_i). Score term: si=μη,/wi=ϕ(ηi)/Φ(ηi)s_i = \\mu_{\\eta,}/w_i = \\phi(\\eta_i)/\\Phi(\\eta_i) (computed stably via log‑ratio code). equations denominator DiD_i logit example; wiw_i, μη,\\mu_{\\eta,}, sis_i change family. run (code) Notes analytic Jacobian valid probit μη,=ϕ(ηi)\\mu_{\\eta,}=\\phi(\\eta_i) μ′η,=−ηiϕ(ηi)\\mu'_{\\eta,}=-\\eta_i\\phi(\\eta_i). clip wiw_i away {0,1}\\{0,1\\} forming μ/w\\mu/w ensure numerical stability.","code":"eng <- el_engine(auxiliary_means = c(X = mu_x), family = \"probit\", standardize = TRUE) res <- nmar(   formula = Y_miss ~ X,   data = df,   engine = eng,   response_predictors = NULL ) estimate(res); confint(res)"},{"path":"https://ncn-foreigners.github.io/NMAR/articles/el_empirical_likelihood_theory.html","id":"debugging-tips","dir":"Articles","previous_headings":"","what":"Debugging Tips","title":"Empirical Likelihood Theory","text":"Convergence: diagnostics$max_equation_residual tiny (e.g., < 1e-5) solution. Constraints: constraint_sum_W constraint_sum_aux near 0 without trimming; small deviations may occur trimming. Denominator: min_denominator > 0; negative near‑zero values indicate inconsistent auxiliary targets bad starting point. Jacobian/inversion: inspect jacobian_condition_number, jacobian_source, invert_rule (“plain”, “ridge”, “pinv”). Consider variance_ridge=TRUE variance_pseudoinverse=TRUE ill‑conditioned. Variance choice: strong NMAR weight trimming, prefer variance_method=\"bootstrap\". Survey designs: ensure design weights known NpopN_{\\text{pop}} correct; confint() uses survey df t‑quantiles applicable. Conventions: normalization ∑ipiEL\\sum_i p_i^{\\text{EL}} implicit constraints applied explicitly forming Ŷ\\hat Y.","code":""},{"path":[]},{"path":"https://ncn-foreigners.github.io/NMAR/articles/el_empirical_likelihood_theory.html","id":"model-dimensions","dir":"Articles","previous_headings":"Generalization and Stability","what":"Model Dimensions","title":"Empirical Likelihood Theory","text":"Response model dimensions: arbitrary K=ncol(Z)K = \\text{ncol}(Z); sums crossproducts generalize automatically Auxiliary constraints: arbitrary L=ncol(X)L = \\text{ncol}(X); λx∈ℝL\\lambda_x \\\\mathbb{R}^L constraint sums columns","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/articles/el_empirical_likelihood_theory.html","id":"survey-design","dir":"Articles","previous_headings":"Generalization and Stability","what":"Survey Design","title":"Empirical Likelihood Theory","text":"Base weights enter aia_i totals NpopN_{\\text{pop}} nresp_weightedn_{\\text{resp\\_weighted}}; score covariance uses survey design’s replication BB. CI computation uses degrees--freedom tt-quantiles is_survey=TRUE. Example (survey; evaluated build):","code":"# \\dontshow{ if (!requireNamespace(\"survey\", quietly = TRUE)) stop(\"survey not installed\") } # \\dontrun{ library(survey) dclus1 <- svydesign(id = ~dnum, weights = ~pw, data = apiclus1, fpc = ~fpc) pop_mean_ell <- mean(apiclus1$ell) eng <- el_engine(auxiliary_means = c(ell = pop_mean_ell)) fit <- nmar(   formula = list(outcome = ~ api00_miss, covariates_outcome = ~ ell, covariates_missingness = ~ NULL),   data = dclus1,   engine = eng ) confint(fit)  # uses t-quantiles with survey df # }"},{"path":"https://ncn-foreigners.github.io/NMAR/articles/el_empirical_likelihood_theory.html","id":"numerical-safeguards","dir":"Articles","previous_headings":"Generalization and Stability","what":"Numerical Safeguards","title":"Empirical Likelihood Theory","text":"Bounds: cap η\\eta ±50\\pm 50; bound WW (ϵ,1−ϵ)(\\epsilon, 1 - \\epsilon); clip pp away {0,1}\\{0,1\\} computing μ/p\\mu/p; lower bound DiD_i ϵ\\epsilon Trimming: optional trim_cap piELp_i^{\\text{EL}} mass redistribution; prefer bootstrap variance trimming used Inversion: condition-aware −1A^{-1} optional ridge/pseudoinverse fallbacks full diagnostics, described Eta cap option: can adjust η\\eta cap via options(nmar.eta_cap = 60) (default 50) suit data scale link","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/articles/el_empirical_likelihood_theory.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Empirical Likelihood Theory","text":"Qin, J., Leung, D., Shao, J. (2002). Estimation survey data nonignorable nonresponse informative sampling. Journal American Statistical Association, 97(457), 193-200. doi:10.1198/016214502753479338","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/articles/el_empirical_likelihood_theory.html","id":"appendix-el-engine-api-reference-user-facing","dir":"Articles","previous_headings":"","what":"Appendix: EL Engine API Reference (User-Facing)","title":"Empirical Likelihood Theory","text":"appendix summarizes key options EL engine (constructor: el_engine()), defaults, recommended usage. Values: “logit”, “probit”, family object (list name, linkinv, mu.eta, d2mu.deta2, score_eta). Notes: implement logit_family() probit_family(). use log‑likelihood score score_eta(eta, delta) = mu.eta(eta)/linkinv(eta) (respondents), .e., ∂logp/∂η\\partial\\log p/\\partial\\eta. matches paper’s semiparametric MLE equations keeps analytic Jacobian family‑agnostic. Standardize ZZ/XX (μx\\mu_x) using nmar_scaling_recipe numerical stability. Coefficients vcov unscaled solving. Caps EL weights redistributes mass. Improves robustness extreme weights arise. Prefer variance_method = \"bootstrap\" trimming finite. “delta”: analytic delta method variance via sandwich −1BA−TA^{-1} B ^{-T} numeric ∇g\\nabla g. “bootstrap”: IID resampling survey replicate weights via svrep; often preferred trimming near-boundary cases. Values: “auto”, “analytic”, “numeric”. “auto”: prefer analytic available; fall back numeric rel_diff > 1e-3 kappa_analytic > 10 * kappa_numeric. Records jacobian_source jacobian_auto_rule (“default”, “rel_diff_high”, “kappa_ratio_high”). “analytic”: force analytic . “numeric”: force numeric . Values: “auto”, “analytic”, “none”. “auto”/“analytic”: pass analytic jacobian Newton available; otherwise, Newton without jac + Broyden fallback. “none”: never pass jacobian; rely Newton w/o jac Broyden fallback. TRUE, allow SVD pseudoinverse singular/ill-conditioned. Diagnostics: used_pseudoinverse = TRUE, invert_rule = \"pinv\". TRUE, apply adaptive ridge epsilon = base * sigma_max() (base=1e-8 ridge_scale). numeric, use epsilon. Diagnostics: used_ridge = TRUE, invert_rule = \"ridge\", ridge_epsilon. Helpful borderline ill-conditioned rank-deficient. Number bootstrap replicates variance_method = \"bootstrap\". Increase stability, decrease speed. Passed nleqslv (e.g., ftol, xtol, maxit). defaults ftol = 1e-10, xtol = 1e-10, maxit = 100, Broyden fallback needed.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/articles/el_empirical_likelihood_theory.html","id":"diagnostics-glanceprint","dir":"Articles","previous_headings":"Appendix: EL Engine API Reference (User-Facing)","what":"Diagnostics (glance/print)","title":"Empirical Likelihood Theory","text":"jacobian_source: “analytic” “numeric” used variance (). jacobian_rel_diff: relative Frobenius difference analytic numeric (computed). jacobian_auto_rule: reason overriding analytic (“default”, “rel_diff_high”, “kappa_ratio_high”). jacobian_condition_number: kappa() used variance. invert_rule: “plain”, “ridge”, “pinv” used ^{-1}. used_pseudoinverse, used_ridge: inversion flags.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/articles/el_empirical_likelihood_theory.html","id":"recommended-settings","dir":"Articles","previous_headings":"Appendix: EL Engine API Reference (User-Facing)","what":"Recommended settings","title":"Empirical Likelihood Theory","text":"Default: variance_method = \"delta\", variance_jacobian = \"auto\", solver_jacobian = \"auto\", standardize = TRUE. trimming suspected weak identification: prefer variance_method = \"bootstrap\". borderline ill-conditioned: set variance_ridge = TRUE (adaptive ridge) variance_pseudoinverse = TRUE (SVD pinv). Inspect diagnostics.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/articles/tutorial_empirical_likelihood.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Empirical Likelihood","text":"vignette demonstrates empirical likelihood (EL) estimator Missing Random (NMAR) data nmar package. method implements estimator Qin, Leung, Shao (2002), using empirical likelihood weights satisfy estimating equations response mechanism (optionally) auxiliary moment constraints. full derivations analytic Jacobian/variance details, see companion article “Empirical Likelihood Theory NMAR”. Key features: Supports data.frame (IID) survey.design objects (design-based variance) via nmar() API. Variance via delta (analytical sandwich) bootstrap. Optional standardization predictors; weight trimming robustness. Rich S3 surface: summary(), confint(), tidy(), glance(), plot()/autoplot().","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/articles/tutorial_empirical_likelihood.html","id":"quick-start","dir":"Articles","previous_headings":"Overview","what":"Quick start","title":"Empirical Likelihood","text":"Variables outcome RHS (e.g., X1 + X2) auxiliaries; supply known population means via auxiliary_means = c(X1 = ..., X2 = ...). Predictors response_predictors enter response model (auxiliary constraint) need population means. Choose engine: el_engine(...), e.g., el_engine(auxiliary_means = c(X1 = 0), variance_method = \"delta\", standardize = TRUE). Fit: nmar(formula = Y_miss ~ X1 + X2, data = df_or_design, engine = el_engine(...), response_predictors = c(\"Z1\",\"Z2\")). Inspect: summary(), confint(), weights(), fitted(), fit$diagnostics. # # Data-frame example (IID) simulate NMAR mechanism response probability depends unobserved outcome. Probit family (optional): Tidy/glance summaries, plots: Outputs diagnostics glance: Bootstrap variance (keep reps small speed):","code":"N <- 500 X <- rnorm(N) Z <- rnorm(N) Y <- 2 + 0.5 * X + Z  # NMAR response: depends on Y p <- plogis(-1.0 + 0.4 * scale(Y)[, 1]) R <- runif(N) < p  dat <- data.frame(Y_miss = Y, X = X) dat$Y_miss[!R] <- NA_real_ engine = el_engine(auxiliary_means = c(X = 0), variance_method = \"delta\", standardize = TRUE   ) # Fit EL estimator (delta variance) fit <- nmar(   formula = Y_miss ~ X,   data = dat,   engine = engine,   response_predictors = NULL )  summary(fit) #> NMAR Model Summary #> ================= #> Y_miss estimate: 1.878660 #> Std. Error: 0.251403 #> 95% CI: (1.385920, 2.371400) #> Converged: TRUE  #> Variance method: delta  #> Variance notes: Calculation successful  #> Total units: 500  #> Respondents: 150  #> Call: nmar(Y_miss ~ X, data = <data.frame: N=500>, engine = empirical_likelihood) #>  #> Response-model coefficients: #>               Estimate Std. Error    z value     Pr(>|z|) #> (Intercept) -1.5706942  0.1239364 -12.673394 8.304254e-37 #> Y_miss       0.3667545  0.3251176   1.128067 2.592915e-01 confint(fit) #>          2.5 % 97.5 % #> Y_miss 1.38592 2.3714 engine = el_engine(auxiliary_means = c(X = 0), family = \"probit\", variance_method = \"delta\", standardize = TRUE)  fit_probit <- nmar(   formula = Y_miss ~ X,   engine = engine,   data = dat,   response_predictors = NULL  ) summary(fit_probit) #> NMAR Model Summary #> ================= #> Y_miss estimate: 1.880128 #> Std. Error: 0.248300 #> 95% CI: (1.393469, 2.366787) #> Converged: TRUE  #> Variance method: delta  #> Variance notes: Calculation successful  #> Total units: 500  #> Respondents: 150  #> Call: nmar(Y_miss ~ X, data = <data.frame: N=500>, engine = empirical_likelihood) #>  #> Response-model coefficients: #>               Estimate Std. Error    z value     Pr(>|z|) #> (Intercept) -0.9496775 0.07636296 -12.436364 1.658849e-35 #> Y_miss       0.2175044 0.18540493   1.173132 2.407429e-01 if (requireNamespace(\"broom\", quietly = TRUE)) {   broom::tidy(fit)   broom::glance(fit) } #>   estimate std.error conf.low conf.high converged trimmed_fraction #> 1  1.87866 0.2514025  1.38592    2.3714      TRUE                0 #>   variance_method solver_jacobian jacobian_source jacobian_condition_number #> 1           delta        analytic        analytic                  36.83019 #>   jacobian_rel_diff max_equation_residual min_denominator #> 1      6.884968e-12          3.347322e-14       0.4613402 #>   fraction_small_denominators used_pseudoinverse nobs nobs_resp is_survey #> 1                           0              FALSE  500       150     FALSE  # plot(fit, which = \"weights\") # plot(fit, which = \"fitted\") weights(fit)[1:10] #>  [1] 1.2576603 1.3406704 0.6572937 2.1675980 1.0438681 1.0741326 0.8992693 #>  [8] 0.9537856 1.1085666 1.1764099 fitted(fit)[1:10] #>  [1] 0.2385382 0.2237686 0.4564170 0.1384020 0.2873926 0.2792951 0.3336042 #>  [8] 0.3145361 0.2706197 0.2550132 str(fit$diagnostics) #> List of 25 #>  $ convergence_code           : int 1 #>  $ message                    : chr \"Function criterion near zero\" #>  $ vcov_message               : chr \"Calculation successful\" #>  $ trimmed_fraction           : num 0 #>  $ solver_jacobian            : chr \"analytic\" #>  $ solver_method              : chr \"Newton\" #>  $ nleqslv_global             : chr NA #>  $ nleqslv_xscalm             : chr NA #>  $ solver_iterations          : int 7 #>  $ solver_time                : num 0.004 #>  $ variance_time              : num 0.006 #>  $ reparam_W                  : chr \"logit\" #>  $ max_equation_residual      : num 3.35e-14 #>  $ jacobian_condition_number  : num 36.8 #>  $ jacobian_source            : chr \"analytic\" #>  $ jacobian_rel_diff          : num 6.88e-12 #>  $ jacobian_auto_rule         : chr \"default\" #>  $ min_denominator            : num 0.461 #>  $ fraction_small_denominators: num 0 #>  $ constraint_sum_W           : num 6.73e-15 #>  $ constraint_sum_aux         : Named num 4.22e-15 #>   ..- attr(*, \"names\")= chr \"X\" #>  $ used_pseudoinverse         : logi FALSE #>  $ used_ridge                 : logi FALSE #>  $ invert_rule                : chr \"plain\" #>  $ variance_auto_rule         : chr NA engine = el_engine(auxiliary_means = c(X = 0), variance_method = \"bootstrap\", bootstrap_reps = 15, standardize = TRUE, suppress_warnings = TRUE)  fit_boot <- nmar(   formula = Y_miss ~ X,   engine = engine,   data = dat,   response_predictors = NULL  ) fit_boot$se #> NULL"},{"path":"https://ncn-foreigners.github.io/NMAR/articles/tutorial_empirical_likelihood.html","id":"response-only-predictors","dir":"Articles","previous_headings":"","what":"Response-only predictors","title":"Empirical Likelihood","text":"can include predictors enter response model (constrained auxiliaries). Specify covariates_missingness keeping auxiliary set RHS outcome formula. Auxiliary means formulas: Names auxiliary_means must match variables outcome RHS exactly. standardize = TRUE, engine automatically transforms auxiliary_means standardized scale internally reports coefficients original scale. Response-predictors (covariates_missingness) need auxiliary means.","code":"N <- 400 X <- rnorm(N) Z <- rnorm(N) Y <- 1 + 0.6 * X + 0.3 * Z + rnorm(N) p <- plogis(-0.6 + 0.5 * scale(Y)[, 1] + 0.4 * Z) R <- runif(N) < p df2 <- data.frame(Y_miss = Y, X = X, Z = Z) df2$Y_miss[!R] <- NA_real_ engine = el_engine(auxiliary_means = c(X = 0), variance_method = \"delta\", standardize = TRUE)  # Use X as auxiliary (known population mean 0), and Z as response-only predictor fit_resp_only <- nmar(   formula = Y_miss ~ X,   data = df2,   engine = engine,   response_predictors = c('Z') ) summary(fit_resp_only) #> NMAR Model Summary #> ================= #> Y_miss estimate: 1.258792 #> Std. Error: 0.140526 #> 95% CI: (0.983365, 1.534218) #> Converged: TRUE  #> Variance method: delta  #> Variance notes: Calculation successful  #> Total units: 400  #> Respondents: 154  #> Call: nmar(Y_miss ~ X, data = <data.frame: N=400>, engine = empirical_likelihood) #>  #> Response-model coefficients: #>                Estimate Std. Error     z value     Pr(>|z|) #> (Intercept) -0.85089950 0.05032983 -16.9064642 4.031846e-64 #> Y_miss       0.28631609 0.27162827   1.0540733 2.918494e-01 #> Z            0.05802273 0.19033451   0.3048461 7.604834e-01"},{"path":"https://ncn-foreigners.github.io/NMAR/articles/tutorial_empirical_likelihood.html","id":"survey-design-example-optional","dir":"Articles","previous_headings":"","what":"Survey design example (optional)","title":"Empirical Likelihood","text":"estimator supports complex surveys via survey::svydesign(). chunk runs survey package available.","code":"if (requireNamespace(\"survey\", quietly = TRUE)) {   library(survey)   data(api)    set.seed(42)   apiclus1$api00_miss <- apiclus1$api00   ystd <- scale(apiclus1$api00)[, 1]   prob <- plogis(-0.5 + 0.4 * ystd + 0.2 * scale(apiclus1$ell)[, 1])   miss <- runif(nrow(apiclus1)) > prob   apiclus1$api00_miss[miss] <- NA_real_    dclus1 <- svydesign(id = ~dnum, weights = ~pw, data = apiclus1, fpc = ~fpc)   pop_mean_ell <- mean(apiclus1$ell)   engine = el_engine(auxiliary_means = c(ell = pop_mean_ell), variance_method = \"delta\", standardize = TRUE)    fit_svy <- nmar(     formula = api00_miss ~ ell,     data = dclus1,     engine = engine,     response_predictors = NULL    )   summary(fit_svy) } #> Loading required package: grid #> Loading required package: Matrix #> Loading required package: survival #>  #> Attaching package: 'survey' #> The following object is masked from 'package:graphics': #>  #>     dotchart #> NMAR Model Summary #> ================= #> api00_miss estimate: 561.429381 #> Std. Error: 34.832435 #> 95% CI: (486.721237, 636.137525) #> Converged: TRUE  #> Variance method: delta  #> Variance notes: Calculation successful  #> Total units: 183  #> Respondents: 65  #> Call: nmar(api00_miss ~ ell, data = <survey.design: N=183>, engine = empirical_likelihood) #>  #> Response-model coefficients: #>                 Estimate Std. Error      z value     Pr(>|z|) #> (Intercept) -19.67790829  1.4801595 -13.29445081 2.484954e-09 #> api00_miss    0.03520924  0.9135567   0.03854083 9.698007e-01"},{"path":"https://ncn-foreigners.github.io/NMAR/articles/tutorial_empirical_likelihood.html","id":"practical-guidance","dir":"Articles","previous_headings":"","what":"Practical guidance","title":"Empirical Likelihood","text":"Variance method: delta method fast asymptotic; bootstrap often preferred moderate samples, trimming, near-boundary cases. Trimming: Use finite trim_cap improve robustness large weights occur; prefer bootstrap variance trimming. solver_method = \"auto\" (default) tries Newton (analytic Jacobian available) falls back Broyden needed. Force Broyden solver_method = \"broyden\" large‑p problems. solver_jacobian = \"analytic\" uses analytic Jacobian solving; set \"none\" force secant updates. Top‑level nleqslv args via solver_args = list(global = \"dbldog\", xscalm = \"auto\"). Control‑list tolerances via control = list(xtol = 1e-10, ftol = 1e-10, maxit = 200). effective settings used recorded fit$diagnostics (e.g., solver_method, nleqslv_global, nleqslv_xscalm). Standardization: standardize = TRUE typically improves numerical stability comparability across predictors auxiliary means. Diagnostics: Inspect fit$diagnostics (Jacobian condition number, max equation residuals, trimming fraction) assess numerical health identification strength. Response-predictors: Variables covariates_missingness need appear RHS outcome formula; enter response model. Auxiliary means must supplied variables outcome RHS. Inconsistent auxiliaries: provided auxiliary means grossly inconsistent sample, EL weights may go negative solver may fail. Consider revisiting constraints, relaxing , using trim_cap bootstrap variance. Troubleshooting: Negative extreme weights: set finite trim_cap; prefer variance_method = \"bootstrap\" SE. Ill-conditioned Jacobian (large fit$diagnostics$jacobian_condition_number): try variance_ridge = TRUE variance_pseudoinverse = TRUE el_engine(...). Convergence issues: check fit$diagnostics$max_equation_residual, rescale predictors (standardize = TRUE), reduce number constraints.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/articles/tutorial_empirical_likelihood.html","id":"references-and-further-reading","dir":"Articles","previous_headings":"","what":"References and further reading","title":"Empirical Likelihood","text":"Qin, J., Leung, D., Shao, J. (2002). Estimation survey data nonignorable nonresponse informative sampling. Journal American Statistical Association, 97(457), 193–200. doi:10.1198/016214502753479338 practical scripts experiments informed implementation, see package’s development materials simulation script inst/simulations/mc-el.R.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/articles/tutorial_empirical_likelihood.html","id":"families-and-numerical-stability","dir":"Articles","previous_headings":"","what":"Families and numerical stability","title":"Empirical Likelihood","text":"Family: el_engine(family = \"logit\") (default) family = \"probit\". Probit stability: response-model score uses stable log-ratio ϕ/Φ\\phi/\\Phi hood. Theory mapping: see companion article “Empirical Likelihood Theory NMAR” equations, Jacobian blocks, variance details.","code":"sessionInfo() #> R version 4.5.1 (2025-06-13) #> Platform: x86_64-pc-linux-gnu #> Running under: Ubuntu 24.04.3 LTS #>  #> Matrix products: default #> BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  #> LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.26.so;  LAPACK version 3.12.0 #>  #> locale: #>  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        #>  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    #>  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           #> [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    #>  #> time zone: UTC #> tzcode source: system (glibc) #>  #> attached base packages: #> [1] grid      stats     graphics  grDevices utils     datasets  methods   #> [8] base      #>  #> other attached packages: #> [1] survey_4.4-8   survival_3.8-3 Matrix_1.7-3   NMAR_0.0.0.1   #>  #> loaded via a namespace (and not attached): #>  [1] jsonlite_2.0.0      dplyr_1.1.4         compiler_4.5.1      #>  [4] Rcpp_1.1.0          tidyselect_1.2.1    nleqslv_3.3.5       #>  [7] tidyr_1.3.1         jquerylib_0.1.4     splines_4.5.1       #> [10] systemfonts_1.3.1   textshaping_1.0.3   yaml_2.3.10         #> [13] fastmap_1.2.0       lattice_0.22-7      R6_2.6.1            #> [16] generics_0.1.4      knitr_1.50          htmlwidgets_1.6.4   #> [19] backports_1.5.0     tibble_3.3.0        desc_1.4.3          #> [22] DBI_1.2.3           bslib_0.9.0         pillar_1.11.1       #> [25] rlang_1.1.6         cachem_1.1.0        broom_1.0.10        #> [28] xfun_0.53           fs_1.6.6            sass_0.4.10         #> [31] cli_3.6.5           pkgdown_2.1.3       magrittr_2.0.4      #> [34] digest_0.6.37       lifecycle_1.0.4     vctrs_0.6.5         #> [37] evaluate_1.0.5      glue_1.8.0          numDeriv_2016.8-1.1 #> [40] mitools_2.4         ragg_1.5.0          rmarkdown_2.30      #> [43] purrr_1.1.0         tools_4.5.1         pkgconfig_2.0.3     #> [46] htmltools_0.5.8.1"},{"path":"https://ncn-foreigners.github.io/NMAR/articles/tutorial_empirical_likelihood.html","id":"notes-on-variance-choices","dir":"Articles","previous_headings":"","what":"Notes on variance choices","title":"Empirical Likelihood","text":"variance_method = \"delta\" uses analytic sandwich; fast may ‑estimate variability tougher regimes (heavy nonresponse, ill‑conditioned Jacobians, trimming). Prefer variance_method = \"bootstrap\" robust SEs. speed‑critical bootstraps, can set variance_method = \"none\" point fits let bootstrap call use internally replicates (default behavior request bootstrap SEs el_engine(...)).","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Maciej Beręsewicz. Author, maintainer. Igor Kołodziej. Author. Mateusz Iwaniuk. Author.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Beręsewicz M, Kołodziej , Iwaniuk M (2025). NMAR: Missing Random. R package version 0.0.0.1, https://github.com/ncn-foreigners/NMAR.","code":"@Manual{,   title = {NMAR: Not Missing at Random},   author = {Maciej Beręsewicz and Igor Kołodziej and Mateusz Iwaniuk},   year = {2025},   note = {R package version 0.0.0.1},   url = {https://github.com/ncn-foreigners/NMAR}, }"},{"path":"https://ncn-foreigners.github.io/NMAR/index.html","id":"nmar","dir":"","previous_headings":"","what":"Not Missing at Random","title":"Not Missing at Random","text":"goal NMAR provide set functions estimate population mean data subject Missing Random (NMAR) mechanisms using advanced statistical methods","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"Not Missing at Random","text":"NMAR library provides functions estimate mean Missing Random (NMAR) data. estimation functions built upon following engine functions, implementing distinct method: exptilt_engine: Exponential Tilting Estimator Minsun Kim Riddles, Jae Kwang Kim, Jongho Im Propensity-score-adjustment Method Nonignorable Nonresponsehttps://doi.org/10.1093/jssam/smv047 exptilt_nonparam_engine: Nonparametric Exponential Tilting Estimator Minsun Kim Riddles, Jae Kwang Kim, Jongho Im Propensity-score-adjustment Method Nonignorable Nonresponse Appendix 2https://doi.org/10.1093/jssam/smv047 el_engine: Empirical Likelihood Estimator Jing Qin, Denis Leung, Jun Shao Estimation Survey Data Nonignorable Nonresponse Informative Samplinghttp://dx.doi.org/10.1198/016214502753479338 main user-facing function nmar(), acts unified wrapper around engine functions.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Not Missing at Random","text":"can install development version NMAR GitHub : ","code":"# install.packages(\"pak\") pak::pak(\"ncn-foreigners/NMAR\") remotes::install_github(\"ncn-foreigners/NMAR@main\", force = T, build = T, build_manual = T, build_vignettes = T)"},{"path":"https://ncn-foreigners.github.io/NMAR/index.html","id":"project-branches","dir":"","previous_headings":"Installation","what":"Project branches:","title":"Not Missing at Random","text":"main - stable production branch. version install general use package-pre_prod - pre-production development branch. stable, installable version reflecting latest features. (1:1 clone package-dev) package-dev - internal development branch. branch uses non-R package structure internal development purposes. download install branch. contribution guidelines, please see CONTRIBUTING.md file [project webpage (TODO: add link webpage)]","code":""},{"path":[]},{"path":"https://ncn-foreigners.github.io/NMAR/index.html","id":"general-naming","dir":"","previous_headings":"Usage","what":"General naming","title":"Not Missing at Random","text":"outcome_var (f.e Y): outcome variable (missing values). covariates_for_outcome(f.e x1,x2): Predictors outcome_var value (used response model). covariates_for_missingness(f.e x3): Predictor outcome_var missingness (used missingness model). formula = outcome_var ~ covariates_for_outcome","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/index.html","id":"example","dir":"","previous_headings":"Usage","what":"Example","title":"Not Missing at Random","text":", salary survey, richer people less likely answer, Y salary, x1 x2 experience education, x3 might gender (assume gender affects likelihood responding salary value ).","code":"generate_test_data <- function(n_rows = 400, n_cols = 2, case = 2, x_var = 0.5, eps_var = 0.5, a = 0.8, b = -0.2) {   X <- as.data.frame(replicate(n_cols, rnorm(n_rows, 0, x_var)^1))   colnames(X) <- paste0(\"x\", 1:n_cols)   coefs <- runif(n_cols, 0.95, 1.05)   eps <- rnorm(n_rows, 0, eps_var)   if (case == 1) {   X$Y <- as.vector(-1 + as.matrix(X) %*% coefs + eps)   }   X <- X[order(X$Y), ]   Y_original = X$Y   pi_obs <- 1 / (1 + exp(-(a + b * X$Y)))   mask <- runif(nrow(X)) > pi_obs   mask[1] <- FALSE   X$Y[mask] <- NA   return(list(X = X, Y_original = Y_original)) }  library(NMAR, quietly = T) res_test_data <- generate_test_data(n_rows = 500, n_cols = 3, case = 1) data <- res_test_data$X  exptilt_config <- exptilt_engine(   y_dens = 'normal',   family = 'probit', # or logit   variance_method='delta', #or delta )  formula = Y ~ x1 + x2 res <- nmar(formula = formula, data = data, engine = exptilt_config, response_predictors = c('x3'))  print(res) #> NMAR Result #> ------------ #> Y: -1.048756 #> Std. Error: 0.106028 #> Converged: TRUE  #> Variance method: delta  #> Estimator: exponential_tilting  #> Sample size: 500 (respondents: 359)"},{"path":"https://ncn-foreigners.github.io/NMAR/index.html","id":"getting-help","dir":"","previous_headings":"","what":"Getting help","title":"Not Missing at Random","text":"encounter clear bug, please file issue minimal reproducible example GitHub","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/index.html","id":"authors-and-acknowledgments","dir":"","previous_headings":"","what":"Authors and acknowledgments","title":"Not Missing at Random","text":"Research grant: OPUS 20 #2020/39/B/HS4/00941 Maciej Beręsewicz Igor Kołodziej Mateusz Iwaniuk","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/apply_nmar_scaling.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply scaling to a matrix using a recipe — apply_nmar_scaling","title":"Apply scaling to a matrix using a recipe — apply_nmar_scaling","text":"Apply scaling matrix using recipe","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/apply_nmar_scaling.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply scaling to a matrix using a recipe — apply_nmar_scaling","text":"","code":"apply_nmar_scaling(matrix_to_scale, recipe)"},{"path":"https://ncn-foreigners.github.io/NMAR/reference/apply_nmar_scaling.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Apply scaling to a matrix using a recipe — apply_nmar_scaling","text":"matrix_to_scale numeric matrix column names present `recipe`. recipe object class `nmar_scaling_recipe`.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/apply_nmar_scaling.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Apply scaling to a matrix using a recipe — apply_nmar_scaling","text":"matrix named column centered scaled using recipe.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/autoplot.html","id":null,"dir":"Reference","previous_headings":"","what":"ggplot2 autoplot generic — autoplot","title":"ggplot2 autoplot generic — autoplot","text":"Generic autoplot; methods provide plotting NMAR results.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/autoplot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ggplot2 autoplot generic — autoplot","text":"","code":"autoplot(object, ...)"},{"path":"https://ncn-foreigners.github.io/NMAR/reference/autoplot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ggplot2 autoplot generic — autoplot","text":"object object. ... Passed methods.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/autoplot.nmar_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Default ggplot2 autoplot for NMAR results — autoplot.nmar_result","title":"Default ggplot2 autoplot for NMAR results — autoplot.nmar_result","text":"Quick ggplot2 visualizations result objects.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/autoplot.nmar_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Default ggplot2 autoplot for NMAR results — autoplot.nmar_result","text":"","code":"# S3 method for class 'nmar_result' autoplot(object, type = c(\"weights\", \"fitted\", \"constraints\"), ...)"},{"path":"https://ncn-foreigners.github.io/NMAR/reference/autoplot.nmar_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Default ggplot2 autoplot for NMAR results — autoplot.nmar_result","text":"object object class `nmar_result` subclass. type One \"weights\", \"fitted\", \"constraints\". ... Ignored.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/autoplot.nmar_result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Default ggplot2 autoplot for NMAR results — autoplot.nmar_result","text":"`ggplot` object.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/bootstrap_variance.data.frame.html","id":null,"dir":"Reference","previous_headings":"","what":"Bootstrap for i.i.d. data.frames — bootstrap_variance.data.frame","title":"Bootstrap for i.i.d. data.frames — bootstrap_variance.data.frame","text":"Bootstrap ..d. data.frames","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/bootstrap_variance.data.frame.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Bootstrap for i.i.d. data.frames — bootstrap_variance.data.frame","text":"","code":"# S3 method for class 'data.frame' bootstrap_variance(   data,   estimator_func,   point_estimate,   bootstrap_reps = 500,   ... )"},{"path":"https://ncn-foreigners.github.io/NMAR/reference/bootstrap_variance.data.frame.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Bootstrap for i.i.d. data.frames — bootstrap_variance.data.frame","text":"data `data.frame` `survey.design`. estimator_func function returns S3 result object; primary estimate extracted via `$estimate` convergence via `$converged`. point_estimate numeric; point estimate used survey variance formulas. bootstrap_reps integer; number resamples. ... passed `estimator_func`.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/bootstrap_variance.data.frame.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Bootstrap for i.i.d. data.frames — bootstrap_variance.data.frame","text":"list `se`, `variance`, vector `replicates`.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/bootstrap_variance.html","id":null,"dir":"Reference","previous_headings":"","what":"Shared bootstrap variance helpers — bootstrap_variance","title":"Shared bootstrap variance helpers — bootstrap_variance","text":"S3 generic + methods estimate variance estimator   via resampling (IID) replicate weights (survey). Designed reused   across NMAR engines.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/bootstrap_variance.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Shared bootstrap variance helpers — bootstrap_variance","text":"","code":"bootstrap_variance(data, estimator_func, point_estimate, ...)"},{"path":"https://ncn-foreigners.github.io/NMAR/reference/bootstrap_variance.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Shared bootstrap variance helpers — bootstrap_variance","text":"data `data.frame` `survey.design`. estimator_func function returns S3 result object; primary estimate extracted via `$estimate` convergence via `$converged`. point_estimate numeric; point estimate used survey variance formulas. ... passed `estimator_func`.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/bootstrap_variance.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Shared bootstrap variance helpers — bootstrap_variance","text":"- `data.frame` inputs, performs ..d. bootstrap resampling rows     rerunning `estimator_func`.   - `survey.design` inputs, converts bootstrap replicate‑weight     design (`svrep::as_bootstrap_design`) uses `survey::withReplicates`     compute replicate estimates; variance computed `survey::svrVar`.   `estimator_func` typically engine method (e.g., `el()`), called   arguments used point estimate, except `data`   argument replaced resampled data replicate design.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/bootstrap_variance.survey.design.html","id":null,"dir":"Reference","previous_headings":"","what":"Bootstrap for survey designs via replicate weights — bootstrap_variance.survey.design","title":"Bootstrap for survey designs via replicate weights — bootstrap_variance.survey.design","text":"Bootstrap survey designs via replicate weights","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/bootstrap_variance.survey.design.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Bootstrap for survey designs via replicate weights — bootstrap_variance.survey.design","text":"","code":"# S3 method for class 'survey.design' bootstrap_variance(   data,   estimator_func,   point_estimate,   bootstrap_reps = 500,   ... )"},{"path":"https://ncn-foreigners.github.io/NMAR/reference/bootstrap_variance.survey.design.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Bootstrap for survey designs via replicate weights — bootstrap_variance.survey.design","text":"data `data.frame` `survey.design`. estimator_func function returns S3 result object; primary estimate extracted via `$estimate` convergence via `$converged`. point_estimate numeric; point estimate used survey variance formulas. bootstrap_reps integer; number bootstrap replicates. ... passed `estimator_func`.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/bootstrap_variance.survey.design.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Bootstrap for survey designs via replicate weights — bootstrap_variance.survey.design","text":"list `se`, `variance`, vector `replicates`.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/bootstrap_variance.survey.design.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Bootstrap for survey designs via replicate weights — bootstrap_variance.survey.design","text":"path constructs replicate-weight design using   [svrep::as_bootstrap_design()] rebuilds original sampling design   replicate weight vector. supplied design must created   directly [survey::svydesign()].","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/build_el_jacobian.html","id":null,"dir":"Reference","previous_headings":"","what":"Analytical Jacobian for empirical likelihood — build_el_jacobian","title":"Analytical Jacobian for empirical likelihood — build_el_jacobian","text":"Analytical Jacobian empirical likelihood","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/build_el_jacobian.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Analytical Jacobian for empirical likelihood — build_el_jacobian","text":"","code":"build_el_jacobian(   family,   response_model_matrix,   auxiliary_matrix,   respondent_weights,   N_pop,   n_resp_weighted,   mu_x_scaled )"},{"path":"https://ncn-foreigners.github.io/NMAR/reference/build_el_jacobian.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Analytical Jacobian for empirical likelihood — build_el_jacobian","text":"Builds block Jacobian \\(=\\partial F/\\partial \\theta\\)   EL estimating system (\\(\\beta\\), \\(W\\), auxiliary multipliers).   response‑model score \\(\\partial\\log p(\\eta)/\\partial\\eta =   \\mu_\\eta(\\eta)/p(\\eta)\\), generalizes logit probit   families. Aligned Qin, Leung Shao (2002).","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/choose_jacobian.html","id":null,"dir":"Reference","previous_headings":"","what":"Select between analytic and numeric Jacobians at a solution. — choose_jacobian","title":"Select between analytic and numeric Jacobians at a solution. — choose_jacobian","text":"Evaluates supplied analytic numeric Jacobian functions target parameter vector, reports preferred matrix, summarises diagnostic metrics condition number relative difference.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/choose_jacobian.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Select between analytic and numeric Jacobians at a solution. — choose_jacobian","text":"","code":"choose_jacobian(analytic_fun, numeric_fun, at)"},{"path":"https://ncn-foreigners.github.io/NMAR/reference/choose_jacobian.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Select between analytic and numeric Jacobians at a solution. — choose_jacobian","text":"analytic_fun Function returning analytic Jacobian; may `NULL`. numeric_fun Function returning numerical Jacobian. Numeric vector Jacobians evaluated.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/choose_jacobian.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Select between analytic and numeric Jacobians at a solution. — choose_jacobian","text":"list entries `` (chosen matrix), `A_analytic`, `A_numeric`,   `source`, `kappa`, `rel_diff`.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/coef.nmar_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Default coefficients for NMAR results — coef.nmar_result","title":"Default coefficients for NMAR results — coef.nmar_result","text":"Returns response-model coefficients available.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/coef.nmar_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Default coefficients for NMAR results — coef.nmar_result","text":"","code":"# S3 method for class 'nmar_result' coef(object, ...)"},{"path":"https://ncn-foreigners.github.io/NMAR/reference/coef.nmar_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Default coefficients for NMAR results — coef.nmar_result","text":"object `nmar_result` object. ... Ignored.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/coef.nmar_result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Default coefficients for NMAR results — coef.nmar_result","text":"named numeric vector `NULL`.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/confint.nmar_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Wald confidence interval for base NMAR results — confint.nmar_result","title":"Wald confidence interval for base NMAR results — confint.nmar_result","text":"Wald confidence interval base NMAR results","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/confint.nmar_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Wald confidence interval for base NMAR results — confint.nmar_result","text":"","code":"# S3 method for class 'nmar_result' confint(object, parm, level = 0.95, ...)"},{"path":"https://ncn-foreigners.github.io/NMAR/reference/confint.nmar_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Wald confidence interval for base NMAR results — confint.nmar_result","text":"object object class `nmar_result`. parm Ignored. level Confidence level. ... Ignored.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/constraint_summaries.html","id":null,"dir":"Reference","previous_headings":"","what":"Constraint summaries for EL diagnostics — constraint_summaries","title":"Constraint summaries for EL diagnostics — constraint_summaries","text":"Constraint summaries EL diagnostics","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/constraint_summaries.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Constraint summaries for EL diagnostics — constraint_summaries","text":"","code":"constraint_summaries(w_i_hat, W_hat, p_untrim, X_centered)"},{"path":"https://ncn-foreigners.github.io/NMAR/reference/convergenceError.html","id":null,"dir":"Reference","previous_headings":"","what":"Error/condition helpers — convergenceError","title":"Error/condition helpers — convergenceError","text":"Developer note: - Add lightweight condition constructors common error types keep   signaling consistent across engines shared utilities. - Keep unexported; meant internal flow control clear   diagnostics (e.g., `convergenceError`). - Prefer simple S3 condition classes like `c(\"<type>\", \"error\", \"condition\")`.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/convergenceError.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Error/condition helpers — convergenceError","text":"","code":"convergenceError(message, call = NULL)"},{"path":"https://ncn-foreigners.github.io/NMAR/reference/create_nmar_scaling_recipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Build a scaling recipe from one or more design matrices — create_nmar_scaling_recipe","title":"Build a scaling recipe from one or more design matrices — create_nmar_scaling_recipe","text":"Build scaling recipe one design matrices","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/create_nmar_scaling_recipe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Build a scaling recipe from one or more design matrices — create_nmar_scaling_recipe","text":"","code":"create_nmar_scaling_recipe(   ...,   intercept_col = \"(Intercept)\",   weights = NULL,   weight_mask = NULL,   tol_constant = 1e-08,   warn_on_constant = TRUE )"},{"path":"https://ncn-foreigners.github.io/NMAR/reference/create_nmar_scaling_recipe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Build a scaling recipe from one or more design matrices — create_nmar_scaling_recipe","text":"... one matrices named columns. intercept_col Intercept column name remain unscaled. weights Optional numeric vector weights used compute weighted means/standard deviations. weight_mask Optional logical/ numeric mask applied `weights` computing moments (useful respondents-scaling). tol_constant Numeric tolerance columns treated constant left unscaled. warn_on_constant Logical; emit warning column treated constant.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/el.data.frame.html","id":null,"dir":"Reference","previous_headings":"","what":"Empirical likelihood for data frames (NMAR) — el.data.frame","title":"Empirical likelihood for data frames (NMAR) — el.data.frame","text":"Internal method dispatched `el()` `data` `data.frame`.   Returns `c('nmar_result_el','nmar_result')` estimate, standard error, weights,   coefficients, diagnostics metadata.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/el.data.frame.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Empirical likelihood for data frames (NMAR) — el.data.frame","text":"","code":"# S3 method for class 'data.frame' el(   data,   formula,   response_predictors = NULL,   auxiliary_means = NULL,   standardize = TRUE,   trim_cap = Inf,   control = list(),   on_failure = c(\"return\", \"error\"),   variance_method = c(\"delta\", \"bootstrap\", \"none\"),   variance_jacobian = c(\"auto\", \"analytic\", \"numeric\"),   solver_jacobian = c(\"auto\", \"analytic\", \"none\"),   solver_method = c(\"auto\", \"newton\", \"broyden\"),   solver_args = list(),   variance_pseudoinverse = FALSE,   variance_ridge = FALSE,   bootstrap_reps = 500,   suppress_warnings = FALSE,   ... )"},{"path":"https://ncn-foreigners.github.io/NMAR/reference/el.data.frame.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Empirical likelihood for data frames (NMAR) — el.data.frame","text":"data `data.frame` outcome column contains `NA` nonrespondents. formula Two-sided formula `Y_miss ~ auxiliaries`. response_predictors Optional character vector naming predictors response (missingness) model. variables enter response model (auxiliary constraint) require population means. auxiliary_means Named numeric vector population means auxiliary variables (names must match RHS outcome formula). standardize Logical; whether standardize predictors prior estimation. trim_cap Numeric; cap EL weights (`Inf` = trimming). control List; optional solver control parameters `nleqslv(control=...)`. on_failure Character; one `\"return\"` `\"error\"` solver failure. variance_method Character; one `\"delta\"`, `\"bootstrap\"`, `\"none\"`. variance_jacobian Character; one `\"auto\"`, `\"analytic\"`, `\"numeric\"`. solver_jacobian Character; one `\"auto\"`, `\"analytic\"`, `\"none\"`. solver_args List; optional top-level `nleqslv` args (e.g., `global`, `xscalm`). variance_pseudoinverse Logical; allow pseudo-inverse variance needed. variance_ridge Logical numeric; TRUE, apply adaptive ridge Jacobian inversion; numeric, treated ridge epsilon. bootstrap_reps Integer; number bootstrap reps `variance_method = \"bootstrap\"`. suppress_warnings Logical; suppress variance-related warnings. ... Additional arguments passed solver.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/el.data.frame.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Empirical likelihood for data frames (NMAR) — el.data.frame","text":"Implements empirical likelihood estimator Qin, Leung Shao (2002) IID data. response‑model score derivative Bernoulli log‑likelihood respect linear predictor; auxiliary moment constraints optional.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/el.data.frame.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Empirical likelihood for data frames (NMAR) — el.data.frame","text":"Qin, J., Leung, D., Shao, J. (2002). Estimation survey data nonignorable nonresponse informative sampling. Journal American Statistical Association, 97(457), 193–200.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/el.html","id":null,"dir":"Reference","previous_headings":"","what":"Empirical likelihood estimator — el","title":"Empirical likelihood estimator — el","text":"Generic empirical likelihood (EL) estimator NMAR.   Methods provided `data.frame` `survey.design`.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/el.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Empirical likelihood estimator — el","text":"","code":"el(data, ...)"},{"path":"https://ncn-foreigners.github.io/NMAR/reference/el.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Empirical likelihood estimator — el","text":"data `data.frame` `survey.design`. ... Passed class-specific methods.","code":""},{"path":[]},{"path":"https://ncn-foreigners.github.io/NMAR/reference/el.survey.design.html","id":null,"dir":"Reference","previous_headings":"","what":"Empirical likelihood for survey designs (NMAR) — el.survey.design","title":"Empirical likelihood for survey designs (NMAR) — el.survey.design","text":"Internal method dispatched `el()` `data` `survey.design`.   Uses design‑based covariance variance estimation `variance_method = 'delta'`.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/el.survey.design.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Empirical likelihood for survey designs (NMAR) — el.survey.design","text":"","code":"# S3 method for class 'survey.design' el(   data,   formula,   response_predictors = NULL,   auxiliary_means = NULL,   standardize = TRUE,   trim_cap = Inf,   control = list(),   on_failure = c(\"return\", \"error\"),   variance_method = c(\"delta\", \"bootstrap\", \"none\"),   variance_jacobian = c(\"auto\", \"analytic\", \"numeric\"),   solver_jacobian = c(\"auto\", \"analytic\", \"none\"),   solver_method = c(\"auto\", \"newton\", \"broyden\"),   solver_args = list(),   variance_pseudoinverse = FALSE,   variance_ridge = FALSE,   bootstrap_reps = 500,   suppress_warnings = FALSE,   ... )"},{"path":"https://ncn-foreigners.github.io/NMAR/reference/el.survey.design.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Empirical likelihood for survey designs (NMAR) — el.survey.design","text":"data `survey.design` created [survey::svydesign()]. formula Two-sided formula: NA-valued outcome LHS; auxiliaries RHS. response_predictors Optional character vector response model RHS. may include variables RHS outcome formula; variables enter response model (auxiliary constraint). auxiliary_means Named numeric vector population means auxiliaries. standardize Logical; standardize predictors. trim_cap Numeric; cap EL weights (Inf = trimming). control List; solver control `nleqslv(control=...)`. on_failure Character; \"return\" \"error\" solver failure. variance_method Character; \"delta\" \"bootstrap\". variance_jacobian Character; \"auto\", \"analytic\", \"numeric\". solver_jacobian Character; \"auto\", \"analytic\", \"none\". solver_args List; optional top-level `nleqslv` args (e.g., `global`, `xscalm`). variance_pseudoinverse Logical; allow pseudo-inverse variance. variance_ridge Logical numeric; TRUE, apply adaptive ridge Jacobian inversion; numeric, treated ridge epsilon. bootstrap_reps Integer; reps `variance_method = \"bootstrap\"`. suppress_warnings Logical; suppress variance method warnings. ... Passed solver.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/el.survey.design.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Empirical likelihood for survey designs (NMAR) — el.survey.design","text":"`c('nmar_result_el','nmar_result')`.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/el.survey.design.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Empirical likelihood for survey designs (NMAR) — el.survey.design","text":"Implements empirical likelihood estimator Qin, Leung Shao (2002) design weights design‑based covariance score totals delta variance. Bootstrap variance via replicate weights also supported.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/el.survey.design.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Empirical likelihood for survey designs (NMAR) — el.survey.design","text":"Qin, J., Leung, D., Shao, J. (2002). Estimation survey data nonignorable nonresponse informative sampling. Journal American Statistical Association, 97(457), 193–200.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/el_build_equation_system.html","id":null,"dir":"Reference","previous_headings":"","what":"Empirical likelihood estimating equations — el_build_equation_system","title":"Empirical likelihood estimating equations — el_build_equation_system","text":"Empirical likelihood estimating equations","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/el_build_equation_system.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Empirical likelihood estimating equations — el_build_equation_system","text":"","code":"el_build_equation_system(   family,   response_model_matrix,   auxiliary_matrix,   respondent_weights,   N_pop,   n_resp_weighted,   mu_x_scaled )"},{"path":"https://ncn-foreigners.github.io/NMAR/reference/el_build_equation_system.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Empirical likelihood estimating equations — el_build_equation_system","text":"Returns function evaluating stacked EL equations   \\(\\beta\\), \\(W\\) (optionally) auxiliary multipliers.   response‑model score uses derivative Bernoulli log‑likelihood   respect linear predictor, \\(\\partial\\log p(\\eta)/\\partial\\eta   = \\mu_\\eta(\\eta)/p(\\eta)\\), valid logit probit links.   matches semiparametric EL system Qin, Leung Shao (2002).","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/el_compute_score_contrib.html","id":null,"dir":"Reference","previous_headings":"","what":"EL variance components and sandwich assembly — el_compute_score_contrib","title":"EL variance components and sandwich assembly — el_compute_score_contrib","text":"EL variance components sandwich assembly","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/el_compute_score_contrib.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"EL variance components and sandwich assembly — el_compute_score_contrib","text":"","code":"el_compute_score_contrib(   family,   response_model_matrix_scaled,   auxiliary_matrix_scaled,   mu_x_scaled,   eta_i_hat,   w_i_hat,   W_hat,   denominator_hat,   lambda_W_hat )"},{"path":"https://ncn-foreigners.github.io/NMAR/reference/el_compute_score_contrib.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"EL variance components and sandwich assembly — el_compute_score_contrib","text":"Assembles respondent score matrix, computes covariance   total scores (IID crossproduct survey design-based), constructs   delta variance \\(\\hat Y\\) via \\(\\nabla g\\,^{-1} B ^{-T}\\,\\nabla g^T\\).   Consistent asymptotic results Qin, Leung Shao (2002).","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/el_engine.html","id":null,"dir":"Reference","previous_headings":"","what":"Empirical likelihood (EL) engine for NMAR — el_engine","title":"Empirical likelihood (EL) engine for NMAR — el_engine","text":"Constructs configuration empirical likelihood estimator nonignorable nonresponse (NMAR), following Qin, Leung Shao (2002). Pass returned object `nmar()` together formula data.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/el_engine.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Empirical likelihood (EL) engine for NMAR — el_engine","text":"","code":"el_engine(   standardize = TRUE,   trim_cap = Inf,   on_failure = c(\"return\", \"error\"),   variance_method = c(\"delta\", \"bootstrap\", \"none\"),   variance_jacobian = c(\"auto\", \"analytic\", \"numeric\"),   solver_jacobian = c(\"auto\", \"analytic\", \"none\"),   solver_method = c(\"auto\", \"newton\", \"broyden\"),   solver_args = list(),   variance_pseudoinverse = FALSE,   variance_ridge = FALSE,   bootstrap_reps = 500,   suppress_warnings = FALSE,   auxiliary_means = NULL,   control = list(),   family = c(\"logit\", \"probit\") )"},{"path":"https://ncn-foreigners.github.io/NMAR/reference/el_engine.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Empirical likelihood (EL) engine for NMAR — el_engine","text":"standardize Logical; standardize predictors. Default TRUE. trim_cap Numeric; cap EL weights (Inf = trimming). on_failure Character; \"return\" \"error\" solver failure. variance_method Character; one \"delta\", \"bootstrap\", \"none\". variance_jacobian Character; \"auto\", \"analytic\", \"numeric\". solver_jacobian Character; \"auto\", \"analytic\", \"none\". solver_method Character; policy root solver: - \"auto\" (default): Newton analytic Jacobian, perturbation restarts, Broyden fallback. - \"newton\": Newton (Broyden fallback). - \"broyden\": Broyden (secant updates, analytic Jacobian). solver_args List; optional top‑level `nleqslv` arguments `global` (e.g., \"dbldog\", \"qline\") `xscalm` (e.g., \"auto\", \"fixed\"). passed top level `nleqslv` call take precedence similarly named entries provided `control`. variance_pseudoinverse Logical; allow pseudo-inverse variance. variance_ridge Logical numeric; TRUE, apply adaptive ridge stabilize Jacobian inversion; numeric, treated ridge epsilon. bootstrap_reps Integer; reps variance_method = \"bootstrap\". suppress_warnings Logical; suppress variance method warnings. auxiliary_means Named numeric vector; population means auxiliaries (names must match RHS outcome formula). Optional. control List; optional solver control `nleqslv::nleqslv(control=...)`. Recognized fields include `xtol`, `ftol`, `btol`, `maxit`, `trace`, `stepmax`, `delta`. family Response model family; string (\"logit\" \"probit\") family object created `logit_family()` / `probit_family()`.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/el_engine.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Empirical likelihood (EL) engine for NMAR — el_engine","text":"engine object class `c('nmar_engine_el','nmar_engine')`.   configuration list; fit. Pass `nmar()`.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/el_engine.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Empirical likelihood (EL) engine for NMAR — el_engine","text":"EL estimator uses weights satisfy estimating equations response mechanism optional auxiliary moment constraints. response model score derivative Bernoulli log‑likelihood respect linear predictor, .e. `mu.eta(eta)/linkinv(eta)`, valid logit probit links. Response predictors need coincide auxiliary predictors; auxiliaries require known population moments. See theory note Qin, Leung Shao (2002) derivations.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/el_engine.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Empirical likelihood (EL) engine for NMAR — el_engine","text":"Qin, J., Leung, D., Shao, J. (2002). Estimation survey data nonignorable nonresponse informative sampling. Journal American Statistical Association, 97(457), 193–200.","code":""},{"path":[]},{"path":"https://ncn-foreigners.github.io/NMAR/reference/el_engine.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Empirical likelihood (EL) engine for NMAR — el_engine","text":"","code":"# \\donttest{ set.seed(1) n <- 200 X <- rnorm(n); Z <- rnorm(n) Y <- 2 + 0.5 * X + Z p <- plogis(-0.7 + 0.4 * scale(Y)[, 1]) R <- runif(n) < p df <- data.frame(Y_miss = Y, X = X); df$Y_miss[!R] <- NA_real_ eng <- el_engine(auxiliary_means = c(X = 0), variance_method = \"delta\") fit <- nmar(Y_miss ~ X, data = df, engine = eng) summary(fit) #> NMAR Model Summary #> ================= #> Y_miss estimate: 3.090401 #> Std. Error: 0.281894 #> 95% CI: (2.537898, 3.642903) #> Converged: TRUE  #> Variance method: delta  #> Variance notes: Calculation successful  #> Total units: 200  #> Respondents: 76  #> Call: nmar(Y_miss ~ X, data = <data.frame: N=200>, engine = empirical_likelihood) #>  #> Response-model coefficients: #>              Estimate Std. Error   z value     Pr(>|z|) #> (Intercept)  3.250571  0.4834881  6.723167 1.778169e-11 #> Y_miss      -1.239524  0.4592639 -2.698936 6.956151e-03 # }"},{"path":"https://ncn-foreigners.github.io/NMAR/reference/el_estimator_core.html","id":null,"dir":"Reference","previous_headings":"","what":"Core Empirical Likelihood Estimator — el_estimator_core","title":"Core Empirical Likelihood Estimator — el_estimator_core","text":"Implements core computational engine empirical likelihood estimation nonignorable nonresponse, including parameter solving, variance calculation, diagnostic computation.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/el_estimator_core.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Core Empirical Likelihood Estimator — el_estimator_core","text":"","code":"el_estimator_core(   full_data,   respondent_data,   respondent_weights,   N_pop,   internal_formula,   auxiliary_means,   standardize,   trim_cap,   control,   compute_score_variance_func,   on_failure,   family = logit_family(),   variance_method,   bootstrap_reps,   variance_jacobian = c(\"auto\", \"analytic\", \"numeric\"),   solver_jacobian = c(\"auto\", \"analytic\", \"none\"),   solver_method = c(\"auto\", \"newton\", \"broyden\"),   solver_args = list(),   variance_pseudoinverse = FALSE,   variance_ridge = FALSE,   user_args,   ... )"},{"path":"https://ncn-foreigners.github.io/NMAR/reference/el_estimator_core.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Core Empirical Likelihood Estimator — el_estimator_core","text":"full_data Data frame survey design object containing units. respondent_data Data frame containing responding units. respondent_weights Numeric vector base sampling weights respondents. N_pop Numeric. Total population size (weighted survey design). internal_formula List internal formulas outcome, response, auxiliary models. auxiliary_means Named numeric vector known population means. standardize Logical. Whether standardize predictors estimation. trim_cap Numeric. Upper bound empirical likelihood weight trimming. control List control parameters nonlinear equation solver. compute_score_variance_func Function compute covariance score totals. on_failure Character. Action solver fails: \"return\" \"error\". family List. Link function specification (typically logit). variance_method Character. Variance estimation method. bootstrap_reps Integer. Number bootstrap replications. variance_jacobian Character. Jacobian method variance computation. solver_jacobian Character. Jacobian method equation solving. variance_pseudoinverse Logical. Use pseudoinverse singular matrices. variance_ridge Logical. Use ridge regularization variance. user_args List. Original user arguments bootstrap replication. ... Additional arguments passed solver.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/el_estimator_core.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Core Empirical Likelihood Estimator — el_estimator_core","text":"List containing estimation results, diagnostics, metadata.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/el_estimator_core.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Core Empirical Likelihood Estimator — el_estimator_core","text":"function implements complete empirical likelihood estimation algorithm: 1. Data preparation scaling 2. Equation system construction 3. Multi-stage nonlinear equation solving robust fallback strategies 4. Weight computation trimming 5. Variance estimation (delta method bootstrap) 6. Comprehensive diagnostic computation","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/el_grad_g_analytic.html","id":null,"dir":"Reference","previous_headings":"","what":"Analytic gradient of the mean functional g(θ) — el_grad_g_analytic","title":"Analytic gradient of the mean functional g(θ) — el_grad_g_analytic","text":"Computes analytic gradient respondent-weighted mean functional   g = sum_i(pi_i y_i)/sum_i(pi_i) smooth conditions (trimming),   EL reparameterization (β, z = logit(W), λ_x). mirrors   guarded denominators used post-solution weight construction.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/el_grad_g_analytic.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Analytic gradient of the mean functional g(θ) — el_grad_g_analytic","text":"","code":"el_grad_g_analytic(   family,   X_beta,   Xc,   mu_x_scaled,   respondent_weights,   eta_i_hat,   w_i_hat,   W_hat,   denominator_hat,   lambda_W_hat,   outcome_vec,   n_resp_weighted,   N_pop )"},{"path":"https://ncn-foreigners.github.io/NMAR/reference/el_run_solver.html","id":null,"dir":"Reference","previous_headings":"","what":"EL core helpers — el_run_solver","title":"EL core helpers — el_run_solver","text":"Internal helpers solving post‑processing EL system:   `el_run_solver()` orchestrates nleqslv restarts/fallback; `el_post_solution()`   computes weights point estimate denominator guards trimming.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/el_run_solver.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"EL core helpers — el_run_solver","text":"","code":"el_run_solver(   equation_system_func,   analytical_jac_func,   init,   final_control,   top_args,   solver_method,   use_solver_jac,   K_beta,   K_aux,   respondent_weights,   N_pop )"},{"path":"https://ncn-foreigners.github.io/NMAR/reference/el_select_variance_jacobian.html","id":null,"dir":"Reference","previous_headings":"","what":"Variance helper utilities — el_select_variance_jacobian","title":"Variance helper utilities — el_select_variance_jacobian","text":"Centralizes Jacobian selection variance delta-variance pipeline keep core estimator compact consistent.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/el_select_variance_jacobian.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Variance helper utilities — el_select_variance_jacobian","text":"","code":"el_select_variance_jacobian(   equation_system_func,   analytical_jac_func,   estimates,   variance_jacobian = c(\"auto\", \"analytic\", \"numeric\") )"},{"path":"https://ncn-foreigners.github.io/NMAR/reference/el_select_variance_jacobian.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Variance helper utilities — el_select_variance_jacobian","text":"equation_system_func Function mapping parameter vector equations. analytical_jac_func Analytic Jacobian function; may NULL. estimates Numeric vector solution. variance_jacobian Character; one \"auto\", \"analytic\", \"numeric\".","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/el_select_variance_jacobian.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Variance helper utilities — el_select_variance_jacobian","text":"List entries: `A_matrix_var`, `A_source`, `A_condition`,   `A_diff_norm`, `jacobian_auto_rule`.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/el_select_variance_jacobian.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Variance helper utilities — el_select_variance_jacobian","text":"Tuning options (set via options()):  - nmar.var_auto_rel_diff_thr: relative Frobenius threshold analytic    numeric Jacobians \"auto\" selector (default 1e-3).  - nmar.var_auto_kappa_ratio_thr: condition-number ratio gate switch    analytic numeric \"auto\" mode (default 10).  - nmar.var_auto_kappa_ridge_thr: singularity threshold enable ridge    stabilization variance inversion (default 1e12).  - nmar.var_auto_kappa_pinv_thr: singularity threshold enable pseudo-    inverse variance inversion (default 1e14).  - nmar.var_ridge_base: base adaptive ridge epsilon (default 1e-6).","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/el_select_variance_jacobian.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Variance helper utilities — el_select_variance_jacobian","text":"Qin, J., Leung, D., Shao, J. (2002). Estimation survey data nonignorable nonresponse informative sampling. Journal American Statistical Association, 97(457), 193–200.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/engine_traits.html","id":null,"dir":"Reference","previous_headings":"","what":"Engine trait declarations — engine_traits","title":"Engine trait declarations — engine_traits","text":"Engines can override generic relax tighten validation checks. defaults match historical behavior exponential tilting engines.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/engine_traits.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Engine trait declarations — engine_traits","text":"","code":"engine_traits(engine)"},{"path":"https://ncn-foreigners.github.io/NMAR/reference/exptilt.html","id":null,"dir":"Reference","previous_headings":"","what":"Exponential tilting estimator — exptilt","title":"Exponential tilting estimator — exptilt","text":"Generic exponential tilting (ET) estimator NMAR.   Methods provided `data.frame` `survey.design`.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/exptilt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Exponential tilting estimator — exptilt","text":"","code":"exptilt(data, ...)"},{"path":"https://ncn-foreigners.github.io/NMAR/reference/exptilt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Exponential tilting estimator — exptilt","text":"data `data.frame` `survey.design`. ... Passed class-specific methods.","code":""},{"path":[]},{"path":"https://ncn-foreigners.github.io/NMAR/reference/exptilt_engine.html","id":null,"dir":"Reference","previous_headings":"","what":"Exponential tilting engine for NMAR estimation — exptilt_engine","title":"Exponential tilting engine for NMAR estimation — exptilt_engine","text":"Build configuration object exponential tilting (ET) estimator -missing--random (NMAR) missingness. configuration controls missingness link, outcome density model, scaling, variance computation, solver behaviour. Pass resulting engine [nmar()] fit ET estimator.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/exptilt_engine.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Exponential tilting engine for NMAR estimation — exptilt_engine","text":"","code":"exptilt_engine(   standardize = TRUE,   on_failure = c(\"return\", \"error\"),   variance_method = c(\"delta\", \"bootstrap\"),   bootstrap_reps = 10,   supress_warnings = FALSE,   auxiliary_means = NULL,   control = list(),   family = c(\"logit\", \"probit\"),   y_dens = c(\"auto\", \"normal\", \"lognormal\", \"exponential\"),   min_iter = 10,   max_iter = 100,   optim_method = c(\"Newton\", \"Broyden\"),   tol_value = 1e-05 )"},{"path":"https://ncn-foreigners.github.io/NMAR/reference/exptilt_engine.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Exponential tilting engine for NMAR estimation — exptilt_engine","text":"standardize Logical; standardise covariates prior optimisation. on_failure One `\"return\"` `\"error\"`; governs happens solver fails converge. variance_method Variance estimator use (`\"delta\"` `\"bootstrap\"`). bootstrap_reps Integer number bootstrap replications `variance_method = \"bootstrap\"`. supress_warnings Logical; suppress variance-related warnings. auxiliary_means Optional named numeric vector population moments auxiliary covariates. control Optional list additional solver controls. family Missingness link function (`\"logit\"` `\"probit\"`). y_dens Outcome density model (`\"auto\"`, `\"normal\"`, `\"lognormal\"`, `\"exponential\"`). min_iter Minimum number solver iterations. (migrated `control` future release.) max_iter Maximum number solver iterations. (migrated `control` future release.) optim_method Solver used response model (`\"Newton\"` `\"Broyden\"`). (migrated `control` future release.) tol_value Convergence tolerance optimisation routine. (migrated `control` future release.)","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/exptilt_engine.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Exponential tilting engine for NMAR estimation — exptilt_engine","text":"list class `c(\"nmar_engine_exptilt\", \"nmar_engine\")`.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/exptilt_nonparam_engine.html","id":null,"dir":"Reference","previous_headings":"","what":"Nonparametric exponential tilting engine — exptilt_nonparam_engine","title":"Nonparametric exponential tilting engine — exptilt_nonparam_engine","text":"Build configuration nonparametric exponential-tilting EM estimator used NMAR problems grouped outcomes refusal counts. Pass resulting engine [nmar()] together appropriate formula data.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/exptilt_nonparam_engine.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Nonparametric exponential tilting engine — exptilt_nonparam_engine","text":"","code":"exptilt_nonparam_engine(refusal_col, max_iter = 100, tol_value = 1e-06)"},{"path":"https://ncn-foreigners.github.io/NMAR/reference/exptilt_nonparam_engine.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Nonparametric exponential tilting engine — exptilt_nonparam_engine","text":"refusal_col Column name `data` containing refusal counts. max_iter Maximum number EM iterations. tol_value Convergence tolerance EM updates.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/exptilt_nonparam_engine.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Nonparametric exponential tilting engine — exptilt_nonparam_engine","text":"list class `c(\"nmar_engine_exptilt_nonparam\", \"nmar_engine\")`.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/extract_nleqslv_top.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract top-level nleqslv arguments from a control-like list — extract_nleqslv_top","title":"Extract top-level nleqslv arguments from a control-like list — extract_nleqslv_top","text":"Extract top-level nleqslv arguments control-like list","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/extract_nleqslv_top.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract top-level nleqslv arguments from a control-like list — extract_nleqslv_top","text":"","code":"extract_nleqslv_top(ctrl)"},{"path":"https://ncn-foreigners.github.io/NMAR/reference/fitted.nmar_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Default fitted values for NMAR results — fitted.nmar_result","title":"Default fitted values for NMAR results — fitted.nmar_result","text":"Returns fitted response probabilities available.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/fitted.nmar_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Default fitted values for NMAR results — fitted.nmar_result","text":"","code":"# S3 method for class 'nmar_result' fitted(object, ...)"},{"path":"https://ncn-foreigners.github.io/NMAR/reference/fitted.nmar_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Default fitted values for NMAR results — fitted.nmar_result","text":"object `nmar_result` object. ... Ignored.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/fitted.nmar_result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Default fitted values for NMAR results — fitted.nmar_result","text":"numeric vector (possibly length 0).","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/formula.nmar_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Default formula for NMAR results — formula.nmar_result","title":"Default formula for NMAR results — formula.nmar_result","text":"Returns estimation formula available.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/formula.nmar_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Default formula for NMAR results — formula.nmar_result","text":"","code":"# S3 method for class 'nmar_result' formula(x, ...)"},{"path":"https://ncn-foreigners.github.io/NMAR/reference/formula.nmar_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Default formula for NMAR results — formula.nmar_result","text":"x `nmar_result` object. ... Ignored.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/formula.nmar_result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Default formula for NMAR results — formula.nmar_result","text":"formula `NULL`.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/get_eta_cap.html","id":null,"dir":"Reference","previous_headings":"","what":"Numerical helpers — get_eta_cap","title":"Numerical helpers — get_eta_cap","text":"Numerical helpers","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/get_eta_cap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Numerical helpers — get_eta_cap","text":"","code":"get_eta_cap()"},{"path":"https://ncn-foreigners.github.io/NMAR/reference/glance.nmar_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Glance summary for NMAR results — glance.nmar_result","title":"Glance summary for NMAR results — glance.nmar_result","text":"One-row diagnostics NMAR fits.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/glance.nmar_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Glance summary for NMAR results — glance.nmar_result","text":"","code":"glance.nmar_result(x, ...)"},{"path":"https://ncn-foreigners.github.io/NMAR/reference/glance.nmar_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Glance summary for NMAR results — glance.nmar_result","text":"x object class `nmar_result`. ... Ignored.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/invert_jacobian.html","id":null,"dir":"Reference","previous_headings":"","what":"Invert a Jacobian matrix with numerically robust fallbacks. — invert_jacobian","title":"Invert a Jacobian matrix with numerically robust fallbacks. — invert_jacobian","text":"Attempts plain inverse matrix well conditioned, otherwise applies ridge regularisation pseudo-inverse requested.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/invert_jacobian.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Invert a Jacobian matrix with numerically robust fallbacks. — invert_jacobian","text":"","code":"invert_jacobian(   A_matrix,   variance_ridge = FALSE,   variance_pseudoinverse = FALSE,   kappa_threshold = 1e+08,   ridge_scale = NULL,   svd_tol = NULL )"},{"path":"https://ncn-foreigners.github.io/NMAR/reference/invert_jacobian.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Invert a Jacobian matrix with numerically robust fallbacks. — invert_jacobian","text":"A_matrix Numeric square matrix invert. variance_ridge Logical positive numeric: apply ridge stabilisation (`TRUE` selects adaptive ridge, numeric values supply ridge size). variance_pseudoinverse Logical; `TRUE`, compute SVD-based pseudo-inverse. kappa_threshold Numeric tolerance controlling plain inverse attempted. ridge_scale Optional numeric multiplier adaptive ridge. svd_tol Optional numeric tolerance singular values truncated forming pseudo-inverse.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/logit_family.html","id":null,"dir":"Reference","previous_headings":"","what":"Logit family functions (link and derivatives) — logit_family","title":"Logit family functions (link and derivatives) — logit_family","text":"Logit family functions (link derivatives)","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/logit_family.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Logit family functions (link and derivatives) — logit_family","text":"","code":"logit_family()"},{"path":"https://ncn-foreigners.github.io/NMAR/reference/merge_nleqslv_top.html","id":null,"dir":"Reference","previous_headings":"","what":"Prefer explicit solver_args over control-provided top-level args — merge_nleqslv_top","title":"Prefer explicit solver_args over control-provided top-level args — merge_nleqslv_top","text":"Prefer explicit solver_args control-provided top-level args","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/merge_nleqslv_top.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prefer explicit solver_args over control-provided top-level args — merge_nleqslv_top","text":"","code":"merge_nleqslv_top(solver_args, control_top)"},{"path":"https://ncn-foreigners.github.io/NMAR/reference/new_nmar_engine_el.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct EL Engine Object — new_nmar_engine_el","title":"Construct EL Engine Object — new_nmar_engine_el","text":"Construct EL Engine Object","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/new_nmar_engine_el.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct EL Engine Object — new_nmar_engine_el","text":"","code":"new_nmar_engine_el(engine)"},{"path":"https://ncn-foreigners.github.io/NMAR/reference/new_nmar_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct Result Object (parent helper) — new_nmar_result","title":"Construct Result Object (parent helper) — new_nmar_result","text":"Builds normalized `nmar_result` list using modern schema. Engines must pass named fields; legacy positional signature supported.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/new_nmar_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct Result Object (parent helper) — new_nmar_result","text":"","code":"new_nmar_result(...)"},{"path":"https://ncn-foreigners.github.io/NMAR/reference/new_nmar_result_el.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct EL Result Object — new_nmar_result_el","title":"Construct EL Result Object — new_nmar_result_el","text":"Construct EL Result Object","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/new_nmar_result_el.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct EL Result Object — new_nmar_result_el","text":"","code":"new_nmar_result_el(   y_hat,   se,   weights,   coefficients,   vcov,   converged,   diagnostics,   data_info,   nmar_scaling_recipe,   fitted_values,   call )"},{"path":"https://ncn-foreigners.github.io/NMAR/reference/new_nmar_task.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a normalized NMAR task object — new_nmar_task","title":"Create a normalized NMAR task object — new_nmar_task","text":"Create normalized NMAR task object","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/new_nmar_task.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a normalized NMAR task object — new_nmar_task","text":"","code":"new_nmar_task(spec, traits)"},{"path":"https://ncn-foreigners.github.io/NMAR/reference/new_nmar_task.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a normalized NMAR task object — new_nmar_task","text":"spec Parsed NMAR specification produced [parse_nmar_spec()]. traits Engine traits returned [engine_traits()].","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/nmar.html","id":null,"dir":"Reference","previous_headings":"","what":"Not Missing at Random (NMAR) Estimation — nmar","title":"Not Missing at Random (NMAR) Estimation — nmar","text":"Provides unified interface Missing Random (NMAR) estimation.   function orchestrates estimation process validating inputs   dispatching appropriate engine based provided `engine` object.   ensures necessary data model specifications correctly   formatted computation begins.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/nmar.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Not Missing at Random (NMAR) Estimation — nmar","text":"","code":"nmar(formula, data, engine, response_predictors = NULL)"},{"path":"https://ncn-foreigners.github.io/NMAR/reference/nmar.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Not Missing at Random (NMAR) Estimation — nmar","text":"formula two-sided formula form `y_miss ~ x1 + x2 + ...` specifying outcome (`NA` values indicating nonresponse) auxiliary variables used stabilise estimation. data data frame `survey.design` containing variables referenced formula. engine engine configuration object, typically created engine constructor function like `exptilt()`. object defines specific NMAR estimation method parameters. must inherit class `nmar_engine`. response_predictors Optional character vector naming additional predictors response (missingness) model. variables need appear right-hand side `formula` interpreted chosen engine.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/nmar.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Not Missing at Random (NMAR) Estimation — nmar","text":"object containing estimation results, whose structure   specific `engine` used. might include estimated parameters,   convergence information, relevant output chosen NMAR method.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/nmar_format_call_line.html","id":null,"dir":"Reference","previous_headings":"","what":"Format an abridged call line for printing — nmar_format_call_line","title":"Format an abridged call line for printing — nmar_format_call_line","text":"Builds concise one-line summary original call without materializing large objects (e.g., full data frames). Intended use print/summary methods.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/nmar_format_call_line.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Format an abridged call line for printing — nmar_format_call_line","text":"","code":"nmar_format_call_line(x)"},{"path":"https://ncn-foreigners.github.io/NMAR/reference/nmar_format_call_line.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Format an abridged call line for printing — nmar_format_call_line","text":"Uses option `nmar.show_call` (default TRUE). Width can tuned via option `nmar.call_width` (default 120), formatter aims keep line compact regardless width.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/nmar_result_get_estimate.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal helpers for nmar_result objects — nmar_result_get_estimate","title":"Internal helpers for nmar_result objects — nmar_result_get_estimate","text":"Internal helpers nmar_result objects","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/nmar_result_get_estimate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal helpers for nmar_result objects — nmar_result_get_estimate","text":"","code":"nmar_result_get_estimate(x)"},{"path":"https://ncn-foreigners.github.io/NMAR/reference/nmar_result_s3_parent.html","id":null,"dir":"Reference","previous_headings":"","what":"Parent S3 surface for NMAR results — nmar_result_s3_parent","title":"Parent S3 surface for NMAR results — nmar_result_s3_parent","text":"Methods apply parent `nmar_result` class   specific particular engine (e.g., EL). Engines return child class   (e.g., `nmar_result_el`) inherits `nmar_result` may override   extend behavior.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/nmar_result_s3_parent.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Parent S3 surface for NMAR results — nmar_result_s3_parent","text":"S3 surface base `nmar_result` Result objects expose universal schema:   - `estimate`, `estimate_name`, `std_error`, `converged`.   - `model`: list `coefficients`, `vcov`, plus optional extras.   - `weights_info`: list respondent weights trimming metadata.   - `sample`: list total units, respondent count, survey flag, `design`.   - `inference`: variance metadata (`variance_method`, `df`, diagnostic flags).   - `diagnostics`, `meta`, `extra` estimator-specific details. New engines populate components constructors rely   `nmar_result_get_*` utilities implementing child-specific S3   methods.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/parse_nmar_spec.html","id":null,"dir":"Reference","previous_headings":"","what":"NMAR input parsing and validation helpers — parse_nmar_spec","title":"NMAR input parsing and validation helpers — parse_nmar_spec","text":"developer-facing utilities centralize parsing user supplied formulas/data allow engines declare small trait lists control validation strictness. Keeping argument checks one place ensures consistent error messages makes easier extend package additional engines.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/parse_nmar_spec.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"NMAR input parsing and validation helpers — parse_nmar_spec","text":"","code":"parse_nmar_spec(   formula,   data,   response_predictors = NULL,   env = parent.frame() )"},{"path":"https://ncn-foreigners.github.io/NMAR/reference/plot.nmar_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Base plotting for NMAR results — plot.nmar_result","title":"Base plotting for NMAR results — plot.nmar_result","text":"Quick base plots weights, fitted probabilities, constraints diagnostics.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/plot.nmar_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Base plotting for NMAR results — plot.nmar_result","text":"","code":"# S3 method for class 'nmar_result' plot(x, which = c(\"weights\", \"fitted\", \"constraints\", \"diagnostics\"), ...)"},{"path":"https://ncn-foreigners.github.io/NMAR/reference/plot.nmar_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Base plotting for NMAR results — plot.nmar_result","text":"x object class `nmar_result`. plot: one `\"weights\"`, `\"fitted\"`, `\"constraints\"`, `\"diagnostics\"`. ... Ignored.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/prepare_el_inputs.html","id":null,"dir":"Reference","previous_headings":"","what":"Prepare inputs for EL estimation — prepare_el_inputs","title":"Prepare inputs for EL estimation — prepare_el_inputs","text":"Prepare inputs EL estimation","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/prepare_el_inputs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prepare inputs for EL estimation — prepare_el_inputs","text":"","code":"prepare_el_inputs(formula, data, response_predictors)"},{"path":"https://ncn-foreigners.github.io/NMAR/reference/prepare_el_inputs.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Prepare inputs for EL estimation — prepare_el_inputs","text":"Validates two-sided outcome formula constructs three   internal formulas: outcome (~ outcome_var), response (missingness   model), auxiliary (RHS , intercept). `response_predictors`   may include variables outcome RHS; variables enter   response model (auxiliary moment constraint). variables   outcome RHS treated auxiliaries , provided, must match   names `auxiliary_means`. See Qin, Leung Shao (2002) EL   formulation.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/prepare_nmar_design.html","id":null,"dir":"Reference","previous_headings":"","what":"Prepare common NMAR design components — prepare_nmar_design","title":"Prepare common NMAR design components — prepare_nmar_design","text":"Prepare common NMAR design components","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/prepare_nmar_design.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prepare common NMAR design components — prepare_nmar_design","text":"","code":"prepare_nmar_design(   task,   standardize = TRUE,   auxiliary_means = NULL,   include_response = TRUE,   include_auxiliary = TRUE,   data = task$data,   design_weights = NULL )"},{"path":"https://ncn-foreigners.github.io/NMAR/reference/prepare_nmar_design.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prepare common NMAR design components — prepare_nmar_design","text":"task object created [new_nmar_task()]. standardize Logical flag forwarded engines. auxiliary_means Optional named vector auxiliary means. include_response Logical; include response predictors. include_auxiliary Logical; include auxiliary predictors. data Optional override data-frame backing task. design_weights Optional numeric vector design weights.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/prepare_nmar_design.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Prepare common NMAR design components — prepare_nmar_design","text":"list containing trimmed data, predictor sets, weights, survey   design (applicable), formula, standardization settings.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/prepare_nmar_scaling.html","id":null,"dir":"Reference","previous_headings":"","what":"Prepare scaled matrices and moments (low-level) — prepare_nmar_scaling","title":"Prepare scaled matrices and moments (low-level) — prepare_nmar_scaling","text":"Prepare scaled matrices moments (low-level)","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/prepare_nmar_scaling.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prepare scaled matrices and moments (low-level) — prepare_nmar_scaling","text":"","code":"prepare_nmar_scaling(   Z_un,   X_un,   mu_x_un,   standardize,   weights = NULL,   weight_mask = NULL )"},{"path":"https://ncn-foreigners.github.io/NMAR/reference/prepare_nmar_scaling.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prepare scaled matrices and moments (low-level) — prepare_nmar_scaling","text":"Z_un response model matrix (intercept column). X_un auxiliary model matrix (intercept), NULL. mu_x_un named numeric vector auxiliary means original scale (names must match `colnames(X_un)`), NULL. standardize logical; apply standardization TRUE. weights Optional numeric vector used weighted scaling. weight_mask Optional logical/numeric mask applied `weights`.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/prepare_nmar_scaling.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Prepare scaled matrices and moments (low-level) — prepare_nmar_scaling","text":"list `Z`, `X`, `mu_x`, `recipe`.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/print.nmar_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for nmar_result — print.nmar_result","title":"Print method for nmar_result — print.nmar_result","text":"Print method nmar_result","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/print.nmar_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for nmar_result — print.nmar_result","text":"","code":"# S3 method for class 'nmar_result' print(x, ...)"},{"path":"https://ncn-foreigners.github.io/NMAR/reference/print.nmar_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for nmar_result — print.nmar_result","text":"x nmar_result object ... Additional parameters","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/print.nmar_result_el.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for EL results — print.nmar_result_el","title":"Print method for EL results — print.nmar_result_el","text":"Compact print objects class `nmar_result_el`.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/print.nmar_result_el.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for EL results — print.nmar_result_el","text":"","code":"# S3 method for class 'nmar_result_el' print(x, ...)"},{"path":"https://ncn-foreigners.github.io/NMAR/reference/print.nmar_result_el.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for EL results — print.nmar_result_el","text":"x object class `nmar_result_el`. ... Ignored.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/print.summary_nmar_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for summary.nmar_result — print.summary_nmar_result","title":"Print method for summary.nmar_result — print.summary_nmar_result","text":"Print method summary.nmar_result","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/print.summary_nmar_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for summary.nmar_result — print.summary_nmar_result","text":"","code":"# S3 method for class 'summary_nmar_result' print(x, ...)"},{"path":"https://ncn-foreigners.github.io/NMAR/reference/print.summary_nmar_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for summary.nmar_result — print.summary_nmar_result","text":"x summary_nmar_result object ... Additional parameters","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/probit_family.html","id":null,"dir":"Reference","previous_headings":"","what":"Probit family functions (link and derivatives) — probit_family","title":"Probit family functions (link and derivatives) — probit_family","text":"Probit family functions (link derivatives)","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/probit_family.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Probit family functions (link and derivatives) — probit_family","text":"","code":"probit_family()"},{"path":"https://ncn-foreigners.github.io/NMAR/reference/run_engine.nmar_engine_el.html","id":null,"dir":"Reference","previous_headings":"","what":"Run method for EL engine — run_engine.nmar_engine_el","title":"Run method for EL engine — run_engine.nmar_engine_el","text":"Run method EL engine","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/run_engine.nmar_engine_el.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run method for EL engine — run_engine.nmar_engine_el","text":"","code":"# S3 method for class 'nmar_engine_el' run_engine(engine, task)"},{"path":"https://ncn-foreigners.github.io/NMAR/reference/sanitize_nleqslv_control.html","id":null,"dir":"Reference","previous_headings":"","what":"Sanitize nleqslv control list for compatibility — sanitize_nleqslv_control","title":"Sanitize nleqslv control list for compatibility — sanitize_nleqslv_control","text":"Sanitize nleqslv control list compatibility","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/sanitize_nleqslv_control.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sanitize nleqslv control list for compatibility — sanitize_nleqslv_control","text":"","code":"sanitize_nleqslv_control(ctrl)"},{"path":"https://ncn-foreigners.github.io/NMAR/reference/summary.nmar_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Summary method for nmar_result — summary.nmar_result","title":"Summary method for nmar_result — summary.nmar_result","text":"Summary method nmar_result","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/summary.nmar_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summary method for nmar_result — summary.nmar_result","text":"","code":"# S3 method for class 'nmar_result' summary(object, conf.level = 0.95, ...)"},{"path":"https://ncn-foreigners.github.io/NMAR/reference/summary.nmar_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summary method for nmar_result — summary.nmar_result","text":"object nmar_result object conf.level Confidence level intervals. ... Additional parameters","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/summary.nmar_result_el.html","id":null,"dir":"Reference","previous_headings":"","what":"Summary method for EL results — summary.nmar_result_el","title":"Summary method for EL results — summary.nmar_result_el","text":"Summarize estimation, standard error response-model coefficients.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/summary.nmar_result_el.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summary method for EL results — summary.nmar_result_el","text":"","code":"# S3 method for class 'nmar_result_el' summary(object, ...)"},{"path":"https://ncn-foreigners.github.io/NMAR/reference/summary.nmar_result_el.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summary method for EL results — summary.nmar_result_el","text":"object object class `nmar_result_el`. ... Ignored.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/tidy.nmar_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Tidy summary for NMAR results — tidy.nmar_result","title":"Tidy summary for NMAR results — tidy.nmar_result","text":"Return data frame primary estimate (available) response-model coefficients.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/tidy.nmar_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tidy summary for NMAR results — tidy.nmar_result","text":"","code":"tidy.nmar_result(x, conf.level = 0.95, ...)"},{"path":"https://ncn-foreigners.github.io/NMAR/reference/tidy.nmar_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Tidy summary for NMAR results — tidy.nmar_result","text":"x object class `nmar_result`. conf.level Confidence level primary estimate. ... Ignored.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/trim_weights.html","id":null,"dir":"Reference","previous_headings":"","what":"Weight utilities — trim_weights","title":"Weight utilities — trim_weights","text":"Weight utilities","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/trim_weights.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Weight utilities — trim_weights","text":"","code":"trim_weights(weights, cap)"},{"path":"https://ncn-foreigners.github.io/NMAR/reference/unscale_coefficients.html","id":null,"dir":"Reference","previous_headings":"","what":"Unscale regression coefficients and covariance — unscale_coefficients","title":"Unscale regression coefficients and covariance — unscale_coefficients","text":"Unscale regression coefficients covariance","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/unscale_coefficients.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Unscale regression coefficients and covariance — unscale_coefficients","text":"","code":"unscale_coefficients(scaled_coeffs, scaled_vcov, recipe)"},{"path":"https://ncn-foreigners.github.io/NMAR/reference/unscale_coefficients.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Unscale regression coefficients and covariance — unscale_coefficients","text":"scaled_coeffs named numeric vector coefficients estimated scaled space. scaled_vcov covariance matrix `scaled_coeffs`. recipe `nmar_scaling_recipe` produced scaling applied.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/unscale_coefficients.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Unscale regression coefficients and covariance — unscale_coefficients","text":"list unscaled `coefficients` `vcov`.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/validate_and_apply_nmar_scaling.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate and apply scaling (engine-friendly) — validate_and_apply_nmar_scaling","title":"Validate and apply scaling (engine-friendly) — validate_and_apply_nmar_scaling","text":"Validate apply scaling (engine-friendly)","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/validate_and_apply_nmar_scaling.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate and apply scaling (engine-friendly) — validate_and_apply_nmar_scaling","text":"","code":"validate_and_apply_nmar_scaling(   standardize,   has_aux,   response_model_matrix_unscaled,   auxiliary_matrix_unscaled,   mu_x_unscaled,   weights = NULL,   weight_mask = NULL )"},{"path":"https://ncn-foreigners.github.io/NMAR/reference/validate_and_apply_nmar_scaling.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Validate and apply scaling (engine-friendly) — validate_and_apply_nmar_scaling","text":"standardize logical; apply standardization TRUE. has_aux logical; whether engine uses auxiliary constraints. response_model_matrix_unscaled response model matrix (intercept). auxiliary_matrix_unscaled auxiliary matrix (intercept) empty matrix. mu_x_unscaled named auxiliary means original scale, NULL. weights Optional numeric vector used weighted scaling. weight_mask Optional logical/numeric mask applied `weights`.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/validate_and_apply_nmar_scaling.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Validate and apply scaling (engine-friendly) — validate_and_apply_nmar_scaling","text":"list `nmar_scaling_recipe`, `response_model_matrix_scaled`,   `auxiliary_matrix_scaled`, `mu_x_scaled`.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/validate_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate Data for NMAR Analysis — validate_data","title":"Validate Data for NMAR Analysis — validate_data","text":"robust function validate data frame survey object performing NMAR analysis. function checks common errors like missing variables, data type inconsistencies, inappropriate variable overlaps. provides detailed, actionable error messages facilitate debugging.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/validate_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate Data for NMAR Analysis — validate_data","text":"","code":"validate_data(   data,   outcome_variable,   covariates_for_outcome,   covariates_for_missingness = character(),   allow_outcome_in_missingness = FALSE,   allow_covariate_overlap = FALSE )"},{"path":"https://ncn-foreigners.github.io/NMAR/reference/validate_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Validate Data for NMAR Analysis — validate_data","text":"data data frame survey object. outcome_variable string specifying outcome variable, expected contain NA values. covariates_for_outcome character vector covariates explaining outcome. covariates_for_missingness character vector covariates explaining missingness. allow_outcome_in_missingness Logical; allow outcome also appear response-model covariates (default `FALSE`). allow_covariate_overlap Logical; allow overlap outcome response covariate sets (default `FALSE`).","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/validate_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Validate Data for NMAR Analysis — validate_data","text":"Returns `invisible(NULL)` success, stopping descriptive error failure.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/validate_nmar_args.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate parsed NMAR inputs — validate_nmar_args","title":"Validate parsed NMAR inputs — validate_nmar_args","text":"Validate parsed NMAR inputs","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/validate_nmar_args.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate parsed NMAR inputs — validate_nmar_args","text":"","code":"validate_nmar_args(spec, traits = list())"},{"path":"https://ncn-foreigners.github.io/NMAR/reference/validate_nmar_args.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Validate parsed NMAR inputs — validate_nmar_args","text":"spec Object produced [parse_nmar_spec()]. traits List engine traits produced [engine_traits()].","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/validate_nmar_engine_el.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate EL Engine Settings — validate_nmar_engine_el","title":"Validate EL Engine Settings — validate_nmar_engine_el","text":"Validate EL Engine Settings","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/validate_nmar_engine_el.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate EL Engine Settings — validate_nmar_engine_el","text":"","code":"validate_nmar_engine_el(engine)"},{"path":"https://ncn-foreigners.github.io/NMAR/reference/validate_nmar_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate nmar_result structure — validate_nmar_result","title":"Validate nmar_result structure — validate_nmar_result","text":"Ensures child class parent schema satisfied. validator also back-fills defaults downstream code can rely presence optional components without defensive checks.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/validate_nmar_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate nmar_result structure — validate_nmar_result","text":"","code":"validate_nmar_result(x, class_name)"},{"path":"https://ncn-foreigners.github.io/NMAR/reference/validator.html","id":null,"dir":"Reference","previous_headings":"","what":"Custom Validation Module — validator","title":"Custom Validation Module — validator","text":"module provides set internal helper functions argument validation. functions designed throw clear error message validation check fails.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/validator.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Custom Validation Module — validator","text":"","code":"validator"},{"path":"https://ncn-foreigners.github.io/NMAR/reference/validator.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Custom Validation Module — validator","text":"object class environment length 4.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/validator_assert_choice.html","id":null,"dir":"Reference","previous_headings":"","what":"Assert Choice — validator_assert_choice","title":"Assert Choice — validator_assert_choice","text":"Checks value one allowed choices.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/validator_assert_choice.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Assert Choice — validator_assert_choice","text":"x value check. choices vector allowed choices. name string representing name argument checked.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/validator_assert_choice.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Assert Choice — validator_assert_choice","text":"Returns nothing success, stops error failure.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/validator_assert_logical.html","id":null,"dir":"Reference","previous_headings":"","what":"Assert Logical — validator_assert_logical","title":"Assert Logical — validator_assert_logical","text":"Checks value single logical value.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/validator_assert_logical.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Assert Logical — validator_assert_logical","text":"x value check. name string representing name argument checked.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/validator_assert_logical.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Assert Logical — validator_assert_logical","text":"Returns nothing success, stops error failure.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/validator_assert_number.html","id":null,"dir":"Reference","previous_headings":"","what":"Assert Number — validator_assert_number","title":"Assert Number — validator_assert_number","text":"Checks value number within specified range.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/validator_assert_number.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Assert Number — validator_assert_number","text":"x value check. name string representing name argument checked. min minimum allowed value (inclusive). Defaults -Inf. max maximum allowed value (inclusive). Defaults Inf.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/validator_assert_number.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Assert Number — validator_assert_number","text":"Returns nothing success, stops error failure.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/validator_assert_positive_integer.html","id":null,"dir":"Reference","previous_headings":"","what":"Assert Positive Integer — validator_assert_positive_integer","title":"Assert Positive Integer — validator_assert_positive_integer","text":"Checks value single, positive, optionally finite integer.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/validator_assert_positive_integer.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Assert Positive Integer — validator_assert_positive_integer","text":"x value check. name string representing name argument checked. .finite logical value. TRUE (default), checks number finite.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/validator_assert_positive_integer.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Assert Positive Integer — validator_assert_positive_integer","text":"Returns nothing success. Stops clear error failure.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/validator_is_positive.html","id":null,"dir":"Reference","previous_headings":"","what":"Checks if a value is a single positive number. — validator_is_positive","title":"Checks if a value is a single positive number. — validator_is_positive","text":"Checks value single positive number.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/validator_is_positive.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Checks if a value is a single positive number. — validator_is_positive","text":"","code":"is_positive(x)"},{"path":"https://ncn-foreigners.github.io/NMAR/reference/validator_is_positive.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Checks if a value is a single positive number. — validator_is_positive","text":"x numeric value.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/validator_is_positive.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Checks if a value is a single positive number. — validator_is_positive","text":"logical value.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/vcov.nmar_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Variance-covariance for base NMAR results — vcov.nmar_result","title":"Variance-covariance for base NMAR results — vcov.nmar_result","text":"Variance-covariance base NMAR results","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/vcov.nmar_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Variance-covariance for base NMAR results — vcov.nmar_result","text":"","code":"# S3 method for class 'nmar_result' vcov(object, ...)"},{"path":"https://ncn-foreigners.github.io/NMAR/reference/vcov.nmar_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Variance-covariance for base NMAR results — vcov.nmar_result","text":"object object class `nmar_result`. ... Ignored.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/weights.nmar_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Default weights for NMAR results — weights.nmar_result","title":"Default weights for NMAR results — weights.nmar_result","text":"Returns respondent weights trimmed_fraction attribute present.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/weights.nmar_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Default weights for NMAR results — weights.nmar_result","text":"","code":"# S3 method for class 'nmar_result' weights(object, ...)"},{"path":"https://ncn-foreigners.github.io/NMAR/reference/weights.nmar_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Default weights for NMAR results — weights.nmar_result","text":"object `nmar_result` object. ... Ignored.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/reference/weights.nmar_result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Default weights for NMAR results — weights.nmar_result","text":"numeric vector (possibly length 0); attribute `trimmed_fraction` may set.","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/news/index.html","id":"nmar-development-version","dir":"Changelog","previous_headings":"","what":"NMAR (development version)","title":"NMAR (development version)","text":"Preparing CRAN deploy","code":""},{"path":[]},{"path":"https://ncn-foreigners.github.io/NMAR/news/index.html","id":"major-changes-0-0-0-1","dir":"Changelog","previous_headings":"","what":"Major changes","title":"NMAR 0.0.0.1","text":"Exptilt, el share similar structure design (#27)","code":""},{"path":"https://ncn-foreigners.github.io/NMAR/news/index.html","id":"minor-improvements-and-bug-fixes-0-0-0-1","dir":"Changelog","previous_headings":"","what":"Minor improvements and bug fixes","title":"NMAR 0.0.0.1","text":"feature 1 feature 2","code":""}]
