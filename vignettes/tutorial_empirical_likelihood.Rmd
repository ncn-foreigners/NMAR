---
title: "Empirical Likelihood Estimator for NMAR"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Empirical Likelihood Estimator for NMAR}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
set.seed(123)
library(NMAR)
```

# Overview

This vignette demonstrates the empirical likelihood (EL) estimator for Not Missing At Random (NMAR) data in the `nmar` package. The method implements the estimator of Qin, Leung, and Shao (2002), using empirical likelihood weights that satisfy estimating equations for the response mechanism and (optionally) auxiliary moment constraints. For full derivations and the analytic Jacobian/variance details, see the companion article “Empirical Likelihood Theory for NMAR”.

Key features:

- Supports `data.frame` (IID) and `survey.design` objects (design-based variance) via the same `nmar()` API.
- Variance via delta (analytical sandwich) or bootstrap.
- Optional standardization of predictors; weight trimming for robustness.
- Rich S3 surface: `summary()`, `confint()`, `tidy()`, `glance()`, `plot()`/`autoplot()`.

## Quick start

- Specify the model via a formula list: `list(outcome = ~ Y_miss, covariates_outcome = ~ X1 + X2, covariates_missingness = ~ Z1 + Z2)`.
  - Variables on the outcome RHS (e.g., `X1 + X2`) are auxiliaries; you can supply their known population means via `auxiliary_means = c(X1 = ..., X2 = ...)`.
  - Variables in `covariates_missingness` enter only the response model (no auxiliary constraint). They do not need population means.
- Choose the engine: `el_engine(...)`, e.g., `el_engine(auxiliary_means = c(X1 = 0), variance_method = "delta", standardize = TRUE)`.
- Fit: `nmar(formula = <list>, data = df_or_design, engine = el_engine(...))`.
- Inspect: `summary()`, `confint()`, `weights()`, `fitted()`, and `fit$diagnostics`.
# 
# Data-frame example (IID)

We simulate an NMAR mechanism where the response probability depends on the unobserved outcome.

```{r}
N <- 500
X <- rnorm(N)
Z <- rnorm(N)
Y <- 2 + 0.5 * X + Z

# NMAR response: depends on Y
p <- plogis(-1.0 + 0.4 * scale(Y)[, 1])
R <- runif(N) < p

dat <- data.frame(Y_miss = Y, X = X)
dat$Y_miss[!R] <- NA_real_
```


```{r}
engine = el_engine(auxiliary_means = c(X = 0), variance_method = "delta", standardize = TRUE
  )
# Fit EL estimator (delta variance)
fit <- nmar(
  formula = Y_miss ~ X,
  data = dat,
  engine = engine,
  response_predictors = NULL
)

summary(fit)
confint(fit)
```

Probit family (optional):

```{r}
engine = el_engine(auxiliary_means = c(X = 0), family = "probit", variance_method = "delta", standardize = TRUE)

fit_probit <- nmar(
  formula = Y_miss ~ X,
  engine = engine,
  data = dat,
  response_predictors = NULL

)
summary(fit_probit)
```

Tidy/glance summaries, and plots:

```{r}
if (requireNamespace("broom", quietly = TRUE)) {
  broom::tidy(fit)
  broom::glance(fit)
}

# plot(fit, which = "weights")
# plot(fit, which = "fitted")
```

Outputs and diagnostics at a glance:

```{r}
weights(fit)[1:10]
fitted(fit)[1:10]
str(fit$diagnostics)
```

Bootstrap variance (keep reps small for speed):

```{r}
engine = el_engine(auxiliary_means = c(X = 0), variance_method = "bootstrap", bootstrap_reps = 15, standardize = TRUE, suppress_warnings = TRUE)

fit_boot <- nmar(
  formula = Y_miss ~ X,
  engine = engine,
  data = dat,
  response_predictors = NULL

)
fit_boot$se
```

# Response-only predictors

You can include predictors that enter only the response model (and are not constrained as auxiliaries). Specify them in `covariates_missingness` while keeping the auxiliary set on the RHS of the outcome formula.

```{r}
N <- 400
X <- rnorm(N)
Z <- rnorm(N)
Y <- 1 + 0.6 * X + 0.3 * Z + rnorm(N)
p <- plogis(-0.6 + 0.5 * scale(Y)[, 1] + 0.4 * Z)
R <- runif(N) < p
df2 <- data.frame(Y_miss = Y, X = X, Z = Z)
df2$Y_miss[!R] <- NA_real_
engine = el_engine(auxiliary_means = c(X = 0), variance_method = "delta", standardize = TRUE)

# Use X as auxiliary (known population mean 0), and Z as response-only predictor
fit_resp_only <- nmar(
  formula = Y_miss ~ X,
  data = df2,
  engine = engine,
  response_predictors = c('Z')
)
summary(fit_resp_only)
```

Auxiliary means and formulas:

- Names of `auxiliary_means` must match the variables on the outcome RHS exactly.
- When `standardize = TRUE`, the engine automatically transforms `auxiliary_means` to the standardized scale internally and reports coefficients on the original scale.
- Response-only predictors (in `covariates_missingness`) do not need auxiliary means.

# Survey design example (optional)

The estimator supports complex surveys via `survey::svydesign()`. This chunk runs only if the `survey` package is available.

```{r}
if (requireNamespace("survey", quietly = TRUE)) {
  library(survey)
  data(api)

  set.seed(42)
  apiclus1$api00_miss <- apiclus1$api00
  ystd <- scale(apiclus1$api00)[, 1]
  prob <- plogis(-0.5 + 0.4 * ystd + 0.2 * scale(apiclus1$ell)[, 1])
  miss <- runif(nrow(apiclus1)) > prob
  apiclus1$api00_miss[miss] <- NA_real_

  dclus1 <- svydesign(id = ~dnum, weights = ~pw, data = apiclus1, fpc = ~fpc)
  pop_mean_ell <- mean(apiclus1$ell)
  engine = el_engine(auxiliary_means = c(ell = pop_mean_ell), variance_method = "delta", standardize = TRUE)

  fit_svy <- nmar(
    formula = api00_miss ~ ell,
    data = dclus1,
    engine = engine,
    response_predictors = NULL

  )
  summary(fit_svy)
}
```

# Practical guidance

- Variance method: The delta method is fast but asymptotic; bootstrap is often preferred for moderate samples, trimming, or near-boundary cases.
- Trimming: Use a finite `trim_cap` to improve robustness when large weights occur; prefer bootstrap variance when trimming.
- Standardization: `standardize = TRUE` typically improves numerical stability and comparability across predictors and auxiliary means.
- Diagnostics: Inspect `fit$diagnostics` (Jacobian condition number, max equation residuals, trimming fraction) to assess numerical health and identification strength.
- Response-only predictors: Variables in `covariates_missingness` do not need to appear on the RHS of the outcome formula; they enter only the response model. Auxiliary means must be supplied only for variables on the outcome RHS.
- Inconsistent auxiliaries: If provided auxiliary means are grossly inconsistent with the sample, EL weights may go negative and the solver may fail. Consider revisiting the constraints, relaxing them, or using `trim_cap` and bootstrap variance.

Troubleshooting:

- Negative or extreme weights: set a finite `trim_cap`; prefer `variance_method = "bootstrap"` for SE.
- Ill-conditioned Jacobian (large `fit$diagnostics$jacobian_condition_number`): try `variance_ridge = TRUE` or `variance_pseudoinverse = TRUE` in `el_engine(...)`.
- Convergence issues: check `fit$diagnostics$max_equation_residual`, rescale predictors (`standardize = TRUE`), or reduce the number of constraints.

# References and further reading

- Qin, J., Leung, D., and Shao, J. (2002). Estimation with survey data under nonignorable nonresponse or informative sampling. Journal of the American Statistical Association, 97(457), 193–200. doi:10.1198/016214502753479338
- For practical scripts and experiments that informed this implementation, see the package’s development materials and the validation script under `inst/validation/mc-el.R`.


# Families and numerical stability

- Family: `el_engine(family = "logit")` (default) or `family = "probit"`.
- Probit stability: the response-model score uses a stable log-ratio for $\phi/\Phi$ under the hood.
- Theory mapping: see the companion article “Empirical Likelihood Theory for NMAR” for equations, Jacobian blocks, and variance details.

```{r}
sessionInfo()
```
