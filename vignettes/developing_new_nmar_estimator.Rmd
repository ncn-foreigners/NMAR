---
title: "Developing a New NMAR Estimator"
output: rmarkdown::html_document
vignette: >
  %\VignetteIndexEntry{Developing a New NMAR Estimator}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

# Developing a New NMAR Estimator in the `nmar` Package

This guide explains how to add and integrate a new Not‑Missing‑At‑Random (NMAR)
statistical estimator into `nmar`, following the architecture used by the
Empirical Likelihood (EL) engine, emphasizing a clean separation of concerns:

- Shared, reusable utilities live in `src/shared/` (scaling, families,
  bootstrap, S3 parent methods, numerics, diagnostics).
- Estimator‑specific math and code live in `src/engines/<method>/`.

> Repository conventions
> - Always edit source under `src/`; the flat files in `R/` are generated by
>   running `Rscript build_r_folder.R`.
> - Use testthat v3 under `tests/testthat/` for tests.
> - Use roxygen2 for documentation; do not edit `NAMESPACE` directly.

---
## 0) General guidelines
1. Adhere to the functional programming style and design patterns (writing pure functions, function factories, functionals, and function operators) when appropriate (eg. building systems of equations)
2. Do not use unpredictable functions like sapply, use vapply or purrr equivalents instead
3. Avoid code duplication, reuse the shared infrastructure as much as possible
4. Develop loosely coupled, modular architecture, identify shareable, method-agnostic functionalities
5. Use S3 OOP system
6. Use constructor and validator functions for your S3 objects
7. Follow the best software engineering practices, including SOLID, DRY, KISS, YAGNI, Separation of Concerns, Principle of Least Astonishment, and Law of Demeter?

## 1) Overview of the package flow

User workflow:

1. User creates an engine configuration (e.g., `el_engine(...)`).
2. User calls `nmar(formula = ..., data = ..., engine = <engine>)`.
3. `nmar()` dispatches to `run_engine(<engine>, ...)` by S3.
4. The engine’s `run_engine.<engine_class>()` prepares arguments and calls a
   method‑specific generic, which dispatches on `data` type:
   - `*.data.frame(...)` for IID data
   - `*.survey.design(...)` for complex surveys
5. The method computes the estimator and returns a result object of class
   `c("nmar_result_<method>", "nmar_result")` containing the primary estimand
   and supporting data for S3 methods.

---

## 2) What to implement for a new estimator

Assume your engine will be named `<method>` (e.g., `exptilt2`, `abc`, etc.).

Create the following files under `src/engines/<method>/`:

### 1) `engine.R` — engine constructor

```{r}
#' <METHOD> engine for NMAR
#' @description Constructs a configuration for the <METHOD> estimator.
#' @return An engine object of class c('nmar_engine_<method>','nmar_engine').
#' @export
<method>_engine <- function(/* controls */) {
  
  #Validate controls using validate_arguments.R as in exptilt.
  #F.E: 
  validator$assert_choice(family, choices = c("logit", "probit"), name = "family")
  
  
  engine <- list(/* controls + options */)
  class(engine) <- c("nmar_engine_<method>", "nmar_engine")
  engine
}
```

### 2) `run_engine.R` — run_engine method

```{r}
#' @exportS3Method run_engine nmar_engine_<method>
run_engine.nmar_engine_<method> <- function(engine, formula, data) {
  #Get information about params
  outcome_variable <- as.vector(all.vars(formula[[2]]))
  covariates_for_outcome <- as.vector(all.vars(formula[[3]]))
  covariates_for_missingness <- response_predictors

  #Run validation on data.
  validate_data(data, outcome_variable, covariates_for_outcome, covariates_for_missingness)
  
  
  # Optionally adapt NMAR formula-list to your estimator’s inputs
  # (see EL's nmar_formula_to_el). You may reuse it if compatible.
  adapted <- list(/* formula, response predictors, etc. */)

  args <- list(
    data = data,
    formula = adapted$formula,
    # other estimator controls from engine
  )
  # Dispatch to the estimator generic (<method>()) by data type
  res <- do.call(<method>, args)
  if (!inherits(res, "nmar_result_<method>")) stop("Expected nmar_result_<method>.")
  res
}
```

### 3) `impl/<method>.R` — define the generic

```{r}
#' <METHOD> estimator (generic)
#' @param data A data.frame or survey.design.
#' @export
<method> <- function(data, ...) UseMethod("<method>")
```

### 4) `impl/<method>_dataframe.R` — method for IID data

```{r}
#' @export
<method>.data.frame <- function(data, formula, /* controls */, ...) {
  # Prepare inputs. You may adapt from EL’s prepare_el_inputs() pattern.
  parsed <- /* build outcome/response/aux formulas and data */
  estimation_data <- parsed$data
  internal_formula <- parsed$formula_list

  # Identify respondents
  response_var <- all.vars(internal_formula$response)[1]
  obs_idx <- which(estimation_data[[response_var]] == 1)

  # Build design matrices
  Z_un <- model.matrix(update(internal_formula$response, NULL ~ .), data = estimation_data[obs_idx, ])
  X_un <- /* auxiliary model matrix or empty */
  mu_x <- /* named auxiliary means on original scale, or NULL */

  # Shared scaling
  sc <- validate_and_apply_nmar_scaling(
    standardize = TRUE, has_aux = !is.null(X_un),
    response_model_matrix_unscaled = Z_un,
    auxiliary_matrix_unscaled = if (is.null(X_un)) matrix(nrow = nrow(Z_un), ncol = 0) else X_un,
    mu_x_unscaled = mu_x
  )

  # Solve on the scaled space (method-specific code)
  fit <- <solve_and_variance_core>(
    full_data = estimation_data,
    respondent_data = estimation_data[obs_idx, ],
    response_model_matrix_scaled = sc$response_model_matrix_scaled,
    auxiliary_matrix_scaled = sc$auxiliary_matrix_scaled,
    mu_x_scaled = sc$mu_x_scaled,
    /* other controls */
  )

  # Wrap into a standard result object (see Section 5)
  new_nmar_result_<method>(/* fields as described below */)
}
```

### 5) `impl/<method>_survey.R` — method for survey.design

Follow EL’s `el.survey.design` pattern:

- Subset respondents via `observed_mask`.
- Get respondent base weights via `weights(resp_design)` and set `N_pop <- sum(weights(design))`.
- Compute the covariance of “total scores” for the delta variance using
  `svytotal(~ scores, design)` followed by `vcov()`. See the **Variance**
  subsection below.

### 6) `impl/<method>_equations.R` / `impl/<method>_jacobian.R` (optional)

If your estimator uses a system of estimating equations and an analytic
Jacobian (like EL), define and document them here. Otherwise, keep method‑specific
math here (e.g., likelihood, gradients, constraints).

### 7) `impl/<method>_variance.R`

- For delta variance: assemble `A = \del(F)/\del(\theta)`, `B = Var(\Sigma(scores)` and the gradient
  of the functional `g(]theta)`. Reuse shared helpers:
  - Jacobian inversion policy: `invert_jacobian()` (ridge/pinv options).
  - IID B: cross‑product of respondent score rows “expanded” to N (zeros
    for nonrespondents).
  - Survey B: covariance of design totals via `svytotal`.
- Add option to use shared bootstrap variance helpers (`bootstrap_variance()`)
  for IID or survey designs.

### 8) `impl/<method>_constructors.R`
Use `new_nmar_result.R` in order to create `new_nmar_result_<method>`. It should 'inherit' from (de facto run) new_nmar_result, as provided in el (`new_nmar_result_el`)

Eventually it should be validated by `validate_nmar_result.R`

Using common new_nmar_result is **obligatory** to provide consistency across naming (y_hat, se etc)

Create a result constructor mirroring EL’s `new_nmar_result_el()`, returning
`structure(list(...), class = c("nmar_result_<method>", "nmar_result"))`, and a
validator. 

### 9) `s3.R` — S3 methods for your result class

Implement (or rely on parent defaults):

- `print.nmar_result_<method>()`, `summary.nmar_result_<method>()` (optional)
- `estimate()`, `vcov()`, `confint()`: the parent methods will work out of the
  box if you return `y_hat`, `se`, `data_info`, and `diagnostics`.
- Optional accessors: `weights()`, `fitted()`, `coef()`, etc., if your engine
  exposes them.

---

## 3) Reusing shared infrastructure

Use these shared modules in `src/shared/`:

### Scaling

- `validate_and_apply_nmar_scaling()` to standardize `Z`/`X` and auxiliary means
  before solving, returning an `nmar_scaling_recipe` for unscaling.
- `unscale_coefficients()` to map scaled coefficients and vcov back to the
  original scale for reporting.
- Intercept is never scaled; constant columns get sd=1. Engines may create a
  recipe from respondents‑only matrices (as in EL) or from full/design matrices.

### Families (response model)

- `logit_family()` / `probit_family()` expose `linkinv`, `mu.eta`, `d2mu.deta2`,
  and `score_eta` for link‑agnostic estimating equations and Jacobians.
- Probit uses a tail‑stable log‑ratio for `phi/Phi`.

### Bootstrap variance

- `bootstrap_variance()` S3 generic with methods for `data.frame` and
  `survey.design`.
- IID: resample rows and rerun the estimator.
- Survey: convert to bootstrap replicate weights (`svrep::as_bootstrap_design`),
  use `survey::withReplicates`, then `survey::svrVar`.

